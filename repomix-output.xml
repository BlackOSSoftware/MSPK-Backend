This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.example
.gitignore
firebase-service-account.json
google-services.json
import_crypto_top10.js
kite_raw.txt
nodemon.json
openapi.yaml
package.json
public/monitor.html
server.js
src/app.js
src/config/config.js
src/config/database.js
src/config/firebase.js
src/config/logger.js
src/config/notificationTemplates.js
src/controllers/admin.controller.js
src/controllers/analytics.controller.js
src/controllers/announcement.controller.js
src/controllers/auth.controller.js
src/controllers/bot.controller.js
src/controllers/cms.controller.js
src/controllers/dashboard.controller.js
src/controllers/economic.controller.js
src/controllers/health.controller.js
src/controllers/lead.controller.js
src/controllers/market.controller.js
src/controllers/notification.controller.js
src/controllers/payment.controller.js
src/controllers/plan.controller.js
src/controllers/search.controller.js
src/controllers/setting.controller.js
src/controllers/signal.controller.js
src/controllers/strategy.controller.js
src/controllers/subBroker.controller.js
src/controllers/subscription.controller.js
src/controllers/ticket.controller.js
src/controllers/watchlist.controller.js
src/data/alltick_popular.js
src/jobs/subscriptionCron.js
src/middleware/auth.js
src/middleware/metrics.js
src/middleware/optionalAuth.js
src/middleware/subscription.middleware.js
src/middleware/upload.js
src/middleware/validate.js
src/models/AdminPaymentDetails.js
src/models/AdminSetting.js
src/models/Announcement.js
src/models/Commission.js
src/models/EconomicEvent.js
src/models/FAQ.js
src/models/Lead.js
src/models/MasterSegment.js
src/models/MasterSymbol.js
src/models/Notification.js
src/models/Page.js
src/models/Plan.js
src/models/Segment.js
src/models/Setting.js
src/models/Signal.js
src/models/Strategy.js
src/models/SubBroker.js
src/models/Subscription.js
src/models/Ticket.js
src/models/Transaction.js
src/models/User.js
src/models/UserSubscription.js
src/models/Watchlist.js
src/monitoring/alertManager.js
src/monitoring/metricsCollector.js
src/routes/admin.route.js
src/routes/analytics.route.js
src/routes/announcement.route.js
src/routes/auth.route.js
src/routes/bot.route.js
src/routes/cms.route.js
src/routes/dashboard.route.js
src/routes/economic.route.js
src/routes/health.route.js
src/routes/index.js
src/routes/lead.route.js
src/routes/market.route.js
src/routes/metrics.route.js
src/routes/notification.route.js
src/routes/payment.route.js
src/routes/plan.route.js
src/routes/search.route.js
src/routes/segment.route.js
src/routes/setting.route.js
src/routes/signal.route.js
src/routes/strategy.route.js
src/routes/subBroker.route.js
src/routes/subscription.route.js
src/routes/ticket.route.js
src/routes/v1/setting.route.js
src/routes/watchlist.routes.js
src/scripts/debug_segments.js
src/scripts/dump_segments.js
src/scripts/seedCMS.js
src/scripts/seedSubBrokers.js
src/services/alltick.service.js
src/services/analytics.service.js
src/services/announcement.service.js
src/services/auth.service.js
src/services/binary.service.js
src/services/cacheManager.js
src/services/channels/push.service.js
src/services/channels/telegram.service.js
src/services/channels/whatsapp.service.js
src/services/cms.service.js
src/services/dashboard.service.js
src/services/economic.service.js
src/services/email.service.js
src/services/fmp.service.js
src/services/hybridStrategy.service.js
src/services/index.js
src/services/kite.service.js
src/services/kiteInstruments.service.js
src/services/marketData.service.js
src/services/msg91.service.js
src/services/notification.fcm.service.js
src/services/notification.service.js
src/services/plan.service.js
src/services/redis.service.js
src/services/scheduler.service.js
src/services/setting.service.js
src/services/signal.monitor.js
src/services/signal.service.js
src/services/startupOptimizer.js
src/services/strategy.service.js
src/services/subBroker.service.js
src/services/subscription.service.js
src/services/technicalAnalysis.service.js
src/services/token.service.js
src/services/transaction.service.js
src/services/user.service.js
src/services/websocket.service.js
src/services/websocketManager.js
src/services/whatsapp.service.js
src/utils/ApiError.js
src/utils/catchAsync.js
src/utils/connection-pool.js
src/utils/encryption.js
src/utils/pick.js
src/utils/pipeline/DataPipeline.js
src/utils/pipeline/filters.cpp
src/utils/pipeline/RingBuffer.js
src/utils/pipeline/WasmLoader.js
src/utils/requestQueue.js
src/utils/technicalIndicators.js
src/validations/admin.validation.js
src/validations/auth.validation.js
src/validations/plan.validation.js
src/validations/signal.validation.js
src/validations/strategy.validation.js
src/validations/subscription.validation.js
src/workers/notification.worker.js
uploads/avatars/avatar-1769341918054-665520637.jpg
uploads/avatars/avatar-1769341930690-842645798.jpg
uploads/avatars/screenshot-1769896574860-970234714.jpeg
uploads/leads/paymentScreenshot-1768940794085-918018985.jpg
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".env.example">
# Server Configuration
PORT=3000
NODE_ENV=production
FRONTEND_URL=https://your-admin-panel.vercel.app

# Database & Cache
MONGO_URI=mongodb+srv://user:pass@cluster.mongodb.net/dbname
REDIS_HOST=localhost
REDIS_PORT=6379

# Security
JWT_SECRET=provide_a_strong_random_secret
JWT_EXPIRES_IN=7d

# Market Data (FMP)
FMP_API_KEY=your_fmp_api_key

# Broker Configuration
USE_MOCK_BROKER=false

# Fyers
FYERS_APP_ID=your_fyers_app_id
FYERS_SECRET_ID=your_fyers_secret_id
FYERS_REDIRECT_URI=https://your-api-domain.com/market/login/fyers

# Kite (Optional)
KITE_API_KEY=your_kite_api_key
KITE_API_SECRET=your_kite_secret

# Upstox (Optional)
UPSTOX_API_KEY=your_upstox_api_key
UPSTOX_API_SECRET=your_upstox_secret
UPSTOX_REDIRECT_URI=https://your-api-domain.com/market/login/upstox

# AllTick (Alternative Feed)
ALLTICK_API_KEY=your_alltick_key

# Notifications
WHATSAPP_ACCESS_TOKEN=your_token
WHATSAPP_PHONE_NUMBER_ID=your_id
MSG91_AUTH_KEY=your_msg91_key
MSG91_OTP_TEMPLATE_ID=your_template_id

# Firebase (Push Notifications)
# Ensure firebase-service-account.json is present in the root directory
</file>

<file path=".gitignore">
node_modules
.env
logs
dist
coverage
.DS_Store
*.zip
temp/
mspktrading
signal_user_app
</file>

<file path="google-services.json">
{
  "project_info": {
    "project_number": "928441080852",
    "project_id": "mspk-trade-solutions",
    "storage_bucket": "mspk-trade-solutions.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:928441080852:android:2fbc708a8feeb28876db01",
        "android_client_info": {
          "package_name": "com.mspktrade.solution"
        }
      },
      "oauth_client": [],
      "api_key": [
        {
          "current_key": "AIzaSyDaX8cE0jU9m1CoQUwEin7D-AAoUuD7ka0"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": []
        }
      }
    }
  ],
  "configuration_version": "1"
}
</file>

<file path="import_crypto_top10.js">
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import MasterSymbol from './src/models/MasterSymbol.js';

dotenv.config();

const cryptoSymbols = [
    { base: 'BTC', name: 'Bitcoin' },
    { base: 'ETH', name: 'Ethereum' },
    { base: 'BNB', name: 'Binance Coin' },
    { base: 'XRP', name: 'Ripple' },
    { base: 'SOL', name: 'Solana' },
    { base: 'TRX', name: 'TRON' },
    { base: 'DOGE', name: 'Dogecoin' },
    { base: 'ADA', name: 'Cardano' },
    { base: 'USDC', name: 'USDC' },
    { base: 'USDT', name: 'Tether' }
];

async function run() {
    try {
        console.log('Connecting to MongoDB...');
        await mongoose.connect(process.env.MONGO_URI);
        console.log('Connected.');

        let addedCount = 0;
        let skippedCount = 0;

        for (const item of cryptoSymbols) {
            // 1. Spot
            const spotSymbol = item.base === 'USDT' ? 'USDTUSD' : `${item.base}USDT`;
            const spotExists = await MasterSymbol.findOne({ symbol: spotSymbol });
            
            if (!spotExists) {
                await MasterSymbol.create({
                    symbol: spotSymbol,
                    name: `${item.name} / Spot`,
                    segment: 'CRYPTO',
                    exchange: 'BINANCE',
                    lotSize: 1,
                    tickSize: 0.00001,
                    isActive: true,
                    isWatchlist: false
                });
                addedCount++;
            } else {
                skippedCount++;
            }

            // 2. Perpetual Future
            const futSymbol = `${item.base}USDT.P`;
            const futExists = await MasterSymbol.findOne({ symbol: futSymbol });
            
            if (!futExists) {
                await MasterSymbol.create({
                    symbol: futSymbol,
                    name: `${item.name} / Perpetual Fut`,
                    segment: 'CRYPTO',
                    exchange: 'BINANCE_FUTURES',
                    lotSize: 1,
                    tickSize: 0.00001,
                    isActive: true,
                    isWatchlist: false
                });
                addedCount++;
            } else {
                skippedCount++;
            }
        }

        console.log(`Crypto Migration complete.`);
        console.log(`Added: ${addedCount}`);
        console.log(`Skipped: ${skippedCount}`);

        process.exit(0);
    } catch (error) {
        console.error('Migration failed:', error);
        process.exit(1);
    }
}

run();
</file>

<file path="kite_raw.txt">
info: [KITE_RAW_DEBUG] Candle 0: {"date":"2026-02-03T03:45:00.000Z","open":1473.9,"high":1489.5,"low":1435,"close":1443.9,"volume":11147506}
</file>

<file path="nodemon.json">
{
    "watch": [
        "src",
        "server.js"
    ],
    "ext": "js,json",
    "ignore": [
        "logs/*",
        "debug_alltick_log.txt",
        "temp/*",
        "*.log"
    ],
    "delay": "1000"
}
</file>

<file path="openapi.yaml">
openapi: 3.0.0
info:
  title: MSPK Trading Backend API
  description: API documentation for the MSPK Trading platform backend.
  version: 1.0.0
servers:
  - url: http://localhost:5000/v1
    description: Local Development Server

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

security:
  - bearerAuth: []

paths:
  # ============================================================
  # AUTHENTICATION
  # ============================================================
  /auth/register:
    post:
      summary: Register a new user
      tags: [Auth]
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [name, email, password, mobile]
              properties:
                name: { type: string }
                email: { type: string, format: email }
                password: { type: string, minLength: 8 }
                mobile: { type: string }
      responses:
        201:
          description: User registered successfully
        400:
          description: Validation error

  /auth/login:
    post:
      summary: Login user
      tags: [Auth]
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [email, password]
              properties:
                email: { type: string, format: email }
                password: { type: string }
      responses:
        200:
          description: Login successful
          content:
            application/json:
              schema:
                type: object
                properties:
                  user: { type: object }
                  tokens: { type: object }

  /auth/send-otp:
    post:
      summary: Send OTP for verification
      tags: [Auth]
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [mobile]
              properties:
                mobile: { type: string }
      responses:
        200:
          description: OTP sent successfully

  /auth/verify-otp:
    post:
      summary: Verify OTP
      tags: [Auth]
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [mobile, otp]
              properties:
                mobile: { type: string }
                otp: { type: string }
      responses:
        200:
          description: OTP verified

  /auth/me:
    get:
      summary: Get current user profile
      tags: [Auth]
      responses:
        200:
          description: User profile data
    patch:
      summary: Update user profile
      tags: [Auth]
      requestBody:
        content:
          multipart/form-data:
            schema:
              type: object
              properties:
                name: { type: string }
                avatar: { type: string, format: binary }
      responses:
        200:
          description: Profile updated

  # ============================================================
  # MARKET DATA
  # ============================================================
  /market/segments:
    get:
      summary: Get available market segments
      tags: [Market]
      security: []
      responses:
        200:
          description: List of segments

  /market/tickers:
    get:
      summary: Get subscription-based tickers (Watchlist)
      tags: [Market]
      responses:
        200:
          description: List of allowed tokens/tickers

  /market/history:
    get:
      summary: Get historical candle data
      tags: [Market]
      parameters:
        - in: query
          name: symbol
          schema: { type: string }
          required: true
        - in: query
          name: resolution
          schema: { type: string, enum: ["1", "5", "15", "30", "60", "D", "W"] }
          required: true
        - in: query
          name: from
          schema: { type: integer } # Unix timestamp
        - in: query
          name: to
          schema: { type: integer } # Unix timestamp
      responses:
        200:
          description: Historical candle data

  /market/search:
    get:
      summary: Search for instruments
      tags: [Market]
      parameters:
        - in: query
          name: q
          schema: { type: string }
          required: true
      responses:
        200:
          description: Search results

  # ============================================================
  # SIGNALS
  # ============================================================
  /signals:
    get:
      summary: Get trading signals
      tags: [Signals]
      parameters:
        - in: query
          name: status
          schema: { type: string, enum: ["Open", "Closed", "Active"] }
      responses:
        200:
          description: List of signals
    post:
      summary: Create a new signal (Admin only)
      tags: [Signals]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [symbol, type, entryPrice, stopLoss, target1]
              properties:
                symbol: { type: string }
                type: { type: string, enum: ["BUY", "SELL"] }
                entryPrice: { type: number }
                stopLoss: { type: number }
                target1: { type: number }
      responses:
        201:
          description: Signal created

  /signals/{signalId}:
    get:
      summary: Get specific signal details
      tags: [Signals]
      parameters:
        - in: path
          name: signalId
          required: true
          schema: { type: string }
      responses:
        200:
          description: Signal details

  # ============================================================
  # SUBSCRIPTIONS & PLANS
  # ============================================================
  /plans:
    get:
      summary: Get available subscription plans
      tags: [Plans]
      security: []
      responses:
        200:
          description: List of plans

  /subscribe/purchase:
    post:
      summary: Purchase a subscription plan
      tags: [Subscription]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [planId]
              properties:
                planId: { type: string }
                paymentMethod: { type: string }
      responses:
        200:
          description: Subscription initiated

  /subscribe/status:
    get:
      summary: Get current user subscription status
      tags: [Subscription]
      responses:
        200:
          description: Subscription status

  /subscriptions/admin/all:
    get:
      summary: Get all user subscriptions (Admin)
      tags: [Subscription]
      responses:
        200:
          description: List of all subscriptions

  # ============================================================
  # DASHBOARD & TICKETS
  # ============================================================
  /dashboard/tickets:
    get:
      summary: Get user support tickets
      tags: [Dashboard]
      responses:
        200:
          description: List of tickets
    post:
      summary: Create a new support ticket
      tags: [Dashboard]
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [subject, message]
              properties:
                subject: { type: string }
                message: { type: string }
                priority: { type: string, enum: ["Low", "Medium", "High"] }
      responses:
        201:
          description: Ticket created

  /dashboard/stats:
    get:
      summary: Get admin dashboard statistics
      tags: [Dashboard]
      responses:
        200:
          description: Admin usage stats

  # ============================================================
  # ADMIN
  # ============================================================
  /admin/users:
    get:
      summary: Get all users
      tags: [Admin]
      responses:
        200:
          description: List of users

  /admin/system/health:
    get:
      summary: Get system health status
      tags: [Admin]
      responses:
        200:
          description: System health metrics
</file>

<file path="package.json">
{
  "name": "mspk_trading_backend",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "module",
  "dependencies": {
    "axios": "^1.13.2",
    "bcryptjs": "^3.0.3",
    "bullmq": "^5.66.4",
    "cheerio": "^1.1.2",
    "cors": "^2.8.5",
    "date-fns": "^4.1.0",
    "dotenv": "^17.2.3",
    "express": "^5.2.1",
    "firebase-admin": "^13.6.0",
    "helmet": "^8.1.0",
    "http-status": "^2.1.0",
    "investing-com-api": "^5.0.3",
    "ioredis": "^5.8.2",
    "joi": "^18.0.2",
    "jsonwebtoken": "^9.0.3",
    "kiteconnect": "^5.1.0",
    "mongoose": "^9.0.2",
    "morgan": "^1.10.1",
    "multer": "^2.0.2",
    "node-cron": "^4.2.1",
    "nodemailer": "^7.0.12",
    "os-utils": "^0.0.14",
    "redis": "^5.10.0",
    "rss-parser": "^3.13.0",
    "technicalindicators": "^3.1.0",
    "validator": "^13.15.26",
    "winston": "^3.19.0",
    "ws": "^8.19.0"
  }
}
</file>

<file path="public/monitor.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSPK System Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #0f1115; color: #e1e1e1; margin: 0; padding: 20px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .card { background: #1a1d23; padding: 20px; border-radius: 8px; border: 1px solid #333; }
        .card h3 { margin-top: 0; color: #888; font-size: 0.9em; text-transform: uppercase; }
        .value { font-size: 2.5em; font-weight: bold; }
        .unit { font-size: 0.4em; color: #666; }
        .status-dot { height: 10px; width: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .status-green { background: #00c853; box-shadow: 0 0 10px #00c853; }
        .status-yellow { background: #ffd600; box-shadow: 0 0 10px #ffd600; }
        .status-red { background: #d50000; box-shadow: 0 0 10px #d50000; }
        .chart-container { height: 200px; margin-top: 20px; }
        #alerts { background: #261a1a; border-left: 4px solid #d50000; padding: 10px; margin-bottom: 20px; display: none; }
    </style>
</head>
<body>
    <h1 style="margin-bottom: 20px;">
        <span id="statusIndicator" class="status-dot status-green"></span>
        System Monitor
        <span style="font-size: 0.4em; color: #555; vertical-align: middle; margin-left: 10px;">v1.0</span>
    </h1>

    <div id="alerts"></div>

    <div class="grid">
        <!-- API -->
        <div class="card">
            <h3>API Load</h3>
            <div class="value" id="apiReq">0 <span class="unit">req/min</span></div>
            <div style="color: #666; margin-top: 5px;">Latency: <span id="apiLat">0</span>ms</div>
            <canvas id="chartApi" class="chart-container"></canvas>
        </div>

        <!-- Cache -->
        <div class="card">
            <h3>Cache Performance</h3>
            <div class="value" id="cacheHit">0% <span class="unit">hit rate</span></div>
            <div style="color: #666; margin-top: 5px;">H: <span id="hits">0</span> / M: <span id="misses">0</span></div>
            <canvas id="chartCache" class="chart-container"></canvas>
        </div>

        <!-- WebSocket -->
        <div class="card">
            <h3>WebSocket</h3>
            <div class="value" id="wsConn">0 <span class="unit">conn</span></div>
            <div style="color: #666; margin-top: 5px;">Queue: <span id="wsQueue">0</span> | Msg/s: <span id="wsMsg">0</span></div>
            <canvas id="chartWs" class="chart-container"></canvas>
        </div>

        <!-- Issues -->
        <div class="card">
            <h3>Critical Events</h3>
            <div class="value" id="err429" style="color: #ff5252">0 <span class="unit">429s</span></div>
            <div style="color: #666; margin-top: 5px;">Memory: <span id="memUsage">0</span> MB</div>
        </div>
    </div>

    <script>
        const ctxApi = document.getElementById('chartApi').getContext('2d');
        const ctxCache = document.getElementById('chartCache').getContext('2d');
        const ctxWs = document.getElementById('chartWs').getContext('2d');

        const chartConfig = (color) => ({
            type: 'line',
            data: { labels: Array(30).fill(''), datasets: [{ data: Array(30).fill(0), borderColor: color, tension: 0.4, borderWidth: 2, pointRadius: 0 }] },
            options: { plugins: { legend: { display: false } }, scales: { x: { display: false }, y: { display: false } }, maintainAspectRatio: false }
        });

        const chart1 = new Chart(ctxApi, chartConfig('#29b6f6'));
        const chart2 = new Chart(ctxCache, chartConfig('#66bb6a'));
        const chart3 = new Chart(ctxWs, chartConfig('#ffa726'));

        function updateChart(chart, val) {
            chart.data.datasets[0].data.push(val);
            chart.data.datasets[0].data.shift();
            chart.update();
        }

        async function fetchMetrics() {
            try {
                const res = await fetch('/v1/metrics');
                const data = await res.json();
                
                // Update DOM
                document.getElementById('apiReq').innerText = data.api.requests_per_minute;
                document.getElementById('apiLat').innerText = data.derived.avg_api_latency;
                document.getElementById('cacheHit').innerText = data.derived.cache_hit_rate + '%';
                document.getElementById('hits').innerText = data.cache.hits;
                document.getElementById('misses').innerText = data.cache.misses;
                document.getElementById('wsConn').innerText = data.websocket.connections;
                document.getElementById('wsQueue').innerText = data.websocket.queue_length;
                document.getElementById('wsMsg').innerText = data.websocket.messages_sent_sec;
                document.getElementById('err429').innerText = data.api.errors_429;
                document.getElementById('memUsage').innerText = data.system.memory_usage_mb;

                // Charts
                updateChart(chart1, data.api.requests_per_minute);
                updateChart(chart2, data.derived.cache_hit_rate);
                updateChart(chart3, data.websocket.messages_sent_sec);

                // Status Logic
                const dot = document.getElementById('statusIndicator');
                if (data.api.errors_429 > 0) dot.className = 'status-dot status-red';
                else if (data.derived.cache_hit_rate < 50 && data.api.requests_per_minute > 5) dot.className = 'status-dot status-yellow';
                else dot.className = 'status-dot status-green';

            } catch (e) {
                console.error(e);
            }
        }

        setInterval(fetchMetrics, 2000);
        fetchMetrics();
    </script>
</body>
</html>
</file>

<file path="server.js">
import app from './src/app.js';
import config from './src/config/config.js';
import logger from './src/config/logger.js';
import connectDB from './src/config/database.js';
import { initWebSocket } from './src/services/websocket.service.js';
import { connectRedis } from './src/services/redis.service.js';
import strategyService from './src/services/strategy.service.js';
import signalMonitor from './src/services/signal.monitor.js';
import schedulerService from './src/services/scheduler.service.js';
import hybridStrategyService from './src/services/hybridStrategy.service.js';
import { initializeFirebase } from './src/config/firebase.js';
import marketDataService from './src/services/marketData.service.js';
import subscriptionCron from './src/jobs/subscriptionCron.js';
import { economicService } from './src/services/economic.service.js';
import './src/workers/notification.worker.js'; // Start Notification Worker

// The 'kiteconnect' library aggressively calls process.exit(1) on connection failures.
// We intercept this to prevent the entire server from crashing due to a localized ticker error.
const originalExit = process.exit;
process.exit = (code) => {
    const stack = new Error().stack;
    if (stack && (stack.includes('kiteconnect') || stack.includes('ticker.js'))) {
        console.error(`[CRITICAL_GUARD] blocked process.exit(${code}) call from KiteTicker. Keeping server alive.`);
        return;
    }
    
    // Allow legitimate exits
    console.log(`[PROCESS_EXIT] Exiting with code: ${code}`);
    originalExit(code);
};

const startServer = async () => {
  try {
    // 1. Connect to Database
    await connectDB();
    
    // 2. Connect to Redis
    await connectRedis();

    // 2.5 Initialize Firebase
    initializeFirebase();

    // 3. Start Express Server
    const server = app.listen(config.port, '0.0.0.0', () => {
      logger.info(`Server running in ${config.env} mode on port ${config.port}`);
    });

    // 4. Initialize Background Services
    marketDataService.init(); 
    initWebSocket(server);
    await strategyService.seedStrategies(); 
    strategyService.startEngine();
    hybridStrategyService.start();
    signalMonitor.start(); 
    
    // Initialize Economic Service with API key
    economicService.initialize(config.fmpApiKey);
    logger.info('Economic Service initialized with FMP API key');
    
    schedulerService.initScheduler();
    schedulerService.initScheduler();
    subscriptionCron.start(); // Start subscription expiry checker

    
    // Handle signals for graceful shutdown
    const exitHandler = () => {
      if (server) {
        server.close(() => {
          logger.info('Server closed');
          process.exit(1);
        });
      } else {
        process.exit(1);
      }
    };

    const unexpectedErrorHandler = (error) => {
      logger.error('Unexpected Global Error:', error);
      if (error && error.stack) {
        logger.error(error.stack);
      }
      // Do not exit the process for these errors, just log them
      // exitHandler(); 
    };

    process.on('uncaughtException', unexpectedErrorHandler);
    process.on('unhandledRejection', unexpectedErrorHandler);

    

    process.on('SIGTERM', () => {
      logger.info('SIGTERM received');
      if (server) {
        server.close();
      }
    });

  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer()
</file>

<file path="src/app.js">
import express from 'express';
import helmet from 'helmet';
import cors from 'cors';
import morgan from 'morgan';
import { metricsMiddleware } from './middleware/metrics.js';
import config from './config/config.js';
import routes from './routes/index.js';

const app = express();

// Middleware
app.use(cors({
  origin: true, // Reflects the request origin
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use('/uploads', express.static('uploads')); // Serve uploaded files
app.use(express.static('public')); // Serve Monitoring Dashboard
// app.use(helmet()); // Temporarily disabled to debug 308 Redirects
// app.use(cors()); // Moved to top

// Logger
if (config.env === 'development') {
  app.use(morgan('dev'));
}

// Direct Route for Fyers Login Callback to match User's App Config (No /v1)
import marketController from './controllers/market.controller.js';
app.get('/market/login/fyers', marketController.handleLoginCallback);

app.use(metricsMiddleware);

// Routes
app.use('/v1', routes);

// Error handling
app.use((err, req, res, next) => {
  const { statusCode, message } = err;
  res.status(statusCode || 500).json({
    status: 'error',
    statusCode: statusCode || 500,
    message: message || 'Internal Server Error',
  });
});

export default app;
</file>

<file path="src/config/config.js">
import dotenv from 'dotenv';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, '../../.env') });

export default {
  env: process.env.NODE_ENV || 'development',
  port: process.env.PORT || 5000,
  frontendUrl: process.env.FRONTEND_URL || 'http://localhost:5173',
  mongoose: {
    url: process.env.MONGO_URI ,
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    },
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: process.env.REDIS_PORT || 6379,
  },
  jwt: {
    secret: process.env.JWT_SECRET,
    expiresIn: process.env.JWT_EXPIRES_IN || '1d',
  },
  fmpApiKey: process.env.FMP_API_KEY,
  useMockBroker: process.env.USE_MOCK_BROKER === 'true', 
  fyers: {
    appId: process.env.FYERS_APP_ID,
    secretId: process.env.FYERS_SECRET_ID,
    redirectUri: process.env.FYERS_REDIRECT_URI || 'http://localhost:3000/market/login/fyers',
  },
  kite: {
    apiKey: process.env.KITE_API_KEY,
    apiSecret: process.env.KITE_API_SECRET,
  },
  upstox: {
    apiKey: process.env.UPSTOX_API_KEY,
    apiSecret: process.env.UPSTOX_API_SECRET,
    redirectUri: process.env.UPSTOX_REDIRECT_URI || 'http://localhost:3000/market/login/upstox',
  },
};
</file>

<file path="src/config/database.js">
import mongoose from 'mongoose';
import config from './config.js';
import logger from './logger.js';

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(config.mongoose.url);
    logger.info(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    logger.error(`Error: ${error.message}`);
    process.exit(1);
  }
};

export default connectDB;
</file>

<file path="src/config/firebase.js">
import admin from 'firebase-admin';
import logger from './logger.js';
import fs from 'fs';
import path from 'path';

const initializeFirebase = () => {
  try {
    const serviceAccountPath = path.resolve(process.cwd(), 'firebase-service-account.json');
    
    if (fs.existsSync(serviceAccountPath)) {
      const serviceAccount = JSON.parse(fs.readFileSync(serviceAccountPath, 'utf8'));
      admin.initializeApp({
        credential: admin.credential.cert(serviceAccount)
      });
      logger.info('Firebase Admin initialized via service account file');
    } else {
      logger.warn('Firebase service account file not found. Push notifications will be disabled or limited.');
      // You can also initialize with env variables if preferred:
      /*
      admin.initializeApp({
        credential: admin.credential.cert({
          projectId: process.env.FIREBASE_PROJECT_ID,
          clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
          privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
        })
      });
      */
    }
  } catch (error) {
    logger.error('Firebase initialization error:', error);
  }
};

export { admin, initializeFirebase };
</file>

<file path="src/config/logger.js">
import winston from 'winston';
import config from './config.js';
import { EventEmitter } from 'events';

export const logEmitter = new EventEmitter();

const enumerateErrorFormat = winston.format((info) => {
  if (info instanceof Error) {
    Object.assign(info, { message: info.stack });
  }
  return info;
});

class EmitterTransport extends winston.Transport {
  log(info, callback) {
    setImmediate(() => {
      this.emit('logged', info);
    });

    const cleanLevel = info.level.replace(/\x1B\[\d+m/g, '');
    if (['info', 'warn', 'error'].includes(cleanLevel)) {
        logEmitter.emit('log', {
          level: cleanLevel,
          message: info.message,
          timestamp: new Date().toISOString()
        });
    }
    callback();
  }
}

const logger = winston.createLogger({
  level: config.env === 'development' ? 'debug' : 'info',
  format: winston.format.combine(
    enumerateErrorFormat(),
    config.env === 'development' ? winston.format.colorize() : winston.format.uncolorize(),
    winston.format.splat(),
    winston.format.printf(({ level, message }) => `${level}: ${message}`)
  ),
  transports: [
    new winston.transports.Console({
      stderrLevels: ['error'],
    }),
    new winston.transports.File({ filename: 'logs/debug.log' }),
    new EmitterTransport()
  ],
});

export default logger;
</file>

<file path="src/config/notificationTemplates.js">
/**
 * Master Notification Templates
 * Use {{variable}} syntax for dynamic data.
 */
export default {
    // Signal Alerts
    SIGNAL_NEW: {
        title: "üöÄ New Signal: {{symbol}}",
        body: "Action: {{type}}\nEntry: {{entryPrice}}\nSL: {{stopLoss}}\nTP1: {{target1}}\nTP2: {{target2}}\nTP3: {{target3}}"
    },
    SIGNAL_UPDATE: {
        title: "‚ö†Ô∏è Signal Update: {{symbol}}",
        body: "Update for {{symbol}}: {{updateMessage}}\nCurrent Price: {{currentPrice}}"
    },
    SIGNAL_TARGET: {
        title: "üéØ Target Hit: {{symbol}}",
        body: "Target {{targetLevel}} Hit for {{symbol}}!\nProfit Booked. üí∞"
    },
    SIGNAL_STOPLOSS: {
        title: "üõë Stop Loss Hit: {{symbol}}",
        body: "SL Hit for {{symbol}}. Exit Position."
    },

    // Announcements
    ANNOUNCEMENT: {
        // Default simply maps title/message as is
        title: "{{title}}",
        body: "{{message}}"
    },

    // Economic Events
    ECONOMIC_ALERT: {
        title: "üåç High Impact: {{event}}",
        body: "Event: {{event}} ({{country}})\nForecast: {{forecast}}\nPrevious: {{previous}}"
    },

    // System / Reminders
    PLAN_EXPIRY_REMINDER: {
        title: "‚è≥ Plan Expiry Reminder",
        body: "Your subscription for {{planName}} is expiring in {{daysLeft}} days. Renew now to continue services."
    },

    // Support
    TICKET_REPLY: {
        title: "üí¨ New Reply: Ticket #{{ticketId}}",
        body: "Admin: {{message}}"
    }
};
</file>

<file path="src/controllers/admin.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import User from '../models/User.js';
import Subscription from '../models/Subscription.js';
import Plan from '../models/Plan.js';
import ApiError from '../utils/ApiError.js';
import { redisClient } from '../services/redis.service.js';
import transactionService from '../services/transaction.service.js';
import { subBrokerService, announcementService } from '../services/index.js';
import hybridStrategyService from '../services/hybridStrategy.service.js';

const createUser = catchAsync(async (req, res) => {
    console.log("Create User Payload:", JSON.stringify(req.body, null, 2)); // DEBUG LOG
    const { email, password, name, phone, role, clientId, equity, walletBalance, subBrokerId, planId, status } = req.body;

    if (await User.findOne({ email })) {
        throw new ApiError(httpStatus.BAD_REQUEST, 'Email already taken');
    }

    const user = await User.create({
        name,
        email,
        password,
        phone,
        role,
        clientId,
        equity,
        walletBalance,
        subBrokerId,
        status,
        isEmailVerified: true // Admin created, so verify
    });

    // Handle Plan Subscription
    if (planId) {
        const plan = await Plan.findById(planId);
        if (plan) {
            const startDate = new Date();
            const endDate = new Date();
            endDate.setDate(endDate.getDate() + (plan.durationDays || 30));

            // Create Manual Transaction
            const transaction = await transactionService.createTransaction({
                user: user.id,
                amount: plan.price,
                currency: 'INR',
                type: 'DEBIT',
                purpose: 'SUBSCRIPTION',
                status: 'success',
                paymentGateway: 'MANUAL_ADMIN',
                metadata: { planId: plan.id, planName: plan.name, adminCreated: true }
            });

            await Subscription.create({
                user: user.id,
                plan: plan.id,
                status: 'active',
                startDate,
                endDate,
                transaction: transaction.id
            });

            // Trigger Commission Record
            try {
                await subBrokerService.recordCommission(transaction, user, plan);
            } catch (err) {
                console.error("Commission Recording Failed:", err);
            }

            // Update legacy user subscription field for consistency
            user.subscription = {
                plan: plan.name,
                expiresAt: endDate
            };
            await user.save();
        }
    }

    res.status(httpStatus.CREATED).send(user);
});

const getUsers = catchAsync(async (req, res) => {
  const users = await User.find({}, '-password').sort({ createdAt: -1 }).populate('subBrokerId', 'name');

  const enrichedUsers = await Promise.all(users.map(async (u) => {
      // Find active subscriptions (Fetch ALL)
      const subs = await Subscription.find({ user: u.id, status: 'active' }).populate('plan');
      
      // Aggregate Plan Data
      let planNames = [];
      let minStart = null;
      let maxEnd = null;

      if (subs.length > 0) {
          planNames = subs.map(s => s.plan ? s.plan.name : 'Unknown').filter(n => n !== 'Unknown');
          
          // Calculate Dates
          const starts = subs.map(s => new Date(s.startDate).getTime());
          const ends = subs.map(s => new Date(s.endDate).getTime());
          
          if (starts.length > 0) minStart = new Date(Math.min(...starts));
          if (ends.length > 0) maxEnd = new Date(Math.max(...ends));
      }

      const hasActivePlan = subs.length > 0;

      return {
          id: u.id,
          name: u.name,
          email: u.email,
          phone: u.phone || '',
          role: u.role,
          ip: u.lastLoginIp,
          
          // Subscription / Plan Data
          plan: hasActivePlan ? planNames.join(', ') : 'Free', 
          planStatus: hasActivePlan ? 'Active' : 'Inactive',
          subscriptionStart: minStart,
          subscriptionExpiry: maxEnd,

          // Broker Data
          subBrokerId: u.subBrokerId ? u.subBrokerId._id : 'DIRECT',
          subBrokerName: u.subBrokerId ? u.subBrokerId.name : 'Direct Client',

          // Trading Stats
          status: u.status || 'Active', 
          walletBalance: u.walletBalance || 0,
          clientId: u.clientId || `MS-${u.id.toString().slice(-4)}`,
          equity: u.equity || 0,
          marginUsed: u.marginUsed || 0,
          pnl: u.pnl || 0,
          
          joinDate: u.createdAt,
          kycStatus: u.kyc?.status || 'Pending',
      };
  }));
  res.send(enrichedUsers);
});

const getUser = catchAsync(async (req, res) => {
  const user = await User.findById(req.params.userId).populate('subBrokerId', 'name clientId');
  if (!user) {
    throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
  }

  // Fetch active subscriptions (ALL)
  const activeSubs = await Subscription.find({ user: user.id, status: 'active' }).populate('plan');

  // Aggregate Data
  let planNames = [];
  let minStart = null;
  let maxEnd = null;
  let totalPrice = 0;

  if (activeSubs.length > 0) {
      planNames = activeSubs.map(s => s.plan ? s.plan.name : 'Unknown');
      totalPrice = activeSubs.reduce((sum, s) => sum + (s.plan ? s.plan.price : 0), 0);
      
      const starts = activeSubs.map(s => new Date(s.startDate).getTime());
      const ends = activeSubs.map(s => new Date(s.endDate).getTime());
      
      if (starts.length > 0) minStart = new Date(Math.min(...starts));
      if (ends.length > 0) maxEnd = new Date(Math.max(...ends));
  }

  // Fetch all subscriptions for history
  const history = await Subscription.find({ user: user.id }).sort({ createdAt: -1 }).populate('plan');

  const enrichedUser = {
      id: user.id,
      name: user.name,
      email: user.email,
      phone: user.phone || '',
      role: user.role,
      
      // Subscription / Plan Data
      plan: planNames.length > 0 ? planNames.join(', ') : 'Free', 
      planStatus: planNames.length > 0 ? 'Active' : 'Inactive',
      subscriptionStart: minStart,
      subscriptionExpiry: maxEnd,
      planPrice: totalPrice,

      // Broker Data
      subBrokerId: user.subBrokerId ? user.subBrokerId._id : null,
      subBrokerName: user.subBrokerId ? user.subBrokerId.name : 'Direct Client',
      subBrokerClientId: user.subBrokerId ? user.subBrokerId.clientId : null,

      // Trading Stats
      status: user.status || 'Active', 
      walletBalance: user.walletBalance || 0,
      clientId: user.clientId || `MS-${user.id.toString().slice(-4)}`,
      equity: user.equity || 0,
      marginUsed: user.marginUsed || 0,
      pnl: user.pnl || 0,
      
      joinDate: user.createdAt,
      kycStatus: user.kyc?.status || 'Pending',
      
      // History
      subscriptionHistory: history.map(h => ({
          id: h.id,
          plan: h.plan ? h.plan.name : 'Unknown Plan',
          amount: h.plan ? `‚Çπ${h.plan.price}` : '-',
          date: h.createdAt,
          status: h.status,
          expiry: h.endDate
      })),

      // Computed Signals (Default List + Overrides)
      // Pass the *latest* expiring sub for signal calculation base, or modify getComputedSignals to handle array.
      // For now, let's pass the one with max expiry as reference 'activeSub'
      signals: getComputedSignals(user, activeSubs.length > 0 ? activeSubs.sort((a,b) => new Date(b.endDate) - new Date(a.endDate))[0] : null)
  };

  res.send(enrichedUser);
});

// Helper to compute signals based on Plan and User Overrides
const getComputedSignals = (user, activeSub) => {
    // Defines all available signal categories in the system
    const systemSignals = [
        { key: 'NIFTY_OPT', label: 'Nifty 50 Options', keywords: ['Nifty', 'Options', 'FNO'] },
        { key: 'BANKNIFTY_OPT', label: 'BankNifty Options', keywords: ['BankNifty', 'Options', 'FNO'] },
        { key: 'STOCKS_INTRA', label: 'Stocks Intraday', keywords: ['Equity', 'Stocks', 'Intraday', 'Cash'] },
        { key: 'COMMODITY', label: 'Commodity (MCX)', keywords: ['Commodity', 'Gold', 'Silver', 'Crude', 'MCX'] },
        { key: 'FOREX', label: 'Forex Signals', keywords: ['Forex', 'Currency', 'Pairs'] }
    ];

    return systemSignals.map(sig => {
        // 1. Check for specific user override first
        const override = user.signalAccess?.find(s => s.category === sig.key);
        if (override) {
            return {
                category: sig.label,
                key: sig.key,
                access: override.access,
                expiry: override.expiry ? override.expiry : (activeSub ? activeSub.endDate : null),
                source: 'override'
            };
        }

        // 2. Smart Plan Mapping
        let planHasAccess = false;
        
        if (activeSub && activeSub.status === 'active' && activeSub.plan && activeSub.plan.features) {
            // Check if any plan feature contains any of the signal keywords
            // logic: Does plan.features (array of strings) have any string that includes a keyword?
            const planFeatures = activeSub.plan.features.map(f => f.toLowerCase());
            
            // Check segment match (stronger check)
            if (activeSub.plan.segment) {
                const seg = activeSub.plan.segment; // NEVER check toLowerCase here if enum is CONSTANT, but safe to do so
                if (seg === 'FNO' && (sig.key === 'NIFTY_OPT' || sig.key === 'BANKNIFTY_OPT')) planHasAccess = true;
                if (seg === 'EQUITY' && sig.key === 'STOCKS_INTRA') planHasAccess = true;
                if (seg === 'COMMODITY' && sig.key === 'COMMODITY') planHasAccess = true;
                if (seg === 'CURRENCY' && sig.key === 'FOREX') planHasAccess = true;
            }

            // Keyword fallback check
            if (!planHasAccess) {
                const keywords = sig.keywords.map(k => k.toLowerCase());
                const matchesKeyword = planFeatures.some(feature => 
                    keywords.some(keyword => feature.includes(keyword))
                );
                if (matchesKeyword) planHasAccess = true;
            }
        }

        return {
            category: sig.label,
            key: sig.key,
            access: planHasAccess,
            expiry: activeSub ? activeSub.endDate : null,
            source: 'plan'
        };
    });
};

const updateSignalAccess = catchAsync(async (req, res) => {
    const user = await User.findById(req.params.userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }

    const { category, access, expiry } = req.body;

    // Check if override exists
    const existingIndex = user.signalAccess.findIndex(s => s.category === category);

    if (existingIndex > -1) {
        // Update existing
        user.signalAccess[existingIndex].access = access;
        if (expiry) user.signalAccess[existingIndex].expiry = expiry;
    } else {
        // Add new override
        user.signalAccess.push({ category, access, expiry });
    }

    await user.save();
    res.send({ message: 'Signal access updated', signals: getComputedSignals(user, null) }); // Return updated list (approximation)
});

const updateUserRole = catchAsync(async (req, res) => {
    const user = await User.findByIdAndUpdate(req.params.userId, { role: req.body.role }, { new: true });
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    res.send(user);
});

const getSystemHealth = catchAsync(async (req, res) => {
    // Check Redis
    let redisStatus = 'DOWN';
    try {
        await redisClient.ping();
        redisStatus = 'UP';
    } catch(e) {
        redisStatus = 'DOWN';
    }

    // Check DB
    const dbStatus = 'UP'; // If we are here, express is connected (usually)
    
    // Memory Usage
    const memory = process.memoryUsage();

    res.send({
        status: 'OK',
        timestamp: new Date(),
        components: {
            redis: redisStatus,
            database: dbStatus
        },
        memory: {
            rss: `${Math.round(memory.rss / 1024 / 1024)} MB`,
            heapTotal: `${Math.round(memory.heapTotal / 1024 / 1024)} MB`
        }
    });
});

const deleteUser = catchAsync(async (req, res) => {
    const user = await User.findById(req.params.userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    await Subscription.deleteMany({ user: user.id });
    await User.deleteOne({ _id: user._id });
    res.status(httpStatus.NO_CONTENT).send();
});

const blockUser = catchAsync(async (req, res) => {
    const user = await User.findById(req.params.userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    user.status = user.status === 'Blocked' ? 'Active' : 'Blocked';
    await user.save();
    res.send(user);
});

const liquidateUser = catchAsync(async (req, res) => {
    const user = await User.findById(req.params.userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    // Logic: Reset trading stats and mark liquidated
    user.status = 'Liquidated';
    user.equity = 0;
    user.marginUsed = 0;
    user.pnl = 0;
    await user.save();
    
    res.send(user);
});

const getStrategyStatus = catchAsync(async (req, res) => {
    const { symbol } = req.query;
    if (!symbol) {
        // Return all
        const allStatus = hybridStrategyService.status;
        res.send(allStatus);
    } else {
        const status = hybridStrategyService.getLiveStatus(symbol);
        res.send(status || {});
    }
});

const updateUser = catchAsync(async (req, res) => {
    const { userId } = req.params;
    const { planId, ...body } = req.body; // Extract planId separately

    const user = await User.findById(userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }

    // Check if email is taken (if email is being updated)
    if (body.email && body.email !== user.email) {
        if (await User.findOne({ email: body.email })) {
            throw new ApiError(httpStatus.BAD_REQUEST, 'Email already taken');
        }
    }

    // Update basic fields
    Object.assign(user, body);
    await user.save(); // Password hashing happens in pre-save if 'password' was in body

    // Handle Plan Update (if planId provided and changed)
    if (planId) {
        const currentSub = await Subscription.findOne({ user: user.id, status: 'active' });
        
        // If no active plan OR different plan
        if (!currentSub || currentSub.plan.toString() !== planId) {
             const plan = await Plan.findById(planId);
             if (plan) {
                 // Expire old subscription
                 if (currentSub) {
                     currentSub.status = 'expired';
                     currentSub.endDate = new Date();
                     await currentSub.save();
                 }

                 // Create new subscription
                 const startDate = new Date();
                 const endDate = new Date();
                 endDate.setDate(endDate.getDate() + (plan.durationDays || 30));

                 await Subscription.create({
                     user: user.id,
                     plan: plan.id,
                     status: 'active',
                     startDate,
                     endDate,
                     transaction: null
                 });
             }
        }
    }

    res.send(user);
    res.send(user);
});

const broadcastMessage = catchAsync(async (req, res) => {
    const { title, message, targetAudience } = req.body;
    
    // Validate inputs
    if (!title || !message) {
        throw new ApiError(httpStatus.BAD_REQUEST, 'Title and Message are required');
    }

    // Use Announcement Service to Create + Schedule
    // This handles DB Log + Broadcast triggers
    const announcement = await announcementService.createAnnouncement({
        title,
        message,
        targetAudience: targetAudience || { role: 'all' },
        type: 'GENERAL',
        isActive: true, // Immediate
        startDate: new Date()
    });

    res.status(httpStatus.CREATED).send({ 
        message: 'Broadcast scheduled successfully', 
        announcementId: announcement.id
    });
});

export default {
  getUsers,
  createUser,
  getUser,
  updateUser,
  updateUserRole,
  deleteUser,
  blockUser, 
  liquidateUser,
  updateSignalAccess,
  getSystemHealth,
  getStrategyStatus,
  broadcastMessage
};
</file>

<file path="src/controllers/analytics.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import analyticsService from '../services/analytics.service.js';

const getAnalytics = catchAsync(async (req, res) => {
    const { type, range } = req.query; // type: 'revenue' | 'subscription' | 'signals'
    
    let data;
    if (type === 'revenue') {
        data = await analyticsService.getRevenueAnalytics(range);
    } else if (type === 'subscription') {
        data = await analyticsService.getSubscriptionAnalytics(range);
    } else if (type === 'signals') {
        data = await analyticsService.getSignalPerformance(range);
    } else {
        // Default to revenue if unspecified
        data = await analyticsService.getRevenueAnalytics('month');
    }
    
    res.send(data);
});

const exportAnalytics = catchAsync(async (req, res) => {
    const { type, range } = req.query;
    const csvData = await analyticsService.getAnalyticsCSV(type || 'revenue', range || 'month');
    
    res.header('Content-Type', 'text/csv');
    res.attachment(`report-${type}-${range}-${new Date().toISOString().split('T')[0]}.csv`);
    res.send(csvData);
});

export default {
    getAnalytics,
    exportAnalytics
};
</file>

<file path="src/controllers/announcement.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { announcementService } from '../services/index.js';
import pick from '../utils/pick.js';
import ApiError from '../utils/ApiError.js';
import Announcement from '../models/Announcement.js';

const createAnnouncement = catchAsync(async (req, res) => {
  const announcement = await announcementService.createAnnouncement(req.body);
  res.status(httpStatus.CREATED).send(announcement);
});

const getAnnouncements = catchAsync(async (req, res) => {
  const { status, type, priority } = req.query;
  const now = new Date();

  const filter = {};
  if (type) filter.type = type;
  if (priority) filter.priority = priority;

  // Status filtering logic
  if (status === 'active') {
    filter.isActive = true;
    filter.startDate = { $lte: now };
    filter.$or = [{ endDate: { $exists: false } }, { endDate: { $gt: now } }];
  } else if (status === 'scheduled') {
    filter.isActive = true;
    filter.startDate = { $gt: now };
  } else if (status === 'history') {
    // History includes expired OR disabled
    filter.$or = [
      { endDate: { $lte: now } },
      { isActive: false }
    ];
    // Note: if user wants ONLY expired but active, logic varies. 
    // Usually history implies "not currently active".
  } else {
    // Default or 'all' - maybe hide deleted?
    // for now keep it open
  }

  const options = pick(req.query, ['page', 'limit']);
  const result = await announcementService.queryAnnouncements(filter, options);
  res.send(result);
});

const getAnnouncement = catchAsync(async (req, res) => {
  const announcement = await announcementService.getAnnouncementById(req.params.announcementId);
  if (!announcement) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Announcement not found');
  }
  res.send(announcement);
});

const updateAnnouncement = catchAsync(async (req, res) => {
  const announcement = await announcementService.updateAnnouncementById(req.params.announcementId, req.body);
  res.send(announcement);
});

const deleteAnnouncement = catchAsync(async (req, res) => {
  await announcementService.deleteAnnouncementById(req.params.announcementId);
  res.status(httpStatus.NO_CONTENT).send();
});

const exportAnnouncements = catchAsync(async (req, res) => {
    const { status, type, priority } = req.query;
    const now = new Date();
  
    const filter = {};
    if (type && type !== 'All') filter.type = type;
    if (priority) filter.priority = priority;
  
    // Status logic (Duplicated for availability - ideally refactor to service)
    if (status === 'active') {
      filter.isActive = true;
      filter.startDate = { $lte: now };
      filter.$or = [{ endDate: { $exists: false } }, { endDate: { $gt: now } }];
    } else if (status === 'scheduled') {
      filter.isActive = true;
      filter.startDate = { $gt: now };
    } else if (status === 'history') {
      filter.$or = [ { endDate: { $lte: now } }, { isActive: false } ];
    }
    
    // Fetch all matching records (limit 1000)
    const announcements = await announcementService.queryAnnouncements(filter, { limit: 1000 });
    const data = announcements.results || announcements;

    // Helper to format date
    const formatDate = (d) => {
        if (!d) return '-';
        return new Date(d).toLocaleString('en-GB', { 
            day: '2-digit', month: '2-digit', year: 'numeric', 
            hour: '2-digit', minute: '2-digit', hour12: true 
        }).replace(',', '');
    };

    // Convert to CSV
    // Fields: Title, Type, Message, Audience, Status, Start Date, End Date, Created At
    const header = ['Title', 'Type', 'Message Body', 'Audience', 'Status', 'Start Date', 'End Date', 'Created At'];
    const csvRows = [];
    
    // Header
    csvRows.push(header.join(','));

    // Rows
    data.forEach(item => {
        const row = [
            `"${(item.title || '').replace(/"/g, '""')}"`, // Title
            item.type || '',
            `"${(item.message || '').replace(/"/g, '""').replace(/\n/g, ' ')}"`, // Message (remove newlines for CSV safety)
            (item.targetAudience?.role === 'all' ? 'All Users' : 
             item.targetAudience?.role === 'sub-broker' ? 'Sub Brokers' : 
             (() => {
                let parts = [item.targetAudience?.role || 'User'];
                if (item.targetAudience?.planValues?.length > 0) parts.push(`Plans: ${item.targetAudience.planValues.join('|')}`);
                if (item.targetAudience?.segments?.length > 0) parts.push(`Segments: ${item.targetAudience.segments.join('|')}`);
                return parts.join(' - ');
             })()),
            item.status || (item.isActive ? 'Active' : 'Inactive'), 
            formatDate(item.startDate),
            formatDate(item.endDate),
            formatDate(item.createdAt)
        ];
        csvRows.push(row.join(','));
    });

    const csvString = csvRows.join('\n');

    res.header('Content-Type', 'text/csv');
    res.header('Content-Disposition', `attachment; filename="announcements_export_${Date.now()}.csv"`);
    res.send(csvString);
});

export default {
  createAnnouncement,
  getAnnouncements,
  getAnnouncement,
  updateAnnouncement,
  deleteAnnouncement,
  exportAnnouncements
};
</file>

<file path="src/controllers/auth.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { authService, tokenService, userService, msg91Service, emailService } from '../services/index.js';
import { redisClient } from '../services/redis.service.js'; // Direct client access for Email OTP

const register = catchAsync(async (req, res) => {
  // Check if phone/email is verified before creating account
  // Note: App should verify FIRST, then call register.
  // We can strictly enforce it here if we assume OTP flow is mandatory.
  if (req.body.phone && req.body.isPhoneVerified !== true) {
     // In a loose flow, we might trust the client or re-verify. 
     // For production strictness, we should check if the phone is marked verified in a temporary store or just trust the 'join' flow 
     // where the client claims it's verified. 
     // Better: The 'verifyOtp' endpoint should issue a temporary 'signup-token' or we trust the immediate register call.
     // For now, we'll assume the client sends the data and we rely on the OTP endpoints having been called.
     // A more robust way is to require a 'verificationId' from the verify step.
  }
  
  const user = await authService.createUser(req.body);
  const tokens = await tokenService.generateAuthTokens(user);
  res.status(201).send({ user, token: tokens.access.token });
});

const sendOtp = catchAsync(async (req, res) => {
    const { type, identifier } = req.body; // type: 'phone' | 'email', identifier: '9198...' | 'abc@example.com'

    if (!identifier) {
        return res.status(httpStatus.BAD_REQUEST).send({ message: 'Identifier is required' });
    }

    if (type === 'phone') {
        // Use MSG91
        // Template ID should be in env or passed. Assuming a default OTP template.
        const templateId = process.env.MSG91_OTP_TEMPLATE_ID; 
        if (!templateId) return res.status(httpStatus.INTERNAL_SERVER_ERROR).send({ message: 'Server config missing OTP Template' });
        
        const success = await msg91Service.sendOtp(identifier, templateId);
        if (success) {
            res.send({ message: 'OTP sent successfully to phone' });
        } else {
            res.status(httpStatus.INTERNAL_SERVER_ERROR).send({ message: 'Failed to send OTP' });
        }
    } else if (type === 'email') {
        const key = `email_otp:${identifier}`;
        const dailyKey = `email_daily_count:${identifier}`;

        // 1. Check Daily Limit (Max 5)
        let dailyCount = await redisClient.get(dailyKey);
        dailyCount = dailyCount ? parseInt(dailyCount) : 0;

        if (dailyCount >= 5) {
             return res.status(httpStatus.TOO_MANY_REQUESTS).send({ 
                 message: 'Daily OTP limit exceeded (5/day). Please try again tomorrow.',
                 dailyLimit: true
             });
        }

        // 2. Check if OTP is already active
        const ttl = await redisClient.ttl(key);
        if (ttl > 0) {
            return res.status(httpStatus.BAD_REQUEST).send({ 
                message: `OTP already sent. Please wait ${Math.ceil(ttl / 60)} minutes before resending.`,
                ttl: ttl 
            });
        }

        // Generate OTP
        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        
        // Store in Redis (10 mins expiry)
        await redisClient.set(key, otp, 'EX', 600);
        
        // Send Email
        const sent = await emailService.sendEmailOtp(identifier, otp);
        
        if (sent) {
            // Increment Daily Count
            const newCount = await redisClient.incr(dailyKey);
            if (newCount === 1) await redisClient.expire(dailyKey, 86400); // 24 Hours

            res.send({ 
                message: 'OTP sent successfully to email', 
                dailyRemaining: 5 - newCount 
            });
        } else {
            res.status(httpStatus.INTERNAL_SERVER_ERROR).send({ message: 'Failed to send OTP email' });
        }
    } else {
        res.status(httpStatus.BAD_REQUEST).send({ message: 'Invalid type. Use "phone" or "email"' });
    }
});

const verifyOtp = catchAsync(async (req, res) => {
    const { type, identifier, otp } = req.body;

    if (!identifier || !otp) {
        return res.status(httpStatus.BAD_REQUEST).send({ message: 'Identifier and OTP are required' });
    }

    if (type === 'phone') {
        const isValid = await msg91Service.verifyOtp(identifier, otp);
        if (isValid) {
            res.send({ message: 'Phone verified successfully', verified: true });
        } else {
            res.status(httpStatus.BAD_REQUEST).send({ message: 'Invalid OTP', verified: false });
        }
    } else if (type === 'email') {
        const storedOtp = await redisClient.get(`email_otp:${identifier}`);
        if (storedOtp === otp) {
            await redisClient.del(`email_otp:${identifier}`); // Clear OTP
            
            // Generate Verification Token for Lead Creation
            // Uses identifier (email) as subject
            const verificationToken = tokenService.generateToken(identifier, Math.floor(Date.now() / 1000) + 900, 'EMAIL_VERIFICATION');
            
            res.send({ 
                message: 'Email verified successfully', 
                verified: true,
                verificationToken: verificationToken 
            });
        } else {
            res.status(httpStatus.BAD_REQUEST).send({ message: 'Invalid or expired OTP', verified: false });
        }
    } else {
        res.status(httpStatus.BAD_REQUEST).send({ message: 'Invalid type' });
    }
});

const login = catchAsync(async (req, res) => {
  const { email, password, deviceId } = req.body;
  // Destructure service response
  const { user, planDetails } = await authService.loginUserWithEmailAndPassword(email, password);
  
  // Single Session & IP Tracking Logic
  user.currentDeviceId = deviceId || 'unknown';
  user.tokenVersion = (user.tokenVersion || 0) + 1;
  user.lastLoginIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress || req.ip;
  await user.save(); // Now works because 'user' is a Mongoose doc

  const tokens = await tokenService.generateAuthTokens(user);
  
  // Merge User + Plan Details for Frontend
  const responseUser = {
      ...user.toObject(),
      ...planDetails
  };

  res.send({ user: responseUser, token: tokens.access.token });
});

const getMe = catchAsync(async (req, res) => {
    const planDetails = await authService.getUserActivePlan(req.user);
    const responseUser = {
        ...req.user.toObject(),
        ...planDetails
    };
    res.send(responseUser);
});

const updateMe = catchAsync(async (req, res) => {
    console.log('UpdateMe Hit. Body:', req.body);
    console.log('UpdateMe File:', req.file);
    const updateBody = req.body;
    if (req.file) {
        updateBody.profile = updateBody.profile || {};
        updateBody.profile.avatar = req.file.path.replace(/\\/g, "/"); // Normalize path
    }
    const user = await userService.updateUserById(req.user.id, updateBody);
    res.send(user);
});

const updateKyc = catchAsync(async (req, res) => {
    const user = await userService.updateKyc(req.user.id, req.body);
    res.send(user);
});

const logout = catchAsync(async (req, res) => {
    // Current implementation is stateless, but we can add token blacklisting here later
    // For now, we just return success to indicate session closure
    res.status(httpStatus.NO_CONTENT).send();
});

export default {
  register,
  login,
  getMe,
  updateMe,
  updateKyc,
  logout,
  sendOtp,
  verifyOtp,
};
</file>

<file path="src/controllers/bot.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { signalService } from '../services/index.js';
import { broadcastToAll } from '../services/websocket.service.js';

const getStatus = catchAsync(async (req, res) => {
    // In a real system, this would come from a database or Redis
    // For now, we return a mock status or the last set status
    const status = global.BOT_STATUS || 'OFF';
    res.send({ status });
});

const toggleBot = catchAsync(async (req, res) => {
    const { status } = req.body; // 'ON' or 'OFF'
    global.BOT_STATUS = status;
    
    // Broadcast status change
    broadcastToAll({ type: 'bot_status', payload: { status } });

    res.send({ status: global.BOT_STATUS, message: `Bot turned ${status}` });
});

export default {
    getStatus,
    toggleBot
};
</file>

<file path="src/controllers/cms.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import cmsService from '../services/cms.service.js';

const getPage = catchAsync(async (req, res) => {
    const page = await cmsService.getPage(req.params.slug);
    if (!page) {
        // Return default structure if not found (or 404?)
        // Better to return empty object or default for UI to handle "Compose New"
        return res.send({ slug: req.params.slug, title: '', content: '' }); 
    }
    res.send(page);
});

const updatePage = catchAsync(async (req, res) => {
    const page = await cmsService.updatePage(req.params.slug, req.body);
    res.send(page);
});

const getFAQs = catchAsync(async (req, res) => {
    const faqs = await cmsService.getFAQs();
    res.send(faqs);
});

const createFAQ = catchAsync(async (req, res) => {
    const faq = await cmsService.createFAQ(req.body);
    res.status(httpStatus.CREATED).send(faq);
});

const updateFAQ = catchAsync(async (req, res) => {
    const faq = await cmsService.updateFAQ(req.params.id, req.body);
    if (!faq) {
        return res.status(httpStatus.NOT_FOUND).send({ message: 'FAQ not found' });
    }
    res.send(faq);
});

const deleteFAQ = catchAsync(async (req, res) => {
    await cmsService.deleteFAQ(req.params.id);
    res.status(httpStatus.NO_CONTENT).send();
});

export default {
    getPage,
    updatePage,
    getFAQs,
    createFAQ,
    updateFAQ,
    deleteFAQ
};
</file>

<file path="src/controllers/dashboard.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { dashboardService } from '../services/index.js';

const getStats = catchAsync(async (req, res) => {
  const stats = await dashboardService.getAdminStats();
  res.send(stats);
});

const createTicket = catchAsync(async (req, res) => {
    // Initial message construction
    const initialMessage = {
        sender: 'USER',
        message: req.body.message,
        attachments: req.body.attachments
    };
    const ticketBody = {
        subject: req.body.subject,
        category: req.body.category,
        priority: req.body.priority || 'MEDIUM',
        initialMessage
    };
    const ticket = await dashboardService.createTicket(ticketBody, req.user);
    res.status(httpStatus.CREATED).send(ticket);
});

const getMyTickets = catchAsync(async (req, res) => {
    const tickets = await dashboardService.getTickets({ user: req.user.id });
    res.send(tickets);
});

const getAllTickets = catchAsync(async (req, res) => {
    const filter = req.query.status ? { status: req.query.status } : {};
    const tickets = await dashboardService.getTickets(filter);
    res.send(tickets);
});

const replyTicket = catchAsync(async (req, res) => {
    const sender = req.user.role === 'admin' ? 'ADMIN' : 'USER';
    const messageData = {
        sender,
        message: req.body.message,
        attachments: req.body.attachments
    };
    const ticket = await dashboardService.replyToTicket(req.params.ticketId, messageData);
    res.send(ticket);
});

export default {
  getStats,
  createTicket,
  getMyTickets,
  getAllTickets,
  replyTicket
};
</file>

<file path="src/controllers/economic.controller.js">
import catchAsync from '../utils/catchAsync.js';
import { economicService } from '../services/index.js';

const getCalendar = catchAsync(async (req, res) => {
  const { from, to } = req.query;
  // Default to today/this week if not specified? 
  // Let's just pass what we have; service handles undefined query well?
  // Actually let's set defaults if missing to avoid fetching entire DB
  const filter = {};
  if (from) filter.from = from;
  if (to) filter.to = to;

  const events = await economicService.getEvents(filter);
  res.send(events);
});

export default {
  getCalendar,
};
</file>

<file path="src/controllers/health.controller.js">
import os from 'os';

import catchAsync from '../utils/catchAsync.js';

// Helper to get CPU avg
const getCpuAverage = () => {
    const cpus = os.cpus();
    let idleMs = 0;
    let totalMs = 0;

    cpus.forEach((core) => {
        for (const type in core.times) {
            totalMs += core.times[type];
        }
        idleMs += core.times.idle;
    });

    return {
        idle: idleMs / cpus.length,
        total: totalMs / cpus.length,
    };
};

const getSystemHealth = catchAsync(async (req, res) => {
    console.log('Health Check API hit (Native)');
    try {
        const startMeasure = getCpuAverage();

        // Wait 100ms to calculate difference
        setTimeout(() => {
            const endMeasure = getCpuAverage();
            const idleDifference = endMeasure.idle - startMeasure.idle;
            const totalDifference = endMeasure.total - startMeasure.total;
            const percentage = totalDifference === 0 ? 0 : 100 - (100 * idleDifference / totalDifference);

            const totalMem = os.totalmem();
            const freeMem = os.freemem();
            const usedMem = totalMem - freeMem;
            const memPercent = (usedMem / totalMem) * 100;

            res.send({
                serverLoad: percentage.toFixed(1),
                memoryUsage: memPercent.toFixed(1),
                uptime: os.uptime(),
                status: 'LIVE'
            });
        }, 1000); // 1 second sample for better accuracy

    } catch (error) {
        console.error('Error in Health API:', error);
        throw error;
    }
});

export default {
    getSystemHealth
};
</file>

<file path="src/controllers/lead.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import Lead from '../models/Lead.js';
import User from '../models/User.js';
import Plan from '../models/Plan.js';
import Subscription from '../models/Subscription.js';
import ApiError from '../utils/ApiError.js';
import { msg91Service } from '../services/index.js';
const createLead = catchAsync(async (req, res) => {
  const leadData = { ...req.body };
  
  if (req.file) {
      leadData.paymentScreenshot = req.file.path.replace(/\\/g, "/"); // Normalize path for Windows
  }

  // IP Address
  leadData.ipAddress = req.headers['x-forwarded-for'] || req.socket.remoteAddress || req.ip;

  const { verificationToken } = req.body;
  if (!verificationToken) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'Email verification required. Please verify your email.');
  }

  try {
      // Verify Token
      const payload = await import('../services/token.service.js').then(m => m.default.verifyToken(verificationToken, 'EMAIL_VERIFICATION'));
      
      // Ensure Email Matches
      if (payload.sub !== req.body.email) {
          throw new ApiError(httpStatus.BAD_REQUEST, 'Verification token does not match provided email');
      }
      
      if (payload.type !== 'EMAIL_VERIFICATION') {
           throw new ApiError(httpStatus.BAD_REQUEST, 'Invalid token type');
      }

  } catch (error) {
      if (error instanceof ApiError) throw error;
      throw new ApiError(httpStatus.UNAUTHORIZED, 'Invalid or expired verification token');
  }

  // Check Uniqueness
  if (await User.findOne({ email: leadData.email })) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'User already exists with this email');
  }
  
  if (await Lead.findOne({ email: leadData.email })) {
      throw new ApiError(httpStatus.BAD_REQUEST, 'Inquiry already submitted with this email');
  }

  // Mark Verified
  leadData.isEmailVerified = true;

  const lead = await Lead.create(leadData);
  res.status(httpStatus.CREATED).send(lead);
});

const getLeads = catchAsync(async (req, res) => {
  // Simple get all for admin
  const leads = await Lead.find({}).sort({ createdAt: -1 });
  res.send(leads);
});

const approveLead = catchAsync(async (req, res) => {
    const { id } = req.params;
    const lead = await Lead.findById(id);
    if (!lead) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Lead not found');
    }

    if (lead.status === 'CONVERTED') {
         throw new ApiError(httpStatus.BAD_REQUEST, 'Lead already approved');
    }

    // 1. Check if user exists
    let user = await User.findOne({ email: lead.email });
    if (!user) {
        // 2. Create User
        user = await User.create({
            name: lead.name,
            email: lead.email,
            phone: lead.phone,
            password: lead.password || 'Mspk@123', // Fallback if no password provided
            profile: { city: lead.city },
            role: 'user',
            isEmailVerified: true,
            isPhoneVerified: true // Admin approved, implying phone is verified or trusted
        });
    }

    // 3. Find Plans and Create Subscriptions
    const planNames = lead.plan.split(',').map(p => p.trim());
    const validPlans = [];
    const activePlanNames = [];

    for (const planName of planNames) {
        let planDoc;
        if (planName === 'Demo') {
             planDoc = await Plan.findOne({ isDemo: true });
        } else {
             // Find plan by name (loose match)
             planDoc = await Plan.findOne({ name: planName });
             if (!planDoc) {
                 planDoc = await Plan.findOne({ name: { $regex: planName, $options: 'i' } });
             }
        }

        if (planDoc) {
            validPlans.push(planDoc);
            
            // 4. Create Subscription for each valid plan
            const startDate = new Date();
            const endDate = new Date(startDate);
            endDate.setDate(startDate.getDate() + planDoc.durationDays);

            await Subscription.create({
                user: user._id,
                plan: planDoc._id,
                status: 'active',
                startDate: startDate,
                endDate: endDate
            });
            
            activePlanNames.push(planDoc.name);
        }
    }

    // 5. Update user signal access (Legacy Support & Aggregated View)
    if (activePlanNames.length > 0) {
        // Use the longest expiry date for the main user record if needed, 
        // or just keep the last one. For string display, join them.
        const planString = activePlanNames.join(', ');
        
        // Find max expiry (optional, just rough estimate for user model)
        const commonExpiry = new Date(); 
        commonExpiry.setDate(commonExpiry.getDate() + 30); // Default placeholder
        
        user.subscription = { plan: planString, expiresAt: commonExpiry };
        await user.save();
    }

    // 6. WhatsApp Welcome Message (MSG91)
    const welcomeTemplate = process.env.MSG91_WELCOME_TEMPLATE_ID || 'welcome_msg';
    // Mapping components: Body 1: Name, Body 2: Email, Body 3: Password
    const components = {
        "1": user.name,
        "2": user.email,
        "3": lead.password || '*****'
    };
    
    msg91Service.sendWhatsapp(lead.phone, welcomeTemplate, components).catch(err => console.error("MSG91 WA Failed:", err.message));

    // 7. Update Lead Status
    lead.status = 'CONVERTED';
    await lead.save();

    res.send({ user, message: 'Lead approved and subscriptions created successfully' });
});

const getLead = catchAsync(async (req, res) => {
    const lead = await Lead.findById(req.params.id);
    if (!lead) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Inquiry not found');
    }
    res.send(lead);
});

const updateLead = catchAsync(async (req, res) => {
    const lead = await Lead.findByIdAndUpdate(req.params.id, req.body, { new: true, runValidators: true });
    if (!lead) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Inquiry not found');
    }
    res.send(lead);
});

const deleteLead = catchAsync(async (req, res) => {
    const lead = await Lead.findByIdAndDelete(req.params.id);
    if (!lead) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Inquiry not found');
    }
    res.status(httpStatus.NO_CONTENT).send();
});

export default {
  createLead,
  getLeads,
  getLead,
  updateLead,
  deleteLead,
  approveLead
};
</file>

<file path="src/controllers/market.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import MasterSegment from '../models/MasterSegment.js';
import MasterSymbol from '../models/MasterSymbol.js';
import config from '../config/config.js';
import logger from '../config/logger.js';

// Seed Data (Standard Set)
import marketDataService from '../services/marketData.service.js';
import { kiteService } from '../services/kite.service.js';
import subscriptionService from '../services/subscription.service.js';
import { technicalAnalysisService } from '../services/index.js';
import fmpService from '../services/fmp.service.js';



// Get Subscription-Based Tickers (Watchlist)
const getTickers = catchAsync(async (req, res) => {
    // Default to Restricted/Empty if no user (or return Nifty 50 as safe default)
    let allowedSegments = ['INDICES']; 
    let allowedExchanges = ['NSE']; // Minimal default

    if (req.user) {
        try {
            const { default: authService } = await import('../services/auth.service.js');
            const planData = await authService.getUserActivePlan(req.user);

            if (planData && planData.permissions.length > 0) {
                 const perms = planData.permissions;
                 allowedSegments = []; 
                 allowedExchanges = [];

                 if (perms.includes('COMMODITY') || perms.includes('MCX_FUT')) {
                    allowedSegments.push('COMMODITY');
                    allowedExchanges.push('MCX');
                 }
                 if (perms.includes('EQUITY_INTRA') || perms.includes('EQUITY_DELIVERY')) {
                    allowedSegments.push('EQUITY', 'INDICES');
                    allowedExchanges.push('NSE', 'BSE');
                 }
                 if (perms.includes('NIFTY_OPT') || perms.includes('BANKNIFTY_OPT')) {
                    allowedSegments.push('FNO', 'INDICES');
                    allowedExchanges.push('NFO', 'MCX', 'CDS');
                 }
                 if (perms.includes('CURRENCY')) {
                    allowedSegments.push('CURRENCY');
                    allowedExchanges.push('CDS', 'FOREX');
                 }
                 if (perms.includes('CRYPTO')) {
                    allowedSegments.push('CRYPTO');
                    allowedExchanges.push('BINANCE', 'CRYPTO');
                 }
            }
        } catch (e) {
            logger.error(`Error in getTickers filter: ${e.message}`);
        }
    }

    // Filter allowed symbols
    const query = { 
        isWatchlist: true,
        $or: [
            { segment: { $in: allowedSegments } },
            { exchange: { $in: allowedExchanges } }
        ]
    };

    // If no allowed segments found (e.g. invalid user), query fails safe (empty OR default Nifty)
    if (allowedSegments.length === 0 && allowedExchanges.length === 0) {
        // Fallback: Show Nifty 50 only
        query.$or = [{ symbol: 'NSE:NIFTY 50-INDEX' }];
    }

    const symbols = await MasterSymbol.find(query).sort({ segment: 1, symbol: 1 }).lean();

    // Inject Real-Time Prices
    const enriched = symbols.map(s => {
        const live = marketDataService.currentPrices[s.symbol] || s.lastPrice || 0;
        const ohlc = marketDataService.currentQuotes[s.symbol]?.ohlc;
        const prevClose = ohlc ? ohlc.close : (s.prevClose || live); 
        
        let change = 0;
        if (prevClose > 0 && live > 0) {
            change = ((live - prevClose) / prevClose) * 100;
        }

        return {
            symbol: s.symbol,
            name: s.name,
            segment: s.segment,
            exchange: s.exchange,
            price: live,
            prevClose: parseFloat(prevClose.toFixed(2)),
            change: parseFloat(change.toFixed(2)),
            isUp: change >= 0,
            lotSize: s.lotSize || 1,
            // Add color hint?
            color: change >= 0 ? '#22C55E' : '#EF4444'
        };
    });

    res.send(enriched);
});

import { calculateRSI, getFearGreedFromRSI } from '../utils/technicalIndicators.js'; // Import Utility

// Get Market Sentiment (Real-Time RSI + VIX)
const getSentiment = catchAsync(async (req, res) => {
    let context = "INDIAN"; // Default
    let symbol = "NSE:NIFTY 50-INDEX"; 
    let marketLabel = "Market Mood";
    let secondarySymbol = "NSE:NIFTY BANK-INDEX";
    let secondaryName = "BankNifty";

    // Determine User Context
    if (req.user) {
        try {
            const { default: authService } = await import('../services/auth.service.js');
            const planData = await authService.getUserActivePlan(req.user);
            
            if (planData && planData.permissions.length > 0) {
                const perms = planData.permissions;
                
                // Segment Priority Logic
                if (perms.includes('CRYPTO')) {
                    context = "CRYPTO";
                    symbol = "BTCUSDT"; // AllTick/Global
                    marketLabel = "Crypto Mood";
                    secondarySymbol = "ETHUSDT";
                    secondaryName = "ETH";
                } else if (perms.includes('COMMODITY') || perms.includes('MCX_FUT')) {
                    // Check if strictly Global Commodity or Indian MCX
                    // Usually users want Gold/Silver global sentiment
                    context = "COMMODITY";
                    symbol = "XAUUSD"; // Gold
                    marketLabel = "Gold Sentiment";
                    secondarySymbol = "XAGUSD";
                    secondaryName = "Silver";
                } else if (perms.includes('CURRENCY')) {
                    context = "FOREX";
                    symbol = "EURUSD";
                    marketLabel = "Forex Sentiment";
                    secondarySymbol = "GBPUSD";
                    secondaryName = "GBP/USD";
                } else {
                    // Default Indian Equity/FNO
                    context = "INDIAN";
                    symbol = "NSE:NIFTY 50-INDEX";
                    marketLabel = "Nifty Mood";
                    secondarySymbol = "NSE:NIFTY BANK-INDEX";
                    secondaryName = "BankNifty";
                }
            }
        } catch (err) {
            logger.error(`Error in getSentiment filter: ${err.message}`);
        }
    }

    // 2. Market Mood Calculation
    let rsiValue = null; 
    let fearGreedScore = 50; // Default Neutral
    let sentimentLabel = "Neutral";
    let sentimentTrend = "Neutral"; // Default
    let hasData = false;

    // A. Calculate RSI (Common for all)
    try {
        const to = Math.floor(Date.now() / 1000);
        const from = to - (60 * 24 * 60 * 60); // 60 Days
        const candles = await marketDataService.getHistory(symbol, 'day', from, to);
        let closes = (candles || []).map(c => c.close);
        
        // Append live price
        const currentPrice = marketDataService.currentPrices[symbol];
        if (currentPrice && currentPrice > 0) closes.push(currentPrice);

        if (closes.length > 14) {
            rsiValue = calculateRSI(closes, 14);
            hasData = true;
        }
    } catch (e) {
        logger.error(`Error calculating RSI for ${symbol}: ${e.message}`);
    }

    // B. Context Specific Adjustments
    if (context === "INDIAN") {
        // Indian Market: Use INDIA VIX if available
        const vixPrice = marketDataService.currentPrices['NSE:INDIA VIX'] || 
                         marketDataService.currentPrices['INDIA VIX'] || 0;
        
        // If we have RSI, start with that. If not, start with 50.
        fearGreedScore = rsiValue ?? 50; 

        // Adjust with VIX (Volatility Index)
        if (vixPrice > 0) {
            let vixImpact = 0;
            if (vixPrice > 22) vixImpact = -20; // High Fear
            else if (vixPrice > 16) vixImpact = -10; // Moderate Fear
            else if (vixPrice < 12) vixImpact = +10; // Greed/Confidence
            
            fearGreedScore += vixImpact;
            hasData = true; // We have at least VIX data
        }

        // Clamp
        fearGreedScore = Math.max(0, Math.min(100, fearGreedScore));

        // Generate Label
        if (!hasData) {
            sentimentLabel = "No Data";
            fearGreedScore = null;
        } else {
            if (fearGreedScore >= 80) sentimentLabel = "Extreme Greed";
            else if (fearGreedScore >= 60) sentimentLabel = "Greed";
            else if (fearGreedScore <= 20) sentimentLabel = "Extreme Fear";
            else if (fearGreedScore <= 40) sentimentLabel = "Fear";
            else sentimentLabel = "Neutral";
        }

        sentimentTrend = (fearGreedScore !== null && fearGreedScore >= 50) ? "Bullish" : "Bearish";

    } else {
        // Foreign (Crypto/Forex): Pure RSI based
        if (rsiValue !== null) {
            const rsiResult = getFearGreedFromRSI(rsiValue);
            fearGreedScore = rsiResult.score;
            sentimentLabel = rsiResult.label;
            sentimentTrend = (rsiValue > 50) ? "Bullish" : "Bearish";
        } else {
            sentimentLabel = "No Data";
            fearGreedScore = null;
        }
    }

    // 3. Market Trend Data (Percentage Change)
    const getTrend = (sym) => {
        const live = marketDataService.currentPrices[sym] || 0;
        const quote = marketDataService.currentQuotes[sym];
        const open = quote?.ohlc?.open || live;
        
        if (live === 0 || open === 0) return { direction: null, change: null, hasData: false };
        
        const change = ((live - open) / open) * 100;
        return {
            direction: change >= 0 ? 'Bullish' : 'Bearish',
            change: parseFloat(change.toFixed(2)),
            hasData: true
        };
    };

    // Return context-aware trend
    // secondarySymbol and secondaryName are already set based on user context at the top
    // No need to re-declare them here.

    const sentiment = {
        fearGreed: {
            score: fearGreedScore !== null ? parseFloat(fearGreedScore.toFixed(0)) : null,
            label: sentimentLabel,
            trend: sentimentTrend,
            context: marketLabel,
            symbol: symbol
        },
        marketTrend: {
            primary: {
                name: symbol === "NSE:NIFTY 50-INDEX" ? "Nifty" : (symbol === "BTCUSDT" ? "BTC" : (symbol === "XAUUSD" ? "Gold" : symbol)),
                ...getTrend(symbol)
            },
            secondary: {
                name: secondaryName,
                ...getTrend(secondarySymbol)
            }
        }
    };
    
    res.send(sentiment);
});

// Get Hybrid Analysis for ANY Symbol
const getSymbolAnalysis = catchAsync(async (req, res) => {
    let { symbol } = req.params;
    if (!symbol) {
        throw new Error('Symbol is required');
    }
    symbol = symbol.toUpperCase();

    // 1. Fetch Candles Parallel (5m, 15m, 1H, 1D)
    // Use marketDataService.getHistory to handle Kite/AllTick automatically
    const now = Math.floor(Date.now() / 1000);
    const from = now - (5 * 24 * 60 * 60); // 5 Days back

    const [c5m, c15m, c1H, c1D] = await Promise.all([
        marketDataService.getHistory(symbol, '5', from.toString(), now.toString()),
        marketDataService.getHistory(symbol, '15', from.toString(), now.toString()),
        marketDataService.getHistory(symbol, '60', from.toString(), now.toString()),
        marketDataService.getHistory(symbol, 'D', from.toString(), now.toString()),
    ]);

    const analysis = {
        scan_5m: technicalAnalysisService.analyzeTimeframe(c5m, '5m'),
        scan_15m: technicalAnalysisService.analyzeTimeframe(c15m, '15m'),
        scan_1h: technicalAnalysisService.analyzeTimeframe(c1H, '1H'),
    };

    // 2. Calculate Daily Volatility Levels
    let volatility = {};
    if (c1D && c1D.length > 14) {
        // Calculate ATR 14
        let sumTR = 0;
        for(let i=c1D.length-14; i<c1D.length; i++) {
             const h = c1D[i].high; const l = c1D[i].low; const pc = c1D[i-1].close;
             sumTR += Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc));
        }
        const atr = sumTR / 14;
        const currentPrice = c1D[c1D.length-1].close;
        
        volatility = {
            atr: atr,
            expectedHigh: currentPrice + atr,
            expectedLow: currentPrice - atr,
            buyPrice: currentPrice + (atr * 0.2), 
            sellPrice: currentPrice - (atr * 0.2)
        };
    }

    res.send({
        symbol,
        analysis,
        volatility,
        timestamp: new Date()
    });
});

const getNews = catchAsync(async (req, res) => {
    let { symbol } = req.params;
    // Optional: Validate symbol or handle special cases?
    // FmpService handles formatting.
    const news = await fmpService.getNews(symbol);
    res.send(news);
});

const SEED_SEGMENTS = [
    { name: 'Equity Intraday', code: 'EQUITY' },
    { name: 'Futures & Options', code: 'FNO' },
    { name: 'Commodity', code: 'COMMODITY' },
    { name: 'Currency', code: 'CURRENCY' },
    { name: 'BTST (Buy Today Sell Tomorrow)', code: 'BTST' }
];

const SEED_SYMBOLS = [];

const seedMarketData = catchAsync(async (req, res) => {
    // 1. Seed Segments
    const segCount = await MasterSegment.countDocuments();
    if (segCount === 0) {
        await MasterSegment.insertMany(SEED_SEGMENTS);
    }

    // 2. Seed Symbols
    const symCount = await MasterSymbol.countDocuments();
    if (symCount === 0) {
        await MasterSymbol.insertMany(SEED_SYMBOLS);
    }

    res.status(httpStatus.CREATED).send({ message: 'Market Master Data Seeded Successfully' });
});

const createSegment = catchAsync(async (req, res) => {
    const { name, code } = req.body;
    const segment = await MasterSegment.create({ name, code });
    res.status(httpStatus.CREATED).send(segment);
});

const updateSegment = catchAsync(async (req, res) => {
    const { id } = req.params;
    const segment = await MasterSegment.findByIdAndUpdate(id, req.body, { new: true });
    res.send(segment);
});

import kiteInstrumentsService from '../services/kiteInstruments.service.js';

const createSymbol = catchAsync(async (req, res) => {
    // Auto-populate instrumentToken from Kite Instruments Memory
    if (!req.body.instrumentToken && req.body.symbol) {
        const sym = req.body.symbol.toUpperCase();
        
        // Auto-detect Crypto
        if (sym.includes('USDT')) {
            req.body.segment = 'CRYPTO';
            req.body.exchange = 'BINANCE';
        }

        const instrument = kiteInstrumentsService.getInstrumentBySymbol(req.body.symbol);
        if (instrument) {
            req.body.instrumentToken = String(instrument.instrument_token);
        } else {
             // Try removing -EQ suffix for NSE
             if (req.body.symbol.endsWith('-EQ')) {
                 const raw = req.body.symbol.replace('-EQ', '');
                 const inst2 = kiteInstrumentsService.getInstrumentBySymbol(raw);
                 if (inst2) req.body.instrumentToken = String(inst2.instrument_token);
             }
        }
    }

    const symbol = await MasterSymbol.create(req.body);
    
    // Real-time update: Add to running memory and subscribe
    await marketDataService.addSymbol(symbol);

    res.status(httpStatus.CREATED).send(symbol);
});

const updateSymbol = catchAsync(async (req, res) => {
    const { id } = req.params;
    const symbol = await MasterSymbol.findByIdAndUpdate(id, req.body, { new: true });
    res.send(symbol);
});

const getSegments = catchAsync(async (req, res) => {
    const segments = await MasterSegment.find(); // Return all, let frontend filter active if needed or admin sees all
    res.send(segments);
});

const getSymbols = catchAsync(async (req, res) => {
    const { segment, watchlist } = req.query;
    const filter = {};
    if (segment) filter.segment = segment;
    if (watchlist === 'true') filter.isWatchlist = true;
    
    // Sort by symbol name
    // Use .lean() to get plain objects we can modify
    const symbols = await MasterSymbol.find(filter).sort({ symbol: 1 }).lean();
    
    // Inject current price from memory
        const enrichedSymbols = symbols.map(s => {
            s.lastPrice = marketDataService.currentPrices[s.symbol] || s.lastPrice || 0;
            s.ltp = s.lastPrice; // Alias
            
            // Inject OHLC if available (from fetchInitialQuote)
            if (marketDataService.currentQuotes && marketDataService.currentQuotes[s.symbol]) {
                 s.ohlc = marketDataService.currentQuotes[s.symbol].ohlc;
            }
            
            return s;
        });

    res.send(enrichedSymbols);
});

import Signal from '../models/Signal.js'; // Import Signal Model


const deleteSegment = catchAsync(async (req, res) => {
    const { id } = req.params;
    
    // 1. Find the segment first
    const segment = await MasterSegment.findById(id);
    if (!segment) {
        return res.status(httpStatus.NOT_FOUND).send({ message: 'Segment not found' });
    }

    // 2. Check dependencies (Symbols)
    const symbolCount = await MasterSymbol.countDocuments({ segment: segment.code });
    if (symbolCount > 0) {
        return res.status(httpStatus.BAD_REQUEST).send({ 
            message: `Cannot delete. ${symbolCount} symbols are linked to this segment.` 
        });
    }

    // 3. Check dependencies (Signals)
    const signalCount = await Signal.countDocuments({ segment: segment.code });
    if (signalCount > 0) {
        return res.status(httpStatus.BAD_REQUEST).send({ 
            message: `Cannot delete. ${signalCount} active signals are linked to this segment.` 
        });
    }

    // 4. Safe to delete
    await MasterSegment.findByIdAndDelete(id);
    res.status(httpStatus.NO_CONTENT).send();
});

const deleteSymbol = catchAsync(async (req, res) => {
    const { id } = req.params;

    // 1. Find the symbol
    const symbol = await MasterSymbol.findById(id);
    if (!symbol) {
         return res.status(httpStatus.NOT_FOUND).send({ message: 'Symbol not found' });
    }

    // 2. Check dependencies (Signals)
    // We check if any Signal uses this symbol directly (by string name)
    const signalCount = await Signal.countDocuments({ symbol: symbol.symbol });
    if (signalCount > 0) {
        return res.status(httpStatus.BAD_REQUEST).send({ 
            message: `Cannot delete. ${signalCount} active signals are using this symbol.` 
        });
    }

    // 3. Delete
    await MasterSymbol.findByIdAndDelete(id);
    res.status(httpStatus.NO_CONTENT).send();
});

const handleLogin = catchAsync(async (req, res) => {
    const { provider } = req.params;
    const payload = req.body; // { request_token } or { code }
    
    try {
        const session = await marketDataService.handleLogin(provider, payload);
        res.send(session);
    } catch (error) {
        res.status(httpStatus.BAD_REQUEST).send({ message: error.message });
    }
});

const handleLoginCallback = catchAsync(async (req, res) => {
    const { provider } = req.params;
    console.log(`\n--- CALLBACK RECEIVED [${provider}] ---`);
    console.log('Original URL:', req.originalUrl);
    console.log('Query Params:', req.query);

    const { code, request_token, auth_code } = req.query; // standard oauth params
    
    const finalCode = code || request_token || auth_code;
    
    if (!finalCode) {
        console.error(' Missing Code in Query params');
        return res.status(httpStatus.BAD_REQUEST).send(`
            <h1>Login Failed</h1>
            <p>No 'code' found in URL.</p>
            <p>Debug Data:</p>
            <pre>${JSON.stringify(req.query, null, 2)}</pre>
            <p>Ensure you did not remove parameters from the URL.</p>
        `);
    }

    try {
        await marketDataService.handleLogin(provider, { code: finalCode, request_token: finalCode });
        res.send('<h1>Login Successful!</h1><p>Token Generated. You can close this window.</p>');
    } catch (error) {
        console.error('Login Handling Error:', error);
        res.status(httpStatus.INTERNAL_SERVER_ERROR).send(`Login Failed: ${error.message}`);
    }
});

const getLoginUrl = catchAsync(async (req, res) => {
    const { provider } = req.params;
    
    // Ensure service uses latest settings
    await marketDataService.loadSettings();
    
    // Validate Provider
    let adapter = null;
    if (provider === 'kite') adapter = kiteService;
    else return res.status(httpStatus.BAD_REQUEST).send({ message: 'Invalid Provider' });

    // Check if key is configured (using generic keys from settings)
    // Check if key is configured (using generic keys from settings)
    let apiKey = null;
    let apiSecret = null;

    if (provider === 'kite') {
        apiKey = marketDataService.config.kite_api_key;
        apiSecret = marketDataService.config.kite_api_secret;
    } else if (provider === 'alltick') {
        apiKey = marketDataService.config.alltick_api_key;
    }
    
    // Fallback or generic (if still needed)
    if (!apiKey) apiKey = marketDataService.config.data_feed_api_key;
    if (!apiSecret) apiSecret = marketDataService.config.data_feed_api_secret;

    if (!apiKey) {
        return res.status(httpStatus.BAD_REQUEST).send({ message: 'API Key not configured' });
    }

    // Initialize specific adapter
    // For Login URL we typically only need API Key and Redirect URI
    // But generic init requires both usually.
    // Construct Redirect URI based on provider
    const redirectUri = `${req.protocol}://${req.get('host')}/market/login/${provider}/callback`; // e.g. NOT REAL ROUTE? 
    // Wait, the frontend handles redirect usually.
    // Let's assume the redirect_uri is fixed or backend generated.
    // Actually, for Kite it's set in App Console. For others passing it is allowed.
    // Let's use a standard localhost URI for now or what user configured.
    // Ideally user configures "Redirect URI" in settings but we don't have that field yet.
    // We will hardcode `http://localhost:5173/market/login/${provider}` (Frontend Route) as redirect.
    // OR backend route? Usually frontend receives code and POSTs to backend.
    
    const frontendCallback = `${config.frontendUrl}/market/login/${provider}`; // Frontend Page
    
    adapter.initialize(apiKey, apiSecret, frontendCallback);

    const url = adapter.getLoginUrl();
    res.send({ url });
});

const getHistory = catchAsync(async (req, res) => {
    const { symbol, resolution, from, to } = req.query;
    
    logger.info(`[HISTORY_REQUEST] Received from ${req.ip} - Symbol: ${symbol}, Resolution: ${resolution}, From: ${from}, To: ${to}`);
    logger.info(`[HISTORY_REQUEST] Headers: ${JSON.stringify(req.headers)}`);
    
    if (!symbol || !resolution || !from || !to) {
        logger.warn(`[HISTORY_REQUEST] Missing parameters!`);
        return res.status(httpStatus.BAD_REQUEST).send({ message: 'Missing required parameters: symbol, resolution, from, to' });
    }

    logger.info(`History Request: ${symbol} (${resolution}) from ${from} to ${to}`);
    const history = await marketDataService.getHistory(symbol, resolution, from, to);
    logger.info(`[HISTORY_RESPONSE] Returning ${history.length} candles for ${symbol}`);
    res.send(history);
});

const searchInstruments = catchAsync(async (req, res) => {
    const { q } = req.query;
    let instruments = await marketDataService.searchInstruments(q);

    // Strict Segment Filtering based on User Plan
    if (req.user) {
        try {
            const { default: authService } = await import('../services/auth.service.js');
            const planData = await authService.getUserActivePlan(req.user);
            
            if (planData && planData.permissions.length > 0) {
                const perms = planData.permissions;
                const allowedSegments = [];
                const allowedExchanges = [];

                // 1. Map Permissions to Allowed Data Segments/Exchanges
                if (perms.includes('COMMODITY') || perms.includes('MCX_FUT')) {
                    allowedSegments.push('COMMODITY');
                    allowedExchanges.push('MCX'); 
                }
                if (perms.includes('EQUITY_INTRA') || perms.includes('EQUITY_DELIVERY')) {
                    allowedSegments.push('EQUITY', 'INDICES');
                    allowedExchanges.push('NSE', 'BSE');
                }
                if (perms.includes('NIFTY_OPT') || perms.includes('BANKNIFTY_OPT')) {
                    allowedSegments.push('FNO', 'INDICES'); 
                    allowedExchanges.push('NFO', 'MCX', 'CDS', 'BCD'); 
                }
                if (perms.includes('CURRENCY')) {
                    allowedSegments.push('CURRENCY');
                    allowedExchanges.push('CDS', 'BCD', 'FOREX');
                }
                if (perms.includes('CRYPTO')) {
                    allowedSegments.push('CRYPTO');
                    allowedExchanges.push('BINANCE', 'CRYPTO');
                }

                
                // Allow "Demo" plan to see everything OR restrict? 
                // User said: "Demo plan... commodity segment... sirf commodity dena hai"
                // So even Demo follows restriction if it has a segment attached.
                
                // 3. Filter Logic
                // If we have ANY restrictions, apply them. If no active sub found (or free user?), maybe allow all or restrict?
                // Assuming strict: If user has a plan, STRICTLY follow plan. 
                
                if (allowedSegments.length > 0 || allowedExchanges.length > 0) {
                     instruments = instruments.filter(item => {
                        const seg = item.segment || ''; // e.g. EQUITY, COMMODITY
                        const exc = item.exchange || ''; // e.g. NSE, MCX
                        
                        // Check if Item matches Allowed Segment OR Allowed Exchange
                        const segmentMatch = allowedSegments.includes(seg);
                        const exchangeMatch = allowedExchanges.includes(exc);
                        
                        return segmentMatch || exchangeMatch;
                    });
                }
            }
        } catch (err) {
            logger.error(`Error filtering segments for user ${req.user.id}: ${err.message}`);
            // On error, maybe fail open or closed? 
            // Better to fail open (return results) or log? 
            // Let's return filtered if possible, but if error, return all (fallback)
        }
    }

    res.send(instruments);
});

const syncInstruments = catchAsync(async (req, res) => {
    const result = await marketDataService.syncInstruments();
    res.send(result);
});

export default {
    seedMarketData,
    getSegments,
    createSegment,
    deleteSegment,
    updateSegment,
    getSymbols,
    createSymbol,
    updateSymbol,
    deleteSymbol,
    handleLogin,
    handleLoginCallback,
    getLoginUrl,
    getHistory,
    searchInstruments,
    syncInstruments,
    getTickers, // New
    getSentiment, // New
    getSymbolAnalysis,
    getNews,
    getMarketStats: (req, res) => {
        const stats = marketDataService.getStats();
        res.send(stats);
    }
};
</file>

<file path="src/controllers/notification.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import Notification from '../models/Notification.js';

const getMyNotifications = catchAsync(async (req, res) => {
  const notifications = await Notification.find({ user: req.user.id })
    .sort({ createdAt: -1 })
    .limit(50);
  
  const unreadCount = await Notification.countDocuments({ user: req.user.id, isRead: false });

  res.send({ results: notifications, unreadCount });
});

const markAsRead = catchAsync(async (req, res) => {
  const notification = await Notification.findOneAndUpdate(
    { _id: req.params.notificationId, user: req.user.id },
    { isRead: true },
    { new: true }
  );
  if (!notification) {
    return res.status(httpStatus.NOT_FOUND).send({ message: 'Notification not found' });
  }
  res.send(notification);
});

const markAllAsRead = catchAsync(async (req, res) => {
  await Notification.updateMany(
    { user: req.user.id, isRead: false },
    { isRead: true }
  );
  res.status(httpStatus.NO_CONTENT).send();
});

const registerFCMToken = catchAsync(async (req, res) => {
  const { token } = req.body;
  console.log('NotifController: Registering FCM Token:', token, 'for User:', req.user._id);
  if (!token) {
    return res.status(httpStatus.BAD_REQUEST).send({ message: 'Token is required' });
  }

  // Update user with unique token (avoid duplicates)
  await req.user.updateOne({
    $addToSet: { fcmTokens: token }
  });

  res.status(httpStatus.OK).send({ message: 'Token registered successfully' });
});

const getNotification = catchAsync(async (req, res) => {
    const notification = await Notification.findOne({
        _id: req.params.notificationId,
        user: req.user.id
    });
    if (!notification) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Notification not found');
    }
    res.send(notification);
});

const deleteNotification = catchAsync(async (req, res) => {
    const notification = await Notification.findOneAndDelete({
        _id: req.params.notificationId,
        user: req.user.id
    });
    if (!notification) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Notification not found');
    }
    res.status(httpStatus.NO_CONTENT).send();
});

export default {
  getMyNotifications,
  markAsRead,
  markAllAsRead,
  registerFCMToken,
  getNotification,
  deleteNotification
};
</file>

<file path="src/controllers/payment.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import AdminPaymentDetails from '../models/AdminPaymentDetails.js';
import UserSubscription from '../models/UserSubscription.js';
import Segment from '../models/Segment.js';
import AdminSetting from '../models/AdminSetting.js';
import ApiError from '../utils/ApiError.js';

// --- Admin Payment Details ---

const getPaymentDetails = catchAsync(async (req, res) => {
  let details = await AdminPaymentDetails.findOne();
  if (!details) {
      details = await AdminPaymentDetails.create({});
  }
  res.send(details);
});

const updatePaymentDetails = catchAsync(async (req, res) => {
  const body = req.body;
  if (req.file) {
      body.qrCodeUrl = req.file.path.replace(/\\/g, '/'); // Normalize path
  }
  
  let details = await AdminPaymentDetails.findOne();
  if (!details) {
      details = await AdminPaymentDetails.create(body);
  } else {
      Object.assign(details, body);
      await details.save();
  }
  res.send(details);
});

// --- Manual Verification Flow ---

const submitPayment = catchAsync(async (req, res) => {
    const { userId, segmentCodes, transactionId } = req.body;
    // req.body.segmentCodes might be stringified if coming from FormData
    const segments = typeof segmentCodes === 'string' ? JSON.parse(segmentCodes) : segmentCodes;

    if (!req.file) {
        throw new ApiError(httpStatus.BAD_REQUEST, 'Screenshot is required');
    }

    // 1. Validate segments exist
    const validSegments = await Segment.find({ segment_code: { $in: segments } });
    if (validSegments.length !== segments.length) {
        throw new ApiError(httpStatus.BAD_REQUEST, 'Invalid segments selected');
    }

    // 2. Calculate Amount (For record keeping)
    const totalAmount = validSegments.reduce((sum, seg) => sum + seg.base_price, 0);

    // 3. Create Subscription with PENDING status
    // Note: We are creating a NEW subscription record.
    // If user has existing active one, this will coexist or replace?
    // User requested: "Payment Submitted! Waiting for Admin Approval."
    
    // We fetch checks logic from subscription service typically, but here we duplicate slightly for "Pending" logic
    // Validity will be decided when Admin APPROVES. 
    // So start/end date are tentative or null? Let's set start now, end now (expired) + valid flag false?
    // Better: status = 'pending_verification'.
    
    // Check allow enum in schema? We need to update UserSubscription enum first?
    // Let's check UserSubscription schema... it has ['active', 'expired', 'cancelled'].
    // We need to add 'pending'.

    const subscription = await UserSubscription.create({
        user_id: req.user.id,
        segments: segments,
        total_amount: totalAmount,
        start_date: new Date(),
        end_date: new Date(), // No validity yet
        plan_type: 'premium', // Manual payments are usually premium
        status: 'pending',    // <--- Need to update Enum
        is_active: false,
        // We need a place to store screenshot/transactionId. 
        // Schema update required? Yes.
        // For now, storing meta in a new field or hijacking an existing one?
        // Let's strictly update the schema in next step.
    });
    
    // Hack: We need to save screenshotUrl and txnId.
    // I will attach them to the subscription object if schema allows, or use a separate "PaymentRequest" model?
    // "Simple" -> Separate model is complex.
    // Better: Update UserSubscription to have `payment_meta` or similar.
    
    // FOR NOW, to allow progress, I will update UserSubscription schema in next step to include `payment_proof` and `transaction_id`.

    subscription.payment_proof = req.file.path.replace(/\\/g, '/'); // Add this field to schema
    subscription.transaction_id = transactionId;
    await subscription.save();

    res.status(httpStatus.CREATED).send({ message: 'Payment submitted for verification', subscription });
});

export default {
    getPaymentDetails,
    updatePaymentDetails,
    submitPayment
};
</file>

<file path="src/controllers/plan.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { planService } from '../services/index.js';
import ApiError from '../utils/ApiError.js';

const createPlan = catchAsync(async (req, res) => {
  const plan = await planService.createPlan(req.body);
  res.status(httpStatus.CREATED).send(plan);
});

const getPlans = catchAsync(async (req, res) => {
  const filter = { isActive: true };
  // Check if user is admin (req.user is set by auth middleware)
  if (req.user && req.user.role === 'admin') {
      delete filter.isActive;
  }
  const plans = await planService.queryPlans(filter);
  res.send(plans);
});

const getPlan = catchAsync(async (req, res) => {
  const plan = await planService.getPlanById(req.params.planId);
  if (!plan) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Plan not found');
  }
  res.send(plan);
});

const updatePlan = catchAsync(async (req, res) => {
  const plan = await planService.updatePlanById(req.params.planId, req.body);
  res.send(plan);
});



const deletePlan = catchAsync(async (req, res) => {
  // Safe Deletion Check
  const Subscription = (await import('../models/Subscription.js')).default;
  const activeSubs = await Subscription.countDocuments({ plan: req.params.planId, status: 'active' });
  
  if (activeSubs > 0) {
    throw new ApiError(httpStatus.BAD_REQUEST, `Cannot delete plan. It has ${activeSubs} active subscribers.`);
  }

  await planService.deletePlanById(req.params.planId);
  res.status(httpStatus.NO_CONTENT).send();
});

export default {
  createPlan,
  getPlans,
  getPlan,
  updatePlan,
  deletePlan,
};
</file>

<file path="src/controllers/search.controller.js">
import catchAsync from '../utils/catchAsync.js';
import User from '../models/User.js';
import Signal from '../models/Signal.js';
import Plan from '../models/Plan.js';
import Ticket from '../models/Ticket.js';

const globalSearch = catchAsync(async (req, res) => {
    const { q } = req.query;
    if (!q || q.length < 2) {
        return res.send([]);
    }

    const regex = new RegExp(q, 'i');

    // Parallel Search
    const [users, signals, plans, tickets] = await Promise.all([
        // 1. Users (Name, Email) - Limit 5
        User.find({ 
            $or: [{ name: regex }, { email: regex }] 
        }).select('name email role').limit(5),

        // 2. Signals (Symbol) - Limit 5
        Signal.find({ 
            symbol: regex 
        }).select('symbol type status').limit(5),

        // 3. Plans (Name) - Limit 3
        Plan.find({ 
            name: regex 
        }).select('name price').limit(3),

        // 4. Tickets (Subject, ID) - Limit 3 (Support only?)
        // If admin, search all. If user, search own??
        // Assuming global search is mostly for Admin.
        req.user.role === 'admin' ? 
            Ticket.find({ $or: [{ subject: regex }, { ticketId: regex }] }).select('ticketId subject status').limit(3) 
            : []
    ]);

    // Format Results
    const results = [
        ...users.map(u => ({ type: 'USER', id: u._id, title: u.name, subtitle: u.email, link: `/users/details?id=${u._id}` })), // Deep link to details
        ...signals.map(s => ({ type: 'SIGNAL', id: s._id, title: s.symbol, subtitle: `${s.type} - ${s.status}`, link: `/signals/all` })),
        ...plans.map(p => ({ type: 'PLAN', id: p._id, title: p.name, subtitle: `‚Çπ${p.price}`, link: `/plans/all` })),
        ...tickets.map(t => ({ type: 'TICKET', id: t._id, title: t.subject, subtitle: t.ticketId, link: `/tickets/details?id=${t._id}` }))
    ];

    res.send(results);
});

export default {
    globalSearch
};
</file>

<file path="src/controllers/setting.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import Setting from '../models/Setting.js';
import logger from '../config/logger.js';

import { encrypt } from '../utils/encryption.js';

const SENSITIVE_KEYS = ['data_feed_api_key', 'data_feed_api_secret', 'data_feed_access_token', 'kite_api_secret', 'kite_access_token', 'alltick_api_key'];

const getSettings = catchAsync(async (req, res) => {
    // Return all or filter by keys if needed
    
    const settings = await Setting.find({});
    // Transform to simple object: { key: value }
    const settingsMap = settings.reduce((acc, curr) => {
        // Mask sensitive keys
        if (SENSITIVE_KEYS.includes(curr.key) && curr.value) {
            acc[curr.key] = '********'; // Masked Value
        } else {
            acc[curr.key] = curr.value;
        }
        return acc;
    }, {});

    res.send(settingsMap);
});

const updateSetting = catchAsync(async (req, res) => {
    const { key, value } = req.body;
    let finalValue = value;

    // Encrypt if sensitive
    if (SENSITIVE_KEYS.includes(key)) {
        if (value === '********') return res.send({ message: 'Ignored masked value' }); // Do not update
        finalValue = encrypt(value);
    }
    
    // Upsert
    const setting = await Setting.findOneAndUpdate(
        { key },
        { value: finalValue },
        { new: true, upsert: true, setDefaultsOnInsert: true }
    );
    
    logger.info(`Setting updated: ${key} by User ${req.user.id}`);
    res.send(setting);
});

const updateBulkSettings = catchAsync(async (req, res) => {
    const updates = req.body; // Expect { key1: val1, key2: val2 }

    const promises = Object.keys(updates).map(async (key) => {
        let value = updates[key];

        if (SENSITIVE_KEYS.includes(key)) {
            // If masked value sent back, ignore this key
            if (value === '********' || value === '') return; 
            value = encrypt(value);
        }

        return Setting.findOneAndUpdate(
            { key },
            { value: value },
            { new: true, upsert: true }
        );
    });

    await Promise.all(promises);

    // Reload Market Data Config
    try {
        const marketDataService = (await import('../services/marketData.service.js')).default;
        await marketDataService.loadSettings();
        logger.info('Market Data Settings Reloaded');
    } catch (error) {
        logger.error('Failed to reload market data settings', error);
    }

    res.send({ message: 'Settings updated successfully' });
});

export default {
    getSettings,
    updateSetting,
    updateBulkSettings
};
</file>

<file path="src/controllers/signal.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import ApiError from '../utils/ApiError.js';
import { signalService, subscriptionService, allTickService, technicalAnalysisService } from '../services/index.js';

const createSignal = catchAsync(async (req, res) => {
  const signal = await signalService.createSignal(req.body, req.user);
  res.status(httpStatus.CREATED).send(signal);
});

const getSignal = catchAsync(async (req, res) => {
  const signal = await signalService.getSignalById(req.params.signalId);
  if (!signal) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Signal not found');
  }
  res.send(signal);
});

const createManualSignal = catchAsync(async (req, res) => {
    // 1. Force Type to 'Manual'
    const payload = { ...req.body, isManual: true, status: 'Active' };
    
    // 2. Create via Service
    const signal = await signalService.createSignal(payload, req.user);

    // 3. Emit Socket Event (Critical for Live Chart)
    // signalService.createSignal usually emits, but let's ensure it.
    // Assuming service handles emission.
    
    res.status(httpStatus.CREATED).send(signal);
});

const getSignals = catchAsync(async (req, res) => {
  // Logic: Show all if admin. If user, show Free OR Subscribed segments.
  let filter = {};
  const { page = 1, limit = 10 } = req.query;

  // 1. Build Base Filter (Permissions)
  let baseFilter = {};
  if (!req.user || req.user.role !== 'admin') {
      let allowedCategories = [];
      let allowedSegments = []; 

      // If user is logged in, fetch their subscriptions (with legacy fallback)
      if (req.user) {
          const { default: authService } = await import('../services/auth.service.js');
          const planData = await authService.getUserActivePlan(req.user);
          
          if (planData && planData.permissions.length > 0) {
              const perms = planData.permissions;
              allowedSegments = []; 
              allowedCategories = [];

              // Map Permissions to Segments
              if (perms.includes('COMMODITY') || perms.includes('MCX_FUT')) {
                   allowedSegments.push('COMMODITY', 'MCX');
                   allowedCategories.push('MCX_FUT');
              }
              if (perms.includes('EQUITY_INTRA') || perms.includes('EQUITY_DELIVERY')) {
                   allowedSegments.push('EQUITY', 'NSE', 'BSE');
                   allowedCategories.push('EQUITY_INTRA', 'EQUITY_DELIVERY');
              }
              if (perms.includes('NIFTY_OPT') || perms.includes('BANKNIFTY_OPT')) {
                   allowedSegments.push('FNO', 'NFO', 'CDS');
                   allowedCategories.push('NIFTY_OPT', 'BANKNIFTY_OPT', 'STOCK_OPT', 'FINNIFTY_OPT');
              }
              if (perms.includes('CURRENCY')) {
                   allowedSegments.push('CURRENCY', 'CDS', 'BCD');
                   allowedCategories.push('CURRENCY');
              }
              if (perms.includes('CRYPTO')) {
                   allowedSegments.push('CRYPTO', 'BINANCE');
                   allowedCategories.push('CRYPTO');
              }
          }
      }

      baseFilter = {
          $or: [
             { isFree: true }, 
             {
                 // Subscribed (Active OR Closed)
                 $or: [
                    { segment: { $in: allowedSegments } },
                    { category: { $in: allowedCategories } }
                 ]
             }
          ]
      };
  }

  // 2. Build Query Filters Array
  const { search, symbol, status, segment, type, dateFilter, signalId } = req.query;
  const conditions = [baseFilter];

  if (search) {
      conditions.push({ symbol: { $regex: search, $options: 'i' } });
  }

  if (symbol) {
      conditions.push({ symbol: symbol });
  }

  if (dateFilter && dateFilter !== 'All') {
      const now = new Date();
      let start = new Date(now);
      let end = new Date(now);
      
      if (dateFilter === 'Today') {
          start.setHours(0, 0, 0, 0);
          end.setHours(23, 59, 59, 999);
      } else if (dateFilter === 'Yesterday') {
          start.setDate(now.getDate() - 1);
          start.setHours(0, 0, 0, 0);
          end.setDate(now.getDate() - 1);
          end.setHours(23, 59, 59, 999);
      } else if (dateFilter === 'This Week') {
          const day = now.getDay(); 
          const diff = now.getDate() - day + (day === 0 ? -6 : 1); 
          start = new Date(now.setDate(diff));
          start.setHours(0, 0, 0, 0);
          end.setHours(23, 59, 59, 999);
      }
      
      conditions.push({
          $or: [
              { createdAt: { $gte: start, $lte: end } },
              { 'report.closedAt': { $gte: start, $lte: end } }
          ]
      });
  }

  if (status && status !== 'All') {
      if (status === '!Closed') {
          conditions.push({ status: { $ne: 'Closed' } });
      } else if (status === 'History') {
          conditions.push({ status: { $in: ['Closed', 'Target Hit', 'Stoploss Hit'] } });
      } else {
          conditions.push({ status: status });
      }
  }

  if (segment && segment !== 'All') {
      conditions.push({ segment: segment });
  }

  if (type && type !== 'All') {
      conditions.push({ type: type.toUpperCase() });
  }

  if (signalId) {
      conditions.push({ _id: signalId });
  }

  if (req.query.timeframe) {
      conditions.push({ timeframe: req.query.timeframe });
  }

  // Final Composite Filter
  filter = conditions.length > 1 ? { $and: conditions } : conditions[0];

  // 3. Query Data
  const signalsData = await signalService.querySignals(filter, { page, limit });
  
  // 4. Get Global Stats
  const stats = await signalService.getSignalStats();

  const formattedResults = signalsData.results.map(s => ({
      id: s._id,
      symbol: s.symbol,
      type: s.type,
      entry: s.entryPrice,
      stoploss: s.stopLoss,
      status: s.status,
      timestamp: s.createdAt,
      createdAt: s.createdAt,
      segment: s.segment,
      category: s.category,
      targets: s.targets,
      isFree: s.isFree,
      notes: s.notes,
      strategyId: s.strategyId,
      strategyName: s.strategyName,
      timeframe: s.timeframe,
      metrics: s.metrics
  }));

  res.send({
      results: formattedResults,
      pagination: {
          page: signalsData.page,
          limit: signalsData.limit,
          totalPages: signalsData.totalPages,
          totalResults: signalsData.totalResults
      },
      stats
  });
});

const updateSignal = catchAsync(async (req, res) => {
    const signal = await signalService.updateSignalById(req.params.signalId, req.body);
    res.send(signal);
});

const deleteSignal = catchAsync(async (req, res) => {
    await signalService.deleteSignalById(req.params.signalId);
    res.status(httpStatus.NO_CONTENT).send();
});

const getSignalAnalysis = catchAsync(async (req, res) => {
    const { signalId } = req.params;
    
    // 1. Fetch Signal to get Symbol
    const signal = await signalService.getSignalById(signalId);
    if (!signal) {
        throw new ApiError(httpStatus.NOT_FOUND, 'Signal not found');
    }
    const symbol = signal.symbol;

    // 2. Fetch Candles Parallel (5m, 15m, 1H, 1D)
    const now = new Date();
    const from = new Date(now.getTime() - 5 * 24 * 60 * 60 * 1000); // 5 Days back is enough for 1H/15m logic
    
    const [c5m, c15m, c1H, c1D] = await Promise.all([
        allTickService.getHistoricalData(symbol, '5m', from, now),
        allTickService.getHistoricalData(symbol, '15m', from, now),
        allTickService.getHistoricalData(symbol, '1H', from, now),
        allTickService.getHistoricalData(symbol, '1D', from, now),
    ]);

    // 3. Helper to Calculate Hybrid Logic per Timeframe
    const analyzeTimeframe = (candles, timeframeName) => {
        if (!candles || candles.length < 20) return { trend: 'NEUTRAL', signal: 'NONE', age: 0, price: 0 };

        // Convert to Heikin Ashi
        const haCandles = [];
        haCandles.push({ ...candles[0] });
        for (let i = 1; i < candles.length; i++) {
            const curr = candles[i];
            const prevHa = haCandles[i - 1];
            const haOpen = (prevHa.open + prevHa.close) / 2;
            const haClose = (curr.open + curr.high + curr.low + curr.close) / 4;
            haCandles.push({
                time: curr.time,
                open: haOpen, high: Math.max(curr.high, haOpen, haClose),
                low: Math.min(curr.low, haOpen, haClose), close: haClose
            });
        }

        // Indicators
        const st = technicalAnalysisService.calculateSupertrend(haCandles, 14, 1.5);
        const psar = technicalAnalysisService.calculatePSAR(haCandles);
        const structure = technicalAnalysisService.calculateMarketStructure(haCandles, 5);
        
        const lastCandle = candles[candles.length - 1]; // Use Standard Price for Levels
        const currentPrice = lastCandle.close;

        // Determine Signal Status on Last Complete Candle
        // Or current state? Dashboard usually shows Current Trend.
        const trend = st.trend === 1 ? 'BULLISH' : 'BEARISH';
        
        // Signal Logic (Replicating Hybrid)
        let signalType = 'HOLD'; // or BUY/SELL if fresh
        if (st.isBuy) signalType = 'BUY';
        if (st.isSell) signalType = 'SELL';
        
        // Check Confluence for "Strong" status
        let isStrong = false;
        if (trend === 'BULLISH' && psar.value < currentPrice && structure.structure === 'HH_HL') isStrong = true;
        if (trend === 'BEARISH' && psar.value > currentPrice && structure.structure === 'LH_LL') isStrong = true;

        return {
            timeframe: timeframeName,
            trend,
            signalType,
            price: currentPrice,
            support: st.trend === 1 ? st.value : psar.value,
            resistance: st.trend === -1 ? st.value : psar.value,
            isStrong
        };
    };

    const analysis = {
        scan_5m: analyzeTimeframe(c5m, '5m'),
        scan_15m: analyzeTimeframe(c15m, '15m'),
        scan_1h: analyzeTimeframe(c1H, '1H'),
    };

    // 4. Calculate Daily Volatility Levels
    let volatility = {};
    if (c1D && c1D.length > 14) {
        // Calculate ATR 14
        let sumTR = 0;
        for(let i=c1D.length-14; i<c1D.length; i++) {
             const h = c1D[i].high; const l = c1D[i].low; const pc = c1D[i-1].close;
             sumTR += Math.max(h-l, Math.abs(h-pc), Math.abs(l-pc));
        }
        const atr = sumTR / 14;
        const currentPrice = c1D[c1D.length-1].close;
        
        volatility = {
            atr: atr,
            expectedHigh: currentPrice + atr,
            expectedLow: currentPrice - atr,
            buyPrice: currentPrice + (atr * 0.2), // Pivot approximation
            sellPrice: currentPrice - (atr * 0.2)
        };
    }

    res.send({
        symbol,
        analysis,
        volatility,
        timestamp: new Date()
    });
});

export default {
  createSignal,
  createManualSignal,
  getSignal,
  getSignals,
  getSignalAnalysis,
  updateSignal,
  deleteSignal
};
</file>

<file path="src/controllers/strategy.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import Strategy from '../models/Strategy.js';

import strategyService from '../services/strategy.service.js';

const createStrategy = catchAsync(async (req, res) => {
    const strategy = await Strategy.create({
        ...req.body,
        user: req.user.id // Assign creator
    });
    strategyService.reloadStrategies();
    res.status(httpStatus.CREATED).send(strategy);
});

const getStrategies = catchAsync(async (req, res) => {
    // Admin sees all? Or user sees theirs? For now, fetch all.
    const strategies = await Strategy.find().sort({ isSystem: -1, createdAt: -1 });
    res.send(strategies);
});

const seedStrategies = catchAsync(async (req, res) => {
    const result = await strategyService.seedStrategies(req.user);
    res.status(httpStatus.CREATED).send(result);
});

const updateStrategy = catchAsync(async (req, res) => {
    // Protection Removed as per User Request for Full Control
    const strategy = await Strategy.findByIdAndUpdate(req.params.strategyId, req.body, { new: true });
    if (!strategy) {
        throw new Error('Strategy not found'); 
    }
    strategyService.reloadStrategies();
    res.send(strategy);
});

const deleteStrategy = catchAsync(async (req, res) => {
    // Protection Removed
    await Strategy.findByIdAndDelete(req.params.strategyId);
    strategyService.reloadStrategies();
    res.status(httpStatus.NO_CONTENT).send();
});

export default {
    createStrategy,
    getStrategies,
    updateStrategy,
    deleteStrategy,
    seedStrategies
};
</file>

<file path="src/controllers/subBroker.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { subBrokerService } from '../services/index.js';

const createSubBroker = catchAsync(async (req, res) => {
    const subBroker = await subBrokerService.createSubBroker(req.body);
    res.status(httpStatus.CREATED).send(subBroker);
});

const getSubBrokers = catchAsync(async (req, res) => {
    // Filter logic can be added here if needed
    const filter = {};
    const result = await subBrokerService.getSubBrokers(filter);
    res.send(result);
});

import Subscription from '../models/Subscription.js';

const getSubBrokerDetails = catchAsync(async (req, res) => {
    const subBroker = await subBrokerService.getSubBrokerById(req.params.subBrokerId);
    if (!subBroker) {
        return res.status(httpStatus.NOT_FOUND).send({ message: 'Sub Broker not found' });
    }
    
    // Fetch raw clients
    const rawClients = await subBrokerService.getSubBrokerClients(req.params.subBrokerId);
    
    // Enrich clients with Subscription Data (Similar to Admin Controller)
    const clients = await Promise.all(rawClients.map(async (u) => {
        const sub = await Subscription.findOne({ user: u.id, status: 'active' }).populate('plan');
        return {
            id: u.id,
            name: u.name,
            email: u.email,
            phone: u.phone || '',
            
            // Subscription / Plan Data
            plan: (sub && sub.plan) ? sub.plan.name : (u.subscription && u.subscription.plan ? u.subscription.plan : 'Free'), 
            planStatus: sub ? 'Active' : 'Inactive',
            subscriptionStart: sub ? sub.startDate : null,
            subscriptionExpiry: sub ? sub.endDate : null,

            // Stats
            status: u.status || 'Active', 
            equity: u.equity || 0,
            walletBalance: u.walletBalance || 0,
            clientId: u.clientId || `MS-${u.id.toString().slice(-4)}`,
            
            joinDate: u.createdAt,
        };
    }));

    const commissions = await subBrokerService.getCommissions(req.params.subBrokerId);
    res.send({ subBroker, clients, commissions });
});

const updateSubBroker = catchAsync(async (req, res) => {
    const subBroker = await subBrokerService.updateSubBrokerById(req.params.subBrokerId, req.body);
    res.send(subBroker);
});

const deleteSubBroker = catchAsync(async (req, res) => {
    await subBrokerService.deleteSubBrokerById(req.params.subBrokerId);
    res.status(httpStatus.NO_CONTENT).send();
});

// For Sub-Broker Self View (Legacy/Auth Compat)
const getMyClients = catchAsync(async (req, res) => {
    const clients = await subBrokerService.getSubBrokerClients(req.user.id);
    res.send(clients);
});

const getMyCommissions = catchAsync(async (req, res) => {
    const commissions = await subBrokerService.getCommissions(req.user.id);
    res.send(commissions);
});

const processPayout = catchAsync(async (req, res) => {
    const result = await subBrokerService.processPayout(req.params.subBrokerId);
    res.send({ message: 'Payout processed successfully', result });
});

export default {
  createSubBroker,
  getSubBrokers,
  getSubBrokerDetails,
  updateSubBroker,
  deleteSubBroker,
  getMyClients,
  getMyCommissions,
  processPayout
};
</file>

<file path="src/controllers/subscription.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import subscriptionService from '../services/subscription.service.js';

// GET /api/segments
const getSegments = catchAsync(async (req, res) => {
  const segments = await subscriptionService.getAllSegments();
  res.send(segments);
});

// GET /api/subscriptions/admin/all
const getAllSubscriptions = catchAsync(async (req, res) => {
  const subscriptions = await subscriptionService.getAllSubscriptions();
  res.send(subscriptions);
});

// POST /api/subscribe/purchase
// Body: { segments: ['EQUITY', 'FNO'], planType: 'premium' }
const purchase = catchAsync(async (req, res) => {
  const { segments, planType } = req.body;
  const user = req.user; // Assumes auth middleware populates req.user

  if (!segments || !Array.isArray(segments) || segments.length === 0) {
    return res.status(httpStatus.BAD_REQUEST).send({ message: 'Segments array is required' });
  }

  const subscription = await subscriptionService.purchaseSegments(user.id, segments, planType);
  res.status(httpStatus.CREATED).send(subscription);
});

// GET /api/subscribe/status
const getStatus = catchAsync(async (req, res) => {
  const status = await subscriptionService.getSubscriptionStatus(req.user.id);
  res.send({ hasActiveSubscription: !!status, subscription: status });
});

// GET /api/subscribe/has-access/:segment
const checkAccess = catchAsync(async (req, res) => {
  const { segment } = req.params;
  const hasAccess = await subscriptionService.checkAccess(req.user.id, segment.toUpperCase());
  res.send({ segment, hasAccess });
});

export default {
  getSegments,
  getAllSubscriptions,
  purchase,
  getStatus,
  checkAccess
};
</file>

<file path="src/controllers/ticket.controller.js">
import httpStatus from 'http-status';
import catchAsync from '../utils/catchAsync.js';
import { dashboardService } from '../services/index.js';
import Ticket from '../models/Ticket.js';

const createTicket = catchAsync(async (req, res) => {
  const ticket = await dashboardService.createTicket(req.body, req.user);
  res.status(httpStatus.CREATED).send(ticket);
});

const getTickets = catchAsync(async (req, res) => {
  const filter = req.user.role === 'admin' ? {} : { user: req.user.id };
  const tickets = await dashboardService.getTickets(filter);
  res.send(tickets);
});

const getTicketById = catchAsync(async (req, res) => {
  const ticket = await Ticket.findById(req.params.id).populate('user', 'name email');
  if (!ticket) {
    return res.status(httpStatus.NOT_FOUND).send({ message: 'Ticket not found' });
  }
  res.send(ticket);
});

const updateTicket = catchAsync(async (req, res) => {
  const ticket = await Ticket.findByIdAndUpdate(req.params.id, req.body, { new: true });
  res.send(ticket);
});

const replyToTicket = catchAsync(async (req, res) => {
  const ticket = await dashboardService.replyToTicket(req.params.id, {
    sender: req.user.role === 'admin' ? 'ADMIN' : 'USER',
    message: req.body.message,
    attachments: req.body.attachments
  });
  res.send(ticket);
});

const editMessage = catchAsync(async (req, res) => {
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) return res.status(httpStatus.NOT_FOUND).send({ message: 'Ticket not found' });
    
    const message = ticket.messages.id(req.params.messageId);
    if (!message) return res.status(httpStatus.NOT_FOUND).send({ message: 'Message not found' });
    
    message.message = req.body.message;
    await ticket.save();
    res.send(ticket);
});

const deleteMessage = catchAsync(async (req, res) => {
    const ticket = await Ticket.findById(req.params.id);
    if (!ticket) return res.status(httpStatus.NOT_FOUND).send({ message: 'Ticket not found' });
    
    ticket.messages.pull({ _id: req.params.messageId });
    await ticket.save();
    res.send(ticket);
});

export default {
  createTicket,
  getTickets,
  getTicketById,
  updateTicket,
  replyToTicket,
  editMessage,
  deleteMessage
};
</file>

<file path="src/controllers/watchlist.controller.js">
import Watchlist from '../models/Watchlist.js';
import catchAsync from '../utils/catchAsync.js';

// @desc    Get user watchlists
// @route   GET /api/watchlist
// @access  Private
const getWatchlists = catchAsync(async (req, res) => {
  let watchlists = await Watchlist.find({ user: req.user._id })
    .populate('signals')
    .sort({ createdAt: 1 });

  // Create default if none exist
  if (watchlists.length === 0) {
    const defaultList = await Watchlist.create({
      user: req.user._id,
      name: 'Watchlist 1',
      isDefault: true,
      signals: []
    });
    watchlists = [defaultList];
  }

  res.json(watchlists);
});

// @desc    Create new watchlist
// @route   POST /api/watchlist
// @access  Private
const createWatchlist = catchAsync(async (req, res) => {
  const { name } = req.body;

  if (!name) {
    res.status(400);
    throw new Error('Watchlist name is required');
  }

  const exists = await Watchlist.findOne({ user: req.user._id, name });
  if (exists) {
    res.status(400);
    throw new Error('Watchlist name already exists');
  }

  const watchlist = await Watchlist.create({
    user: req.user._id,
    name,
    signals: []
  });

  res.status(201).json(watchlist);
});

// @desc    Delete watchlist
// @route   DELETE /api/watchlist/:id
// @access  Private
const deleteWatchlist = catchAsync(async (req, res) => {
  const watchlist = await Watchlist.findOne({ _id: req.params.id, user: req.user._id });

  if (!watchlist) {
    res.status(404);
    throw new Error('Watchlist not found');
  }

  if (watchlist.isDefault) {
    res.status(400);
    throw new Error('Cannot delete default watchlist');
  }

  await watchlist.deleteOne();
  res.json({ message: 'Watchlist removed' });
});

// @desc    Toggle Signal in Watchlist
// @route   PATCH /api/watchlist/:id/toggle
// @access  Private
const toggleSignal = catchAsync(async (req, res) => {
  const { signalId } = req.body;
  const watchlist = await Watchlist.findOne({ _id: req.params.id, user: req.user._id });

  if (!watchlist) {
    res.status(404);
    throw new Error('Watchlist not found');
  }

  const index = watchlist.signals.indexOf(signalId);
  if (index === -1) {
    watchlist.signals.push(signalId);
  } else {
    watchlist.signals.splice(index, 1);
  }

  await watchlist.save();
  
  // Return populated signals for immediate UI update
  await watchlist.populate('signals');
  
  res.json(watchlist);
});

export {
  getWatchlists,
  createWatchlist,
  deleteWatchlist,
  toggleSignal
};
</file>

<file path="src/data/alltick_popular.js">
export const ALLTICK_POPULAR_SYMBOLS = [
    // Forex
    { symbol: 'EURUSD', name: 'Euro / US Dollar', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'GBPUSD', name: 'British Pound / US Dollar', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'USDJPY', name: 'US Dollar / Japanese Yen', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'AUDUSD', name: 'Australian Dollar / US Dollar', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'USDCAD', name: 'US Dollar / Canadian Dollar', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'USDCHF', name: 'US Dollar / Swiss Franc', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'NZDUSD', name: 'New Zealand Dollar / US Dollar', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'EURJPY', name: 'Euro / Japanese Yen', segment: 'CURRENCY', exchange: 'FOREX' },
    { symbol: 'GBPJPY', name: 'British Pound / Japanese Yen', segment: 'CURRENCY', exchange: 'FOREX' },
    // Commodities
    { symbol: 'XAUUSD', name: 'Gold / US Dollar', segment: 'COMMODITY', exchange: 'FOREX' },
    { symbol: 'XAGUSD', name: 'Silver / US Dollar', segment: 'COMMODITY', exchange: 'FOREX' },
    { symbol: 'USOIL', name: 'Crude Oil (WTI)', segment: 'COMMODITY', exchange: 'FOREX' },
    { symbol: 'UKOIL', name: 'Brent Oil', segment: 'COMMODITY', exchange: 'FOREX' },
    // Crypto
    { symbol: 'BTCUSD', name: 'Bitcoin / US Dollar', segment: 'CRYPTO', exchange: 'CRYPTO' },
    { symbol: 'ETHUSD', name: 'Ethereum / US Dollar', segment: 'CRYPTO', exchange: 'CRYPTO' },
    { symbol: 'LTCUSD', name: 'Litecoin / US Dollar', segment: 'CRYPTO', exchange: 'CRYPTO' },
    { symbol: 'XRPUSD', name: 'Ripple / US Dollar', segment: 'CRYPTO', exchange: 'CRYPTO' },
    { symbol: 'SOLUSD', name: 'Solana / US Dollar', segment: 'CRYPTO', exchange: 'CRYPTO' },
    // Indices (CFDs)
    { symbol: 'US30', name: 'Dow Jones 30', segment: 'INDICES', exchange: 'CFD' },
    { symbol: 'NAS100', name: 'Nasdaq 100', segment: 'INDICES', exchange: 'CFD' },
    { symbol: 'SPX500', name: 'S&P 500', segment: 'INDICES', exchange: 'CFD' },
    { symbol: 'GER30', name: 'DAX 30 (Germany)', segment: 'INDICES', exchange: 'CFD' },
    { symbol: 'USDKRW', name: 'US Dollar / Korean Won', segment: 'CURRENCY', exchange: 'FOREX' },
];
</file>

<file path="src/jobs/subscriptionCron.js">
import cron from 'node-cron';
import subscriptionService from '../services/subscription.service.js';
import notificationService from '../services/notification.service.js';
import logger from '../config/logger.js';

/**
 * Subscription Cron Job
 * Runs daily at 9:00 AM IST
 * - Sends pre-expiry reminders (3 days before expiry)
 * - Expires subscriptions and blocks users
 */
class SubscriptionCron {
  constructor() {
    this.isRunning = false;
  }

  /**
   * Start the cron job
   */
  start() {
    // Run every day at 9:00 AM IST (3:30 AM UTC)
    // Cron format: minute hour day month weekday
    cron.schedule('0 9 * * *', async () => {
      if (this.isRunning) {
        logger.warn('Subscription cron job already running, skipping this execution');
        return;
      }

      this.isRunning = true;
      logger.info('üïê Starting subscription cron job...');

      try {
        await this.checkPreExpiryReminders();
        await this.checkExpiredSubscriptions();
        logger.info('‚úÖ Subscription cron job completed successfully');
      } catch (error) {
        logger.error('‚ùå Subscription cron job failed:', error);
      } finally {
        this.isRunning = false;
      }
    }, {
      timezone: 'Asia/Kolkata'
    });

    logger.info('üìÖ Subscription cron job scheduled (Daily at 9:00 AM IST)');
  }

  /**
   * Check and send pre-expiry reminders (3 days before expiry)
   */
  async checkPreExpiryReminders() {
    try {
      logger.info('üìß Checking for subscriptions expiring in 3 days...');
      
      const expiringSubscriptions = await subscriptionService.getExpiringSubscriptions(3);
      
      if (expiringSubscriptions.length === 0) {
        logger.info('No subscriptions expiring in 3 days');
        return;
      }

      logger.info(`Found ${expiringSubscriptions.length} subscriptions expiring in 3 days`);

      for (const subscription of expiringSubscriptions) {
        try {
          const user = subscription.user;
          const daysLeft = Math.ceil(
            (new Date(subscription.endDate) - new Date()) / (1000 * 60 * 60 * 24)
          );

          // Send pre-expiry reminder
          await notificationService.sendPreExpiryReminder(user, subscription, daysLeft);

          // Mark reminder as sent
          await subscriptionService.markPreExpiryReminderSent(subscription._id);

          logger.info(`‚úì Pre-expiry reminder sent to ${user.email} (${subscription.plan.name})`);
        } catch (error) {
          logger.error(`Failed to send pre-expiry reminder for subscription ${subscription._id}:`, error);
        }
      }

      logger.info(`‚úÖ Sent ${expiringSubscriptions.length} pre-expiry reminders`);
    } catch (error) {
      logger.error('Error in checkPreExpiryReminders:', error);
      throw error;
    }
  }

  /**
   * Check and expire subscriptions that have passed their end date
   */
  async checkExpiredSubscriptions() {
    try {
      logger.info('üîí Checking for expired subscriptions...');
      
      const expiredSubscriptions = await subscriptionService.getExpiredSubscriptions();
      
      if (expiredSubscriptions.length === 0) {
        logger.info('No expired subscriptions found');
        return;
      }

      logger.info(`Found ${expiredSubscriptions.length} expired subscriptions`);

      for (const subscription of expiredSubscriptions) {
        try {
          const user = subscription.user;

          // Expire subscription and block user
          await subscriptionService.expireSubscription(subscription._id);

          // Send expiry notification
          await notificationService.sendExpiryNotification(user, subscription);

          logger.info(`‚úì Expired subscription and blocked user ${user.email} (${subscription.plan.name})`);
        } catch (error) {
          logger.error(`Failed to expire subscription ${subscription._id}:`, error);
        }
      }

      logger.info(`‚úÖ Expired ${expiredSubscriptions.length} subscriptions and blocked users`);
    } catch (error) {
      logger.error('Error in checkExpiredSubscriptions:', error);
      throw error;
    }
  }

  /**
   * Manual trigger for testing (call this from admin panel or script)
   */
  async runManually() {
    logger.info('üîß Manually triggering subscription cron job...');
    
    if (this.isRunning) {
      logger.warn('Subscription cron job already running');
      return { success: false, message: 'Job already running' };
    }

    this.isRunning = true;

    try {
      await this.checkPreExpiryReminders();
      await this.checkExpiredSubscriptions();
      
      this.isRunning = false;
      return { success: true, message: 'Subscription cron job completed successfully' };
    } catch (error) {
      this.isRunning = false;
      logger.error('Manual subscription cron job failed:', error);
      return { success: false, message: error.message };
    }
  }
}

export default new SubscriptionCron();
</file>

<file path="src/middleware/auth.js">
import jwt from 'jsonwebtoken';
import httpStatus from 'http-status';
import config from '../config/config.js';
import ApiError from '../utils/ApiError.js';
import User from '../models/User.js';

const auth = (requiredRoles = []) => async (req, res, next) => {
  try {
    // 1) Get token from header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      throw new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate');
    }

    // 2) Verify token
    const decoded = jwt.verify(token, config.jwt.secret);
    
    // 3) Check if user exists
    const user = await User.findById(decoded.sub);
    if (!user) {
      throw new ApiError(httpStatus.UNAUTHORIZED, 'User not found');
    }

    // 4) Check Single Session (Token Version)
    // If the user has a tokenVersion set (meaning they logged in on the new system), 
    // the incoming token MUST match it. This invalidates old/legacy tokens immediately.
    if (user.tokenVersion && decoded.v !== user.tokenVersion) {
        throw new ApiError(httpStatus.UNAUTHORIZED, 'Session expired. Logged in on another device.');
    }

    // 5) Check Email Verification
    if (!user.isEmailVerified) {
        throw new ApiError(httpStatus.FORBIDDEN, 'Email is not verified. Please verify your email to continue.');
    }

    // 6) Check Subscription Status (Block if Inactive/Blocked)
    if (user.status === 'Inactive' || user.status === 'Blocked') {
        throw new ApiError(httpStatus.FORBIDDEN, 'Your account is disabled or blocked. Please contact support.');
    }

    // 6) Check role
    if (requiredRoles.length && !requiredRoles.includes(user.role)) {
       throw new ApiError(httpStatus.FORBIDDEN, 'Forbidden');
    }

    req.user = user;
    next();
  } catch (err) {
    next(new ApiError(httpStatus.UNAUTHORIZED, 'Please authenticate'));
  }
};

export default auth;
</file>

<file path="src/middleware/metrics.js">
import metricsCollector from '../monitoring/metricsCollector.js';

export const metricsMiddleware = (req, res, next) => {
    const start = Date.now();

    res.on('finish', () => {
        const duration = Date.now() - start;
        metricsCollector.trackApiRequest(duration);
        
        if (res.statusCode === 429) {
            metricsCollector.track429();
        }
    });

    next();
};
</file>

<file path="src/middleware/optionalAuth.js">
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import User from '../models/User.js';

const optionalAuth = () => async (req, res, next) => {
  try {
    // 1) Get token from header
    const token = req.headers.authorization?.replace('Bearer ', '');
    
    if (!token) {
      return next(); // Guest user
    }

    // 2) Verify token
    try {
        const decoded = jwt.verify(token, config.jwt.secret);
        const user = await User.findById(decoded.sub);
        
        // If user found and valid, attach to req
        if (user) {
             // Optional: Check token version if you want strict session handling even for optional auth
             if (!user.tokenVersion || decoded.v === user.tokenVersion) {
                 req.user = user;
             }
        }
    } catch (err) {
        // Token exists but invalid/expired. 
        // Decide: Return 401 or treat as Guest? 
        // Usually if they SEND a token, they EXPECT to be logged in. So 401 is better than silent failure.
        // BUT for a "Public" page, maybe silent failure is okay? 
        // Let's go with: If token is bad, treat as Guest. The frontend can handle "session expired" logic if it cares.
        // actually for security/debugging, silent fail is annoying. 
        // sticking to: Treat as Guest if token invalid.
    }
    
    next();
  } catch (err) {
    next();
  }
};

export default optionalAuth;
</file>

<file path="src/middleware/subscription.middleware.js">
import subscriptionService from '../services/subscription.service.js';
import httpStatus from 'http-status';

/**
 * Middleware to check segment access
 * usage: router.get('/some-route', auth(), requireSegment('EQUITY'), controller)
 */
const requireSegment = (segmentCode) => async (req, res, next) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(httpStatus.UNAUTHORIZED).send({ message: 'Unauthorized' });
    }

    const hasAccess = await subscriptionService.checkAccess(userId, segmentCode.toUpperCase());

    if (!hasAccess) {
      return res.status(httpStatus.FORBIDDEN).send({ 
        message: `Access Denied. Active subscription for ${segmentCode} is required.` 
      });
    }

    next();
  } catch (error) {
    next(error);
  }
};

export default requireSegment;
</file>

<file path="src/middleware/upload.js">
import multer from 'multer';
import path from 'path';
import httpStatus from 'http-status';

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    let folder = 'uploads/avatars';
    if (file.fieldname === 'screenshot') folder = 'uploads/payments';
    if (file.fieldname === 'qrCode') folder = 'uploads/payments';
    // Ensure folder exists (fs.mkdirSync logic or assume pre-created)
    // For now assuming folder structure or letting multer handles relative. 
    // Ideally we should use fs to mkdir, but let's stick to simple relative path 
    // and rely on manual creation or app.js static serve.
    cb(null, folder);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const fileFilter = (req, file, cb) => {
  console.log('Multer Filter Check:', file.mimetype, file.originalname);
  // Allow all image types
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    console.error('Multer Rejected:', file.mimetype);
    cb(new Error('Unsupported file format: ' + file.mimetype), false);
  }
};

const upload = multer({ 
  storage: storage,
  limits: {
    fileSize: 1024 * 1024 * 5 // 5MB limit
  },
  fileFilter: fileFilter
});

export default upload;
</file>

<file path="src/middleware/validate.js">
import Joi from 'joi';
import ApiError from '../utils/ApiError.js';

const pick = (object, keys) => {
  return keys.reduce((obj, key) => {
    if (object && Object.prototype.hasOwnProperty.call(object, key)) {
      // eslint-disable-next-line no-param-reassign
      obj[key] = object[key];
    }
    return obj;
  }, {});
};

const validate = (schema) => (req, res, next) => {
  const validSchema = pick(schema, ['params', 'query', 'body']);
  const object = pick(req, Object.keys(validSchema));
  const { value, error } = Joi.compile(validSchema)
    .prefs({ errors: { label: 'key' }, abortEarly: false })
    .validate(object);

  if (error) {
    const errorMessage = error.details.map((details) => details.message).join(', ');
    return next(new ApiError(400, errorMessage)); // Using 400 directly
  }
  Object.assign(req, value);
  return next();
};

export default validate;
</file>

<file path="src/models/AdminPaymentDetails.js">
import mongoose from 'mongoose';

const adminPaymentDetailsSchema = new mongoose.Schema(
  {
    upiId: {
      type: String,
      trim: true,
      default: ''
    },
    qrCodeUrl: {
      type: String, // URL to uploaded image
      trim: true,
      default: ''
    },
    bankName: {
      type: String,
      trim: true,
      default: ''
    },
    accountNumber: {
      type: String,
      trim: true,
      default: ''
    },
    ifscCode: {
      type: String,
      trim: true,
      uppercase: true,
      default: ''
    },
    accountHolderName: {
      type: String,
      trim: true,
      default: ''
    },
    supportWhatsapp: {
      type: String,
      trim: true,
      default: '' // Format: 919999999999
    }
  },
  {
    timestamps: true,
    capped: { size: 1024, max: 1 } // Singleton: Only one record needed
  }
);

const AdminPaymentDetails = mongoose.model('AdminPaymentDetails', adminPaymentDetailsSchema);

export default AdminPaymentDetails;
</file>

<file path="src/models/AdminSetting.js">
import mongoose from 'mongoose';

const adminSettingSchema = new mongoose.Schema(
  {
    demo_validity_days: {
      type: Number,
      default: 1,
      min: 1
    },
    premium_validity_days: {
      type: Number,
      default: 30,
      min: 1
    },
    // Can be extended for other global configs
  },
  {
    timestamps: true,
    capped: { size: 1024, max: 1 } // Ensure singleton-like behavior (optional, but good for settings)
  }
);

const AdminSetting = mongoose.model('AdminSetting', adminSettingSchema);

export default AdminSetting;
</file>

<file path="src/models/Announcement.js">
import mongoose from 'mongoose';

const announcementSchema = new mongoose.Schema(
  {
    title: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
    type: {
      type: String,
      enum: ['SYSTEM', 'URGENT', 'UPDATE', 'EVENT', 'NEWS', 'SIGNAL', 'ECONOMIC', 'REMINDER'],
      default: 'NEWS',
    },
    priority: {
      type: String,
      enum: ['LOW', 'NORMAL', 'HIGH', 'CRITICAL'],
      default: 'NORMAL',
    },
    targetAudience: {
      role: { type: String, enum: ['all', 'user', 'sub-broker'], default: 'all' },
      planValues: [String], // e.g. ['pro', 'enterprise']
      segments: [String],   // e.g. ['EQUITY_INTRA', 'NIFTY_OPT']
    },
    startDate: {
      type: Date,
      default: Date.now,
    },
    endDate: {
      type: Date,
    },
    isActive: {
       type: Boolean,
       default: true,
    },
    isNotificationSent: {
        type: Boolean,
        default: false
    }
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

// Virtual for status
announcementSchema.virtual('status').get(function () {
  if (!this.isActive) return 'Disabled';
  const now = new Date();
  if (this.startDate > now) return 'Scheduled';
  if (this.endDate && this.endDate < now) return 'Expired';
  return 'Active';
});

const Announcement = mongoose.model('Announcement', announcementSchema);

export default Announcement;
</file>

<file path="src/models/Commission.js">
import mongoose from 'mongoose';

const commissionSchema = new mongoose.Schema(
  {
    subBroker: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    user: {
      type: mongoose.Schema.Types.ObjectId, // The user who made the purchase
      ref: 'User',
      required: true,
    },
    transaction: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Transaction',
      required: true,
    },
    amount: {
      type: Number,
      required: true,
    },
    percentage: {
      type: Number, // Commission percentage at that time
      required: true,
    },
    status: {
      type: String,
      enum: ['PENDING', 'PAID'],
      default: 'PENDING',
    },
  },
  {
    timestamps: true,
  }
);

const Commission = mongoose.model('Commission', commissionSchema);

export default Commission;
</file>

<file path="src/models/EconomicEvent.js">
import mongoose from 'mongoose';

const economicEventSchema = new mongoose.Schema(
  {
    eventId: { type: String, unique: true, index: true },
    date: { type: Date, required: true, index: true },
    country: { type: String, index: true }, // e.g., 'US', 'EU'
    event: { type: String, required: true },
    currency: { type: String }, // e.g., 'USD'
    impact: { type: String, enum: ['Low', 'Medium', 'High', 'None'], default: 'None' },
    actual: { type: String },
    forecast: { type: String },
    previous: { type: String },
    unit: { type: String },
    isAlertSent: { type: Boolean, default: false }
  },
  { timestamps: true }
);

const EconomicEvent = mongoose.model('EconomicEvent', economicEventSchema);

export default EconomicEvent;
</file>

<file path="src/models/FAQ.js">
import mongoose from 'mongoose';

const faqSchema = new mongoose.Schema(
  {
    question: { type: String, required: true },
    answer: { type: String, required: true },
    category: { 
        type: String, 
        default: 'General',
        enum: ['General', 'Account', 'Billing', 'Technical', 'Trading']
    },
    isActive: { type: Boolean, default: true },
    order: { type: Number, default: 0 }
  },
  { timestamps: true }
);

const FAQ = mongoose.model('FAQ', faqSchema);

export default FAQ;
</file>

<file path="src/models/Lead.js">
import mongoose from 'mongoose';

const leadSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
    },
    isEmailVerified: {
      type: Boolean,
      default: false,
    },
    phone: {
      type: String,
      required: true,
      trim: true,
    },
    password: { // Temp storage for auto-creation
      type: String,
      required: true,
      minlength: 6,
    },
    status: {
      type: String,
      enum: ['PENDING', 'CONTACTED', 'CONVERTED', 'REJECTED'],
      default: 'PENDING',
    },
    notes: {
      type: String,
    },
    city: { type: String },
    segment: { type: String },
    plan: { type: String },
    paymentScreenshot: { type: String }, // Path to file
    ipAddress: { type: String },
  },
  {
    timestamps: true,
  }
);

const Lead = mongoose.model('Lead', leadSchema);

export default Lead;
</file>

<file path="src/models/MasterSegment.js">
import mongoose from 'mongoose';

const masterSegmentSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true, // e.g., "Equity Intraday"
    },
    code: {
      type: String,
      required: true,
      unique: true,
      uppercase: true, // e.g., "EQUITY", "FNO"
    },
    isActive: {
      type: Boolean,
      default: true
    }
  },
  {
    timestamps: true,
  }
);

const MasterSegment = mongoose.model('MasterSegment', masterSegmentSchema);

export default MasterSegment;
</file>

<file path="src/models/MasterSymbol.js">
import mongoose from 'mongoose';

const masterSymbolSchema = new mongoose.Schema(
  {
    symbol: {
      type: String,
      required: true,
      unique: true,
      uppercase: true, // e.g., "NIFTY 50", "RELIANCE"
    },
    name: {
        type: String,
        required: true, // e.g., "Nifty 50 Index"
    },
    segment: {
      type: String, 
      required: true, // e.g., "FNO", "EQUITY" (Matches MasterSegment.code)
    },
    exchange: {
        type: String,
        default: 'NSE'
    },
    lotSize: {
        type: Number,
        default: 1
    },
    tickSize: {
        type: Number,
        default: 0.05
    },
    isActive: {
      type: Boolean,
      default: true
    },
    instrumentToken: {
        type: String // Kite Instrument Token
    },
    isWatchlist: {
        type: Boolean,
        default: false
    }
  },
  {
    timestamps: true,
  }
);

const MasterSymbol = mongoose.model('MasterSymbol', masterSymbolSchema);

export default MasterSymbol;
</file>

<file path="src/models/Notification.js">
import mongoose from 'mongoose';

const notificationSchema = mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    title: {
      type: String,
      required: true,
    },
    message: {
      type: String,
      required: true,
    },
    type: {
      type: String,
      enum: ['SYSTEM', 'SIGNAL', 'PAYMENT', 'TICKET', 'ANNOUNCEMENT'],
      default: 'SYSTEM',
    },
    isRead: {
      type: Boolean,
      default: false,
    },
    data: {
      type: Object, // Optional payload (e.g. signalId, ticketId)
      default: {}
    },
    link: {
      type: String, // Optional redirect URL
    },
  },
  {
    timestamps: true,
  }
);

const Notification = mongoose.model('Notification', notificationSchema);

export default Notification;
</file>

<file path="src/models/Page.js">
import mongoose from 'mongoose';

const pageSchema = new mongoose.Schema(
  {
    slug: { 
        type: String, 
        required: true, 
        unique: true, 
        enum: ['terms', 'privacy', 'refund', 'about'],
        index: true 
    },
    title: { type: String, required: true },
    content: { type: String, default: '' }, // Markdown or HTML content
    isActive: { type: Boolean, default: true }
  },
  { timestamps: true }
);

const Page = mongoose.model('Page', pageSchema);

export default Page;
</file>

<file path="src/models/Plan.js">
import mongoose from 'mongoose';

const planSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    description: {
      type: String,
    },
    segment: {
      type: String,
      enum: ['EQUITY', 'FNO', 'COMMODITY', 'CURRENCY'],
      // required: true, // Made optional to support multi-segment plans
    },
    permissions: [{
      type: String,
      enum: [
        'EQUITY_INTRA', 
        'EQUITY_DELIVERY', 
        'NIFTY_OPT', 
        'BANKNIFTY_OPT', 
        'FINNIFTY_OPT', 
        'STOCK_OPT', 
        'MCX_FUT', 
        'CURRENCY', 
        'CRYPTO',
        'BTST',
        'HERO_ZERO'
      ]
    }],
    price: {
      type: Number,
      required: true,
    },
    durationDays: {
      type: Number,
      required: true, // e.g., 30, 90, 365
    },
    features: [
      {
        type: String,
      },
    ],
    isActive: {
      type: Boolean,
      default: true,
    },
    isDemo: {
      type: Boolean,
      default: false,
    },
  },
  {
    timestamps: true,
  }
);

const Plan = mongoose.model('Plan', planSchema);

export default Plan;
</file>

<file path="src/models/Segment.js">
import mongoose from 'mongoose';

const segmentSchema = new mongoose.Schema(
  {
    segment_code: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      uppercase: true,
      enum: ['EQUITY', 'CRYPTO', 'COMMODITY', 'FOREX', 'OPTIONS']
    },
    name: {
      type: String,
      required: true,
      trim: true
    },
    base_price: {
      type: Number,
      default: 25000,
      min: 0
    },
    is_active: {
      type: Boolean,
      default: true
    }
  },
  {
    timestamps: true
  }
);

// Indexes for fast lookup
segmentSchema.index({ segment_code: 1 });
segmentSchema.index({ is_active: 1 });

const Segment = mongoose.model('Segment', segmentSchema);

export default Segment;
</file>

<file path="src/models/Setting.js">
import mongoose from 'mongoose';

const settingSchema = mongoose.Schema(
  {
    key: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },
    value: {
      type: mongoose.Schema.Types.Mixed,
      required: true,
    },
    description: {
      type: String,
    },
  },
  {
    timestamps: true,
  }
);

// Plugin removed as it does not exist
// settingSchema.plugin(toJSON);


const Setting = mongoose.model('Setting', settingSchema);

export default Setting;
</file>

<file path="src/models/Signal.js">
import mongoose from 'mongoose';

const signalSchema = new mongoose.Schema(
  {
    symbol: {
      type: String,
      required: true,
      trim: true,
      uppercase: true,
    },
    segment: {
      type: String,
      required: true,
    },
    category: {
      type: String,
      required: true, 
      enum: [
        'EQUITY_INTRA', 
        'EQUITY_DELIVERY', 
        'NIFTY_OPT', 
        'BANKNIFTY_OPT', 
        'FINNIFTY_OPT', 
        'STOCK_OPT', 
        'MCX_FUT', 
        'CURRENCY', 
        'CRYPTO',
        'BTST',
        'HERO_ZERO'
      ]
    },
    type: {
      type: String,
      enum: ['BUY', 'SELL'],
      required: true,
    },
    entryPrice: {
      type: Number, // Frontend expects single value 'entry'
      required: true,
    },
    stopLoss: {
      type: Number,
      required: true,
    },
    targets: {
      target1: { type: Number, required: true },
      target2: { type: Number },
      target3: { type: Number },
    },
    status: {
      type: String,
      enum: ['Active', 'Target Hit', 'Stoploss Hit', 'Closed'], // Matched Frontend Mock
      default: 'Active',
    },
    report: {
        result: { type: Number }, // P/L Points
        closedAt: { type: Date },
        closedPrice: { type: Number }
    },
    isFree: {
      type: Boolean,
      default: false,
    },
    notes: {
      type: String,
    },
    attachments: [
      {
        type: String, // URL
      },
    ],
    // For admin audit
    createdBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User',
        required: false // Allow automated signals from 'system' to be null
    },
    // Strategy Reference
    strategyId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Strategy',
        required: false
    },
    strategyName: {
        type: String,
        required: false
    },
    timeframe: {
        type: String,
        required: false
    },
    metrics: {
        sma: Number,
        ema: Number,
        supertrend: Number,
        rsi: Number,
        psar: Number
    }
  },
  {
    timestamps: true,
  }
);

const Signal = mongoose.model('Signal', signalSchema);

export default Signal;
</file>

<file path="src/models/Strategy.js">
import mongoose from 'mongoose';

const strategySchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    name: {
      type: String,
      required: true,
      trim: true,
    },
    symbol: {
      type: String,
      required: true,
      uppercase: true,
    },
    timeframe: {
      type: String,
      required: true, // e.g., '1m', '5m', '1h'
    },
    segment: {
      type: String,
      enum: ['EQUITY', 'FNO', 'COMMODITY', 'CURRENCY', 'GLOBAL'],
      required: true,
      default: 'EQUITY'
    },
    // For Multi-Symbol Strategies
    symbols: [{ type: String, uppercase: true }], 
    
    candleType: {
        type: String,
        enum: ['Standard', 'HeikinAshi'],
        default: 'Standard'
    },
    
    risk: {
        riskRewardRatio: { type: Number, default: 2 }, // 1:2
        stopLossType: { type: String, enum: ['Fixed%', 'Indicator', 'Swing'], default: 'Fixed%' },
        stopLossValue: { type: Number, default: 1 } // 1% or Indicator Period
    },

    stats: {
        totalSignals: { type: Number, default: 0 },
        successCount: { type: Number, default: 0 },
        lastSignalAt: { type: Date }
    },
    // Dynamic Rules Engine Structure
    // Example: { 
    //   condition: 'AND', 
    //   rules: [
    //     { indicator: 'RSI', period: 14, operator: '<', value: 30 },
    //     { indicator: 'SMA', period: 50, operator: '>', value: 'SMA', valuePeriod: 200 }
    //   ] 
    // }
    logic: {
      condition: {
        type: String,
        enum: ['AND', 'OR'],
        default: 'AND'
      },
      rules: [{
        indicator: { type: String, required: true }, // RSI, SMA, EMA, MACD, Supertrend, PSAR
        params: { type: Map, of: Number }, // { period: 14, multiplier: 1.5 }
        operator: { type: String, enum: ['>', '<', '>=', '<=', '==', 'CROSS_ABOVE', 'CROSS_BELOW'], required: true },
        comparisonType: { type: String, enum: ['VALUE', 'INDICATOR'], default: 'VALUE' },
        value: { type: mongoose.Schema.Types.Mixed, required: true }, // 30 or { indicator: 'SMA', params: {...} }
      }]
    },
    action: {
      type: String,
      enum: ['BUY', 'SELL', 'ALERT'], // ALERT = Both/Signaling
      default: 'ALERT'
    },
    status: {
      type: String,
      enum: ['Active', 'Paused', 'Archived'],
      default: 'Paused'
    },
    isSystem: {
      type: Boolean,
      default: false
    },
    isDefault: {
      type: Boolean,
      default: false
    },
  },
  {
    timestamps: true,
  }
);

const Strategy = mongoose.model('Strategy', strategySchema);

export default Strategy;
</file>

<file path="src/models/SubBroker.js">
import mongoose from 'mongoose';
import validator from 'validator';

const subBrokerSchema = mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
      validate(value) {
        if (!validator.isEmail(value)) {
          throw new Error('Invalid email');
        }
      },
    },
    phone: {
      type: String,
      required: true,
      trim: true,
    },
    company: {
      type: String,
      trim: true,
    },
    location: {
      type: String,
      trim: true,
    },
    brokerId: {
        type: String,
        required: true,
        unique: true,
        trim: true,
        index: true
    },
    telegramId: String,
    commission: {
        type: {
            type: String,
            enum: ['PERCENTAGE', 'FIXED'],
            default: 'PERCENTAGE'
        },
        value: {
            type: Number,
            required: true,
            default: 20
        }
    },
    status: {
        type: String,
        enum: ['Active', 'Blocked'],
        default: 'Active'
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    agreementDoc: String, // URL/Path to PDF
  },
  {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
  }
);

// Virtual for total clients (Using User model later if needed, for now placeholders)
subBrokerSchema.virtual('totalClients').get(function() {
    return 0; // Placeholder, real implementation requires aggregation
});

// Virtual for total revenue
subBrokerSchema.virtual('totalRevenue').get(function() {
    return 0; // Placeholder
});

/**
 * Check if email is taken
 * @param {string} email - The user's email
 * @param {ObjectId} [excludeUserId] - The id of the user to be excluded
 * @returns {Promise<boolean>}
 */
subBrokerSchema.statics.isEmailTaken = async function (email, excludeId) {
  const user = await this.findOne({ email, _id: { $ne: excludeId } });
  return !!user;
};

const SubBroker = mongoose.model('SubBroker', subBrokerSchema);

export default SubBroker;
</file>

<file path="src/models/Subscription.js">
import mongoose from 'mongoose';

const subscriptionSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    plan: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Plan',
      required: true,
    },
    status: {
      type: String,
      enum: ['active', 'expired', 'canceled'],
      default: 'active',
    },
    startDate: {
      type: Date,
      default: Date.now,
    },
    endDate: {
      type: Date,
      required: true,
    },
    preExpiryReminderSent: {
      type: Boolean,
      default: false,
    },
    expiryNotificationSent: {
      type: Boolean,
      default: false,
    },
    transaction: {
      type: mongoose.Schema.Types.ObjectId, // Link to Transaction
      ref: 'Transaction'
    },
    // paymentId deprecated, use transaction reference
  },
  {
    timestamps: true,
  }
);

const Subscription = mongoose.model('Subscription', subscriptionSchema);

export default Subscription;
</file>

<file path="src/models/Ticket.js">
import mongoose from 'mongoose';

const ticketSchema = new mongoose.Schema(
  {
    ticketId: {
      type: String,
      required: true,
      unique: true,
    },
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    subject: {
      type: String,
      required: true,
    },
    category: {
      type: String,
      enum: ['General', 'Technical', 'Billing', 'Feature Request', 'Other', 'PAYMENT', 'ACCOUNT', 'TECHNICAL', 'OTHER'], 
      default: 'General',
    },
    priority: {
      type: String,
      enum: ['low', 'medium', 'high', 'urgent', 'LOW', 'MEDIUM', 'HIGH'],
      default: 'medium',
    },
    status: {
      type: String,
      enum: ['OPEN', 'IN_PROGRESS', 'RESOLVED', 'CLOSED'],
      default: 'OPEN',
    },
    messages: [
      {
        sender: { type: String, enum: ['USER', 'ADMIN'], required: true },
        message: { type: String, required: true },
        attachments: [String],
        timestamp: { type: Date, default: Date.now },
      },
    ],
  },
  {
    timestamps: true,
  }
);

const Ticket = mongoose.model('Ticket', ticketSchema);

export default Ticket;
</file>

<file path="src/models/Transaction.js">
import mongoose from 'mongoose';

const transactionSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
    },
    amount: {
      type: Number,
      required: true,
    },
    currency: {
      type: String,
      default: 'INR',
    },
    type: {
      type: String,
      enum: ['CREDIT', 'DEBIT'],
      required: true,
    },
    purpose: {
      type: String,
      enum: ['SUBSCRIPTION', 'WALLET_TOPUP', 'WITHDRAWAL'],
      required: true,
    },
    status: {
      type: String,
      enum: ['pending', 'success', 'failed'],
      default: 'pending',
    },
    paymentGateway: {
      type: String,
      enum: ['RAZORPAY', 'STRIPE', 'MANUAL', 'MANUAL_ADMIN'],
    },
    gatewayTransactionId: {
      type: String,
    },
    metadata: {
      type: Map,
      of: mongoose.Schema.Types.Mixed,
    },
  },
  {
    timestamps: true,
  }
);

const Transaction = mongoose.model('Transaction', transactionSchema);

export default Transaction;
</file>

<file path="src/models/User.js">
import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';

const userSchema = new mongoose.Schema(
  {
    name: {
      type: String,
      required: true,
      trim: true,
    },
    email: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      lowercase: true,
    },
    password: {
      type: String,
      required: true,
      minlength: 6,
      private: true, // Custom option to indicate this shoudn't be returned by default
    },
    role: {
      type: String,
      enum: ['user', 'admin', 'sub-broker'],
      default: 'user',
    },
    phone: {
      type: String,
      trim: true,
      unique: true,
      sparse: true,
    },
    kyc: {
        status: { type: String, enum: ['Pending', 'Verified', 'Rejected'], default: 'Pending' }, // Cap matched
        panCard: { type: String },
        aadhaarCard: { type: String }
    },
    profile: {
        avatar: { type: String },
        address: { type: String },
        city: { type: String },
        state: { type: String }
    },
    referral: {
        code: { type: String, unique: true, sparse: true },
        referredBy: { type: mongoose.Schema.Types.ObjectId, ref: 'User' }
    },
    subBrokerId: { 
        type: mongoose.Schema.Types.ObjectId, 
        ref: 'User' 
    },
    walletBalance: {
        type: Number,
        default: 0
    },
    status: {
        type: String,
        enum: ['Active', 'Inactive', 'Suspended', 'Blocked', 'Liquidated'], // Updated to support new actions
        default: 'Active'
    },
    // Signal Access Overrides
    signalAccess: [{
        category: { type: String, required: true }, // e.g. 'NIFTY_OPT', 'BANKNIFTY_OPT', 'STOCKS_INTRA', 'COMMODITY', 'FOREX'
        access: { type: Boolean, default: true },
        expiry: { type: Date }
    }],
    // Trading Stats (Mock/Snapshot)
    clientId: { type: String, unique: true, sparse: true }, // e.g. MS-1001
    equity: { type: Number, default: 0 },
    marginUsed: { type: Number, default: 0 },
    pnl: { type: Number, default: 0 },
    fcmTokens: [String],
    isPhoneVerified: {
      type: Boolean,
      default: false,
    },
    isEmailVerified: {
      type: Boolean,
      default: false,
    },
    isWhatsAppEnabled: {
      type: Boolean,
      default: true,
    },
    isNotificationEnabled: {
      type: Boolean,
      default: true,
    },
    isBlocked: { // Keeping for internal logic, but relying on status mostly
      type: Boolean,
      default: false
    },
    // Leaving legacy subscription field for now but moving to dedicated Subscription model
    subscription: {
      plan: {
        type: String,
        default: 'free',
      },
      expiresAt: Date,
    }, // Deprecated in favor of 'Subscription' collection
    // Single Session & IP Tracking
    tokenVersion: {
      type: Number,
      default: 0
    },
    lastLoginIp: {
      type: String,
      default: null
    },
    currentDeviceId: {
      type: String,
      default: null
    }
  },
  {
    timestamps: true,
  }
);

// Encrypt password using bcrypt
userSchema.pre('save', async function () {
  if (!this.isModified('password')) {
    return;
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
});

// Match user entered password to hashed password in database
userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

const User = mongoose.model('User', userSchema);

export default User;
</file>

<file path="src/models/UserSubscription.js">
import mongoose from 'mongoose';

const userSubscriptionSchema = new mongoose.Schema(
  {
    user_id: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      required: true,
      index: true
    },
    segments: [{
      type: String,
      enum: ['EQUITY', 'CRYPTO', 'COMMODITY', 'FOREX', 'OPTIONS'],
      required: true
    }],
    total_amount: {
      type: Number,
      required: true,
      min: 0
    },
    start_date: {
      type: Date,
      default: Date.now,
      required: true
    },
    end_date: {
      type: Date,
      required: true,
      index: true // Key for expiration checks
    },
    plan_type: {
      type: String,
      enum: ['demo', 'premium'],
      required: true
    },
    status: {
      type: String,
      enum: ['active', 'expired', 'cancelled', 'pending'],
      default: 'active',
      index: true
    },
    is_active: {
      type: Boolean,
      default: true
    },
    // Payment Verification Fields
    payment_proof: {
      type: String, // Path to screenshot
      default: null
    },
    transaction_id: {
      type: String,
      default: null
    },
    admin_note: {
      type: String,
      default: null
    }
  },
  {
    timestamps: true
  }
);

// Compound index for frequent access checks: User + Status + Date
userSubscriptionSchema.index({ user_id: 1, status: 1, end_date: 1 });

const UserSubscription = mongoose.model('UserSubscription', userSubscriptionSchema);

export default UserSubscription;
</file>

<file path="src/models/Watchlist.js">
import mongoose from 'mongoose';

const watchlistSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: true,
    trim: true,
    default: 'Watchlist 1'
  },
  signals: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Signal'
  }],
  isDefault: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// Ensure a user can't have duplicate watchlist names
watchlistSchema.index({ user: 1, name: 1 }, { unique: true });

const Watchlist = mongoose.model('Watchlist', watchlistSchema);

export default Watchlist;
</file>

<file path="src/monitoring/alertManager.js">
import logger from '../config/logger.js';

class AlertManager {
    constructor() {
        this.alerts = [];
    }

    /**
     * Trigger an alert
     * @param {string} severity - 'INFO' | 'WARNING' | 'CRITICAL'
     * @param {string} message 
     * @param {Object} metadata 
     */
    trigger(severity, message, metadata = {}) {
        const alert = {
            id: Date.now(),
            timestamp: new Date().toISOString(),
            severity,
            message,
            metadata
        };

        this.alerts.push(alert);
        if (this.alerts.length > 100) this.alerts.shift();

        this._dispatch(alert);
    }

    _dispatch(alert) {
        // Log to Console
        if (alert.severity === 'CRITICAL') {
            logger.error(`[ALERT] ${alert.message}`, alert.metadata);
            // TODO: Integrations (Slack/Email) would go here
        } else {
            logger.warn(`[ALERT] ${alert.message}`, alert.metadata);
        }
    }

    getHistory() {
        return this.alerts;
    }
}

export default new AlertManager();
</file>

<file path="src/monitoring/metricsCollector.js">
import logger from '../config/logger.js';

class MetricsCollector {
    constructor() {
        this.metrics = {
            api: {
                requests_per_minute: 0,
                errors_429: 0,
                latency_sum: 0,
                latency_count: 0
            },
            cache: {
                hits: 0,
                misses: 0,
                keys: 0
            },
            websocket: {
                connections: 0,
                messages_sent_sec: 0,
                queue_length: 0
            },
            system: {
                memory_usage_mb: 0,
                uptime: 0
            }
        };

        // Rotation History (Last 60 mins)
        this.history = [];
        
        // Reset Counters every minute
        setInterval(() => this.rotateMetrics(), 60000);
        
        // Reset Rate Counters every second (for "per second" metrics)
        setInterval(() => {
            this.metrics.websocket.messages_sent_sec = 0;
        }, 1000);
    }

    // --- API Hook ---
    trackApiRequest(durationMs) {
        this.metrics.api.requests_per_minute++;
        this.metrics.api.latency_sum += durationMs;
        this.metrics.api.latency_count++;
    }

    track429() {
        this.metrics.api.errors_429++;
    }

    // --- Cache Hook ---
    trackCache(hit) {
        if (hit) this.metrics.cache.hits++;
        else this.metrics.cache.misses++;
    }

    // --- WS Hook ---
    updateWsConnections(count) {
        this.metrics.websocket.connections = count;
    }

    trackWsMessage() {
        this.metrics.websocket.messages_sent_sec++;
    }

    updateQueueLength(len) {
        this.metrics.websocket.queue_length = len;
    }

    // --- System ---
    getSnapshot() {
        const mem = process.memoryUsage();
        this.metrics.system.memory_usage_mb = Math.round(mem.heapUsed / 1024 / 1024);
        this.metrics.system.uptime = process.uptime();
        
        // Calculated/Derived
        const cacheTotal = this.metrics.cache.hits + this.metrics.cache.misses;
        const cacheHitRate = cacheTotal > 0 ? (this.metrics.cache.hits / cacheTotal) * 100 : 0;
        
        const avgLatency = this.metrics.api.latency_count > 0 
            ? Math.round(this.metrics.api.latency_sum / this.metrics.api.latency_count) 
            : 0;

        return {
            timestamp: Date.now(),
            ...this.metrics,
            derived: {
                cache_hit_rate: parseFloat(cacheHitRate.toFixed(1)),
                avg_api_latency: avgLatency
            }
        };
    }

    rotateMetrics() {
        const snapshot = this.getSnapshot();
        
        // Check Alerts (Simple Hook)
        this._checkAlerts(snapshot);

        // Store History
        this.history.push(snapshot);
        if (this.history.length > 60) this.history.shift();

        // Reset Counters
        this.metrics.api.requests_per_minute = 0;
        this.metrics.api.errors_429 = 0;
        this.metrics.api.latency_sum = 0;
        this.metrics.api.latency_count = 0;
        // Cache misses/hits accumulate or reset? Let's accumulate for lifetime or reset?
        // Let's reset to track "Hit Rate Per Minute"
        this.metrics.cache.hits = 0;
        this.metrics.cache.misses = 0;
    }

    _checkAlerts(data) {
        const { api, derived, websocket } = data;
        
        // 1. 429 Errors
        if (api.errors_429 > 0) {
            logger.error(`[ALERT] CRITICAL: ${api.errors_429} 429 Errors detected in last minute!`);
        }

        // 2. Cache Hit Rate
        if (derived.cache_hit_rate < 50 && (api.requests_per_minute > 10)) {
            logger.warn(`[ALERT] WARNING: Cache Hit Rate Low: ${derived.cache_hit_rate}%`);
        }

        // 3. Queue Length
        if (websocket.queue_length > 20) {
            logger.warn(`[ALERT] WARNING: Request Queue Length High: ${websocket.queue_length}`);
        }
    }
}

export default new MetricsCollector();
</file>

<file path="src/routes/admin.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import adminController from '../controllers/admin.controller.js';

import validate from '../middleware/validate.js';
import adminValidation from '../validations/admin.validation.js';

const router = express.Router();

// Protect all routes: Must be Logged In AND have 'admin' role
router.use(auth(['admin']));

router
  .route('/users')
  .get(adminController.getUsers)
  .post(validate(adminValidation.createUser), adminController.createUser);

router
  .route('/users/:userId/signals')
  .patch(adminController.updateSignalAccess);

router
  .route('/users/:userId')
  .get(adminController.getUser)
  .patch(validate(adminValidation.updateUser), adminController.updateUser)
  .delete(adminController.deleteUser);

router.patch('/users/:userId/block', adminController.blockUser);
router.patch('/users/:userId/liquidate', adminController.liquidateUser);

router
  .route('/system/health')
  .get(adminController.getSystemHealth);

router
  .route('/strategy/status')
  .get(adminController.getStrategyStatus);

router.post('/broadcast', adminController.broadcastMessage);

export default router;
</file>

<file path="src/routes/analytics.route.js">
import express from 'express';
import analyticsController from '../controllers/analytics.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

router.route('/')
    .get(auth('admin'), analyticsController.getAnalytics);

router.route('/export')
    .get(auth('admin'), analyticsController.exportAnalytics);

export default router;
</file>

<file path="src/routes/announcement.route.js">
import express from 'express';
import announcementController from '../controllers/announcement.controller.js';

const router = express.Router();

router
  .route('/export')
  .get(announcementController.exportAnnouncements);

router
  .route('/')
  .post(announcementController.createAnnouncement)
  .get(announcementController.getAnnouncements);

router
  .route('/:announcementId')
  .get(announcementController.getAnnouncement)
  .patch(announcementController.updateAnnouncement)
  .delete(announcementController.deleteAnnouncement);

export default router;
</file>

<file path="src/routes/auth.route.js">
import express from 'express';
import validate from '../middleware/validate.js';
import authValidation from '../validations/auth.validation.js';
import authController from '../controllers/auth.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

router.post('/register', validate(authValidation.register), authController.register);
router.post('/login', validate(authValidation.login), authController.login);
router.post('/send-otp', validate(authValidation.sendOtp), authController.sendOtp);
router.post('/verify-otp', validate(authValidation.verifyOtp), authController.verifyOtp);

// Authenticated Routes
router.use(auth()); // All routes below require authentication

import upload from '../middleware/upload.js';

router.route('/me')
    .get(authController.getMe)
    .patch(upload.single('avatar'), validate(authValidation.updateProfile), authController.updateMe);

router.post('/me/kyc', validate(authValidation.updateKyc), authController.updateKyc);
router.post('/logout', authController.logout);

export default router;
</file>

<file path="src/routes/bot.route.js">
import express from 'express';
import validate from '../middleware/validate.js';
import botController from '../controllers/bot.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

router
  .route('/status')
  .get(auth(), botController.getStatus); // Any logged in user

router
  .route('/toggle')
  .post(auth(['admin']), botController.toggleBot); // Only admin

export default router;
</file>

<file path="src/routes/cms.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import cmsController from '../controllers/cms.controller.js';

const router = express.Router();

// Pages (Public Read, Admin Write)
router
  .route('/pages/:slug')
  .get(cmsController.getPage)
  .post(auth(['admin']), cmsController.updatePage);

// FAQs (Public Read, Admin Write)
router
  .route('/faqs')
  .get(cmsController.getFAQs)
  .post(auth(['admin']), cmsController.createFAQ);

router
  .route('/faqs/:id')
  .patch(auth(['admin']), cmsController.updateFAQ)
  .delete(auth(['admin']), cmsController.deleteFAQ);

export default router;
</file>

<file path="src/routes/dashboard.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import dashboardController from '../controllers/dashboard.controller.js';

const router = express.Router();

router.use(auth());

// User Routes
router.post('/tickets', dashboardController.createTicket);
router.get('/tickets', dashboardController.getMyTickets);
router.post('/tickets/:ticketId/reply', dashboardController.replyTicket);

// Admin Routes (Would normally be under /admin/...)
// But since we are creating a unified module, let's keep it here or separate?
// The task says "Implement specific APIs for Admin Dashboard Stats".
// I'll put specific admin routes here protected by auth(['admin'])

router.get('/stats', auth(['admin']), dashboardController.getStats);
router.get('/admin/tickets', auth(['admin']), dashboardController.getAllTickets);

export default router;
</file>

<file path="src/routes/economic.route.js">
import express from 'express';
import economicController from '../controllers/economic.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

router
  .route('/')
  .get(auth(), economicController.getCalendar); // Using generic auth (login required) but no specific rights
  // OR just .get(economicController.getCalendar); if public


export default router;
</file>

<file path="src/routes/health.route.js">
import express from 'express';
import healthController from '../controllers/health.controller.js';

const router = express.Router();

router.get('/', healthController.getSystemHealth);

export default router;
</file>

<file path="src/routes/index.js">
import express from 'express';
import authRoute from './auth.route.js';
import strategyRoute from './strategy.route.js';
import adminRoute from './admin.route.js';
import planRoute from './plan.route.js';
import segmentRoute from './segment.route.js';
import subscriptionRoute from './subscription.route.js';
import paymentRoute from './payment.route.js';
import signalRoute from './signal.route.js';
import dashboardRoute from './dashboard.route.js';
import subBrokerRoute from './subBroker.route.js';
import settingRoute from './setting.route.js';
import marketRoute from './market.route.js';
import ticketRoute from './ticket.route.js';
import analyticsRoute from './analytics.route.js';
import announcementRoute from './announcement.route.js';
import economicRoute from './economic.route.js';
import cmsRoute from './cms.route.js';

import healthRoute from './health.route.js';
import notificationRoute from './notification.route.js';
import searchRoute from './search.route.js';
import leadRoute from './lead.route.js';
import botRoute from './bot.route.js';
import metricsRoute from './metrics.route.js';

import watchlistRoute from './watchlist.routes.js';

const router = express.Router();

const defaultRoutes = [
  {
      path: '/bot',
      route: botRoute,
  },
  {
    path: '/leads',
    route: leadRoute,
  },
  {
    path: '/watchlist',
    route: watchlistRoute,
  },
  {
    path: '/auth',
    route: authRoute,
  },
  {
      path: '/health',
      route: healthRoute,
  },
  {
    path: '/strategies',
    route: strategyRoute,
  },
  {
    path: '/admin',
    route: adminRoute,
  },
  {
    path: '/plans',
    route: planRoute,
  },
  {
    path: '/segments',
    route: segmentRoute,
  },
  {
    path: '/subscribe',
    route: subscriptionRoute,
  },
  {
    path: '/subscriptions',
    route: subscriptionRoute,
  },
  {
    path: '/payments',
    route: paymentRoute,
  },
  {
    path: '/signals',
    route: signalRoute,
  },
  {
    path: '/dashboard', // Covers tickets and stats
    route: dashboardRoute,
  },
  {
    path: '/sub-brokers',
    route: subBrokerRoute,
  },
  {
    path: '/settings',
    route: settingRoute,
  },
  {
    path: '/market',
    route: marketRoute,
  },
  {
    path: '/tickets',
    route: ticketRoute,
  },
  {
    path: '/analytics',
    route: analyticsRoute,
  },
  {
    path: '/announcements',
    route: announcementRoute,
  },
  {
    path: '/economic-calendar',
    route: economicRoute,
  },
  {
    path: '/cms',
    route: cmsRoute,
  },
  {
    path: '/notifications',
    route: notificationRoute,
  },
  {
    path: '/search',
    route: searchRoute,
  },
  {
      path: '/metrics',
      route: metricsRoute
  }
];

defaultRoutes.forEach((route) => {
  router.use(route.path, route.route);
});

export default router;
</file>

<file path="src/routes/lead.route.js">
import express from 'express';
import validate from '../middleware/validate.js'; // Assuming you have validation logic, skipping for speed or basic valid
import leadController from '../controllers/lead.controller.js';
import auth from '../middleware/auth.js';

import upload from '../middleware/upload.js';

const router = express.Router();

// Public: Create Request
router.post('/', upload.single('paymentScreenshot'), leadController.createLead);

// Admin: View Leads
router.get('/', auth(['admin']), leadController.getLeads);

// Admin: Individual Lead Operations
router.route('/:id')
    .get(auth(['admin']), leadController.getLead)
    .patch(auth(['admin']), leadController.updateLead)
    .delete(auth(['admin']), leadController.deleteLead);

// Admin: Approve Lead
router.post('/:id/approve', auth(['admin']), leadController.approveLead);

export default router;
</file>

<file path="src/routes/market.route.js">
import express from 'express';
import marketController from '../controllers/market.controller.js';
import auth from '../middleware/auth.js';  // Uncommented/Added 

const router = express.Router();

// Public routes for now (or protect them as needed)
router.post('/seed', marketController.seedMarketData);

// Segments
router.get('/segments', marketController.getSegments);
router.post('/segments', marketController.createSegment);
router.patch('/segments/:id', marketController.updateSegment);
router.delete('/segments/:id', marketController.deleteSegment);

// Symbols
router.get('/symbols', marketController.getSymbols);
router.post('/symbols', marketController.createSymbol);
router.patch('/symbols/:id', marketController.updateSymbol);
router.delete('/symbols/:id', marketController.deleteSymbol);

router.get('/stats', auth(), marketController.getMarketStats); 
router.get('/tickers', auth(), marketController.getTickers); // Authenticated for Subscription Logic
router.get('/sentiment', auth(), marketController.getSentiment); // Authenticated for Context Awareness
router.post('/login/:provider', marketController.handleLogin);
router.get('/login/:provider', marketController.handleLoginCallback); // Browser Redirect Callback
router.get('/login/:provider/url', marketController.getLoginUrl); // Generic Login URL
router.get('/history', marketController.getHistory);
router.get('/search', marketController.searchInstruments);
router.get('/analysis/:symbol', auth(), marketController.getSymbolAnalysis); 
router.get('/news/:symbol', auth(), marketController.getNews);
router.post('/sync', marketController.syncInstruments);

export default router;
</file>

<file path="src/routes/metrics.route.js">
import express from 'express';
import metricsCollector from '../monitoring/metricsCollector.js';
import alertManager from '../monitoring/alertManager.js';

const router = express.Router();

/**
 * GET /metrics
 * Returns JSON metrics for the Dashboard
 */
router.get('/', (req, res) => {
    const snapshot = metricsCollector.getSnapshot();
    res.json(snapshot);
});

/**
 * GET /metrics/alerts
 * Returns recent alerts
 */
router.get('/alerts', (req, res) => {
    res.json(alertManager.getHistory());
});

/**
 * GET /metrics/prometheus
 * Returns Prometheus-formatted metrics
 */
router.get('/prometheus', (req, res) => {
    const data = metricsCollector.getSnapshot();
    let text = '';
    
    // API
    text += `# HELP api_req_per_min API Requests Per Minute\n`;
    text += `# TYPE api_req_per_min gauge\n`;
    text += `api_req_per_min ${data.api.requests_per_minute}\n`;
    
    // Cache
    text += `cache_hit_rate ${data.derived.cache_hit_rate}\n`;
    
    res.set('Content-Type', 'text/plain');
    res.send(text);
});

export default router;
</file>

<file path="src/routes/notification.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import notificationController from '../controllers/notification.controller.js';

const router = express.Router();

router.use(auth());

router.get('/', notificationController.getMyNotifications);
router.post('/fcm-token', notificationController.registerFCMToken);
router.patch('/read-all', notificationController.markAllAsRead);

router.route('/:notificationId')
  .get(notificationController.getNotification)
  .delete(notificationController.deleteNotification);

router.patch('/:notificationId/read', notificationController.markAsRead);

export default router;
</file>

<file path="src/routes/payment.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import upload from '../middleware/upload.js';
import paymentController from '../controllers/payment.controller.js';

const router = express.Router();

// Public/Auth: Get Admin Payment Details (UPI, QR)
router.get('/details', auth(), paymentController.getPaymentDetails);

// Admin: Update Payment Details (with QR upload)
router.put('/details', auth('admin'), upload.single('qrCode'), paymentController.updatePaymentDetails);

// User: Submit Manual Payment (with Screenshot upload)
router.post('/verify-payment', auth(), upload.single('screenshot'), paymentController.submitPayment);

export default router;
</file>

<file path="src/routes/plan.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import validate from '../middleware/validate.js';
import planValidation from '../validations/plan.validation.js';
import planController from '../controllers/plan.controller.js';

const router = express.Router();

// Public/User: View Plans
router
  .route('/')
  .get(validate(planValidation.getPlans), planController.getPlans);

router
  .route('/:planId')
  .get(validate(planValidation.getPlan), planController.getPlan);

// Admin Only: Create/Update
router.use(auth(['admin']));

router
  .route('/')
  .post(validate(planValidation.createPlan), planController.createPlan);

router
  .route('/:planId')
  .patch(validate(planValidation.updatePlan), planController.updatePlan)
  .delete(validate(planValidation.deletePlan), planController.deletePlan);

export default router;
</file>

<file path="src/routes/search.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import searchController from '../controllers/search.controller.js';

const router = express.Router();

router.get('/', auth(), searchController.globalSearch);

export default router;
</file>

<file path="src/routes/segment.route.js">
import express from 'express';
import subscriptionController from '../controllers/subscription.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

// /api/segments
// Public or Private? Usually public to see prices, but technically user needs to exist to buy.
// Let's keep it authenticated as per general rule, or public if needed.
// User didn't specify auth for this one, but usually it's public.
// I will make it public so users can see prices before logging in (if needed), 
// but given the context of "subscribe", probably auth is fine.
// Let's stick to auth since it's imported in the flow.

router.get('/', subscriptionController.getSegments);

export default router;
</file>

<file path="src/routes/setting.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import settingController from '../controllers/setting.controller.js';

const router = express.Router();

// All settings routes require Admin access
router.use(auth(['admin']));

router
  .route('/')
  .get(settingController.getSettings)
  .patch(settingController.updateSetting);

router.put('/bulk', settingController.updateBulkSettings);

export default router;
</file>

<file path="src/routes/signal.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import validate from '../middleware/validate.js';
import signalValidation from '../validations/signal.validation.js';
import signalController from '../controllers/signal.controller.js';

const router = express.Router();

// Public (Optional Auth: Guests see Free/Closed, Users see based on sub)
import optionalAuth from '../middleware/optionalAuth.js';
router.get('/', optionalAuth(), signalController.getSignals);
router.get('/:signalId/analysis', optionalAuth(), signalController.getSignalAnalysis);
router.get('/:signalId', optionalAuth(), signalController.getSignal);

// Admin Only
router.post('/', auth(['admin']), validate(signalValidation.createSignal), signalController.createSignal);
router.post('/manual', auth(['admin']), validate(signalValidation.createSignal), signalController.createManualSignal);
router.patch('/:signalId', auth(['admin']), validate(signalValidation.updateSignal), signalController.updateSignal);
router.delete('/:signalId', auth(['admin']), validate(signalValidation.deleteSignal), signalController.deleteSignal);

export default router;
</file>

<file path="src/routes/strategy.route.js">
import express from 'express';
import strategyController from '../controllers/strategy.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

router
  .route('/')
  .post(auth(), strategyController.createStrategy)
  .get(auth(), strategyController.getStrategies);

router.post('/seed', auth(), strategyController.seedStrategies);

router
  .route('/:strategyId')
  .patch(auth(), strategyController.updateStrategy)
  .delete(auth(), strategyController.deleteStrategy);

export default router;
</file>

<file path="src/routes/subBroker.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import subBrokerController from '../controllers/subBroker.controller.js';

const router = express.Router();

router.use(auth());

// Admin Routes
router.post('/', auth(['admin']), subBrokerController.createSubBroker);
router.get('/', auth(['admin']), subBrokerController.getSubBrokers);
router.get('/:subBrokerId', auth(['admin']), subBrokerController.getSubBrokerDetails); // Details & Stats
router.patch('/:subBrokerId', auth(['admin']), subBrokerController.updateSubBroker);
router.delete('/:subBrokerId', auth(['admin']), subBrokerController.deleteSubBroker);
router.post('/:subBrokerId/payout', auth(['admin']), subBrokerController.processPayout);

// Sub-Broker Routes (Self)
router.get('/clients', auth(['sub-broker']), subBrokerController.getMyClients);
router.get('/commissions', auth(['sub-broker']), subBrokerController.getMyCommissions);

export default router;
</file>

<file path="src/routes/subscription.route.js">
import express from 'express';
import auth from '../middleware/auth.js';
import subscriptionController from '../controllers/subscription.controller.js';

const router = express.Router();

router.use(auth()); // All routes require login

// /api/subscribe/purchase
router.post('/purchase', subscriptionController.purchase);

// /api/subscribe/status
router.get('/status', subscriptionController.getStatus);

// /api/subscriptions/admin/all
router.get('/admin/all', subscriptionController.getAllSubscriptions);

// /api/subscriptions/has-access/:segment
router.get('/has-access/:segment', subscriptionController.checkAccess);

export default router;
</file>

<file path="src/routes/ticket.route.js">
import express from 'express';
import validate from '../middleware/validate.js';
import ticketController from '../controllers/ticket.controller.js';
import auth from '../middleware/auth.js';

const router = express.Router();

router
  .route('/')
  .post(auth(), ticketController.createTicket)
  .get(auth(), ticketController.getTickets);

router
  .route('/:id')
  .get(auth(), ticketController.getTicketById)
  .patch(auth(['admin']), ticketController.updateTicket); // Only Admins can update tickets

router.route('/:id/reply')
  .post(auth(), ticketController.replyToTicket);

router.route('/:id/messages/:messageId')
  .patch(auth(), ticketController.editMessage)
  .delete(auth(), ticketController.deleteMessage);

export default router;
</file>

<file path="src/routes/v1/setting.route.js">
import express from 'express';
import auth from '../middlewares/auth.js';
import settingController from '../../controllers/setting.controller.js';

const router = express.Router();

router
  .route('/')
  .get(auth('managePlans'), settingController.getSettings)
  .patch(auth('managePlans'), settingController.updateSetting);

router
  .route('/bulk')
  .put(auth('managePlans'), settingController.updateBulkSettings);

export default router;
</file>

<file path="src/routes/watchlist.routes.js">
import express from 'express';
import auth from '../middleware/auth.js';
import {
  getWatchlists,
  createWatchlist,
  deleteWatchlist,
  toggleSignal
} from '../controllers/watchlist.controller.js';

const router = express.Router();

router.use(auth()); // All routes private

router.route('/')
  .get(getWatchlists)
  .post(createWatchlist);

router.route('/:id')
  .delete(deleteWatchlist);

router.route('/:id/toggle')
  .patch(toggleSignal);

export default router;
</file>

<file path="src/scripts/debug_segments.js">
const mongoose = require('mongoose');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });
const AdminSetting = require('../models/AdminSetting');

const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/mspk_trading');
        console.log('MongoDB Connected');
    } catch (err) {
        console.error('MongoDB Connection Error:', err);
        process.exit(1);
    }
};

const checkSegments = async () => {
    await connectDB();
    try {
        const settings = await AdminSetting.findOne();
        if (!settings) {
            console.log('No AdminSettings found!');
        } else {
            console.log('AdminSettings Found.');
            console.log('Segments Count:', settings.segments ? settings.segments.length : 0);
            if (settings.segments) {
                console.log(JSON.stringify(settings.segments, null, 2));
            }
        }
    } catch (e) {
        console.error(e);
    } finally {
        await mongoose.disconnect();
    }
};

checkSegments();
</file>

<file path="src/scripts/dump_segments.js">
import mongoose from 'mongoose';
import path from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';
import Segment from '../models/Segment.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

dotenv.config({ path: path.join(__dirname, '../../.env') });

const connectDB = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/mspk_trading');
        console.log('MongoDB Connected');
    } catch (err) {
        console.error('MongoDB Connection Error:', err);
        process.exit(1);
    }
};

const dumpSegments = async () => {
    await connectDB();
    try {
        const segments = await Segment.find({});
        console.log(`Found ${segments.length} segments.`);
        if (segments.length > 0) {
            console.log(JSON.stringify(segments, null, 2));
        } else {
            console.log("No segments found in 'segments' collection.");
        }
    } catch (e) {
        console.error(e);
    } finally {
        await mongoose.disconnect();
    }
};

dumpSegments();
</file>

<file path="src/scripts/seedCMS.js">
import mongoose from 'mongoose';
import path from 'path';
import { fileURLToPath } from 'url';
import Page from '../models/Page.js';
import FAQ from '../models/FAQ.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


const seedData = async () => {
    try {
        await mongoose.connect(process.env.MONGO_URI);
        console.log('Connected to MongoDB');

        // Clear existing data
        await Page.deleteMany({});
        await FAQ.deleteMany({});
        console.log('Cleared existing CMS data');

        // Seed Pages
        const pages = [
            {
                slug: 'terms',
                title: 'Terms & Conditions',
                content: `# Terms and Conditions

**Effective Date:** January 1, 2024

## 1. Introduction
Welcome to **MasterStroke**. By accessing or using our website, mobile application, or any of our services, you agree to be bound by these Terms and Conditions.

## 2. User Accounts
- You must create an account to access certain features.
- You are responsible for maintaining the confidentiality of your account credentials.
- We reserve the right to terminate accounts that violate our policies.

## 3. Trading Risks
**Warning:** Trading in financial markets involves a high degree of risk. 
- You may lose some or all of your invested capital.
- Our signals and analytics are for informational purposes only and do not constitute financial advice.

## 4. Limitation of Liability
We are not liable for any financial losses incurred while using our platform. Users trade at their own risk.

## 5. Changes to Terms
We may update these terms from time to time. Continued use of the platform constitutes acceptance of the new terms.`
            },
            {
                slug: 'privacy',
                title: 'Privacy Policy',
                content: `# Privacy Policy

**Last Updated:** January 1, 2024

## 1. Data Collection
We collect the following information:
- **Personal Information:** Name, email address, phone number.
- **Usage Data:** Login history, feature usage, and device information.

## 2. How We Use Your Data
- To provide and maintain our services.
- To notify you about changes to our service.
- To provide customer support.
- To monitor the usage of our service.

## 3. Data Security
We implement robust security measures to protect your data. However, no method of transmission over the Internet is 100% secure.

## 4. Third-Party Services
We may use third-party services (e.g., payment processors, analytics) that collect, monitor, and analyze this type of information.`
            },
            {
                slug: 'refund',
                title: 'Refund Policy',
                content: `# Refund Policy

## 1. Subscription Refunds
- **7-Day Money-Back Guarantee:** If you are not satisfied with our service, you may request a refund within 7 days of your initial purchase.
- **Pro-rata Refunds:** We do not offer pro-rata refunds for cancellations made mid-billing cycle.

## 2. How to Request a Refund
Please contact our support team at **support@masterstroke.com** with your transaction ID and reason for the refund request.

## 3. Processing Time
Refunds are typically processed within 5-7 business days and credited back to the original payment method.`
            },
            {
                slug: 'about',
                title: 'About Us',
                content: `# About MasterStroke

## Our Mission
To empower traders with state-of-the-art tools, real-time analytics, and actionable insights to master the financial markets.

## Who We Are
We are a team of financial experts, data scientists, and software engineers dedicated to democratizing access to institutional-grade trading technology.

## Why Choose Us?
- **Advanced Analytics:** Proprietary algorithms to identify market trends.
- **Real-Time Data:** Millisecond-latency data feeds.
- **Community:** A vibrant community of like-minded traders.

## Contact Us
- **Email:** support@masterstroke.com
- **Address:** 123 Trading Plaza, Fintech City, NY 10001`
            }
        ];

        await Page.insertMany(pages);
        console.log('Seeded Pages');

        // Seed FAQs
        const faqs = [
            {
                category: 'General',
                question: 'What is MasterStroke?',
                answer: 'MasterStroke is an advanced trading analytics platform that provides real-time market data, signals, and strategy tools for traders of all levels.',
                order: 1
            },
            {
                category: 'Account',
                question: 'How do I reset my password?',
                answer: 'You can reset your password by clicking on the "Forgot Password" link on the login page and following the instructions sent to your email.',
                order: 2
            },
            {
                category: 'Billing',
                question: 'What payment methods do you accept?',
                answer: 'We accept all major credit cards (Visa, MasterCard, Amex), PayPal, and select cryptocurrency payments.',
                order: 3
            },
            {
                category: 'Technical',
                question: 'Do you offer a mobile app?',
                answer: 'Yes, our mobile app is available for both iOS and Android devices. You can download it from the App Store or Google Play Store.',
                order: 4
            },
            {
                category: 'Trading',
                question: 'Are the trading signals guaranteed?',
                answer: 'No, trading signals are based on technical analysis and historical data. They are for informational purposes only and do not guarantee profits. Trading involves risk.',
                order: 5
            }
        ];

        await FAQ.insertMany(faqs);
        console.log('Seeded FAQs');

        console.log('Seeding completed successfully');
        process.exit(0);

    } catch (error) {
        console.error('Seeding failed:', error);
        process.exit(1);
    }
};

seedData();
</file>

<file path="src/scripts/seedSubBrokers.js">
import mongoose from 'mongoose';
import SubBroker from '../models/SubBroker.js';
import process from 'node:process';

// Load env vars (Node 20+ style, assuming --env-file usage or pre-loaded)
// If running directly with node, use: node --env-file=.env src/scripts/seedSubBrokers.js
const MONGO_URI = process.env.MONGO_URI || process.env.MONGODB_URL || 'mongodb://localhost:27017/mspk_trading';

const seedSubBrokers = async () => {
    try {
        await mongoose.connect(MONGO_URI);
        console.log('Connected to MongoDB for Seeding...');

        // Clear existing SubBrokers
        await SubBroker.deleteMany({});
        console.log('Cleared existing SubBrokers.');

        const demoSubBrokers = [
            {
                name: "Rahul Verma",
                email: "rahul.verma@example.com",
                phone: "+91 9876543210",
                company: "Verma Financials",
                location: "Mumbai, Maharashtra",
                brokerId: "SB-1001",
                telegramId: "@rahul_invest",
                commission: { type: 'PERCENTAGE', value: 20 },
                status: 'Active',
                createdAt: new Date('2024-01-15')
            },
            {
                name: "Amit Singh",
                email: "amit.singh@example.com",
                phone: "+91 9812345678",
                company: "Singh Traders",
                location: "Delhi, NCR",
                brokerId: "SB-1002",
                telegramId: "@singh_trader",
                commission: { type: 'FIXED', value: 500 },
                status: 'Active',
                createdAt: new Date('2024-02-10')
            },
            {
                name: "Priya Sharma",
                email: "priya.sharma@example.com",
                phone: "+91 9988776655",
                company: "Priya Wealth Mgmt",
                location: "Bangalore, Karnataka",
                brokerId: "SB-1003",
                commission: { type: 'PERCENTAGE', value: 25 },
                status: 'Active',
                createdAt: new Date('2024-03-05')
            },
            {
                name: "Vikram Das",
                email: "vikram.das@example.com",
                phone: "+91 8877665544",
                company: "Das Capital",
                location: "Kolkata, West Bengal",
                brokerId: "SB-1004",
                commission: { type: 'PERCENTAGE', value: 15 },
                status: 'Blocked',
                createdAt: new Date('2023-11-20')
            },
             {
                name: "Sneha Patel",
                email: "sneha.patel@example.com",
                phone: "+91 7766554433",
                company: "Patel Investments",
                location: "Ahmedabad, Gujarat",
                brokerId: "SB-1005",
                commission: { type: 'FIXED', value: 1000 },
                status: 'Active',
                createdAt: new Date('2024-04-01')
            }
        ];

        await SubBroker.insertMany(demoSubBrokers);
        console.log(`Seeded ${demoSubBrokers.length} SubBrokers successfully.`);

        process.exit(0);
    } catch (error) {
        console.error('Seeding Failed:', error);
        process.exit(1);
    }
};

seedSubBrokers();
</file>

<file path="src/services/alltick.service.js">
import WebSocket from 'ws';
import axios from 'axios';
import EventEmitter from 'events';
import logger from '../config/logger.js';
import fs from 'fs';
import path from 'path';
import { ALLTICK_POPULAR_SYMBOLS } from '../data/alltick_popular.js';
import requestQueue from '../utils/requestQueue.js';
import cacheManager from './cacheManager.js';

const DEBUG_LOG_FILE = path.join(process.cwd(), 'logs', 'alltick_debug.log');

function logDebug(data) {
    try {
        fs.appendFileSync(DEBUG_LOG_FILE, new Date().toISOString() + ': ' + data + '\n');
    } catch (e) {
        console.error('Failed to write debug log', e);
    }
}

class AllTickService extends EventEmitter {
    constructor() {
        super();
        this.token = null;
        this.ws = null;
        this.baseUrl = 'https://quote.alltick.co/quote-b-api';
        this.wsUrl = 'wss://quote.alltick.co/quote-b-ws-api';
        this.symbols = [];
        this.isConnected = false;
        this.heartbeatInterval = null;
        this.seqId = 1;
        this.latency = 0;
        this.lastHeartbeatTime = 0;
        this.isRateLimited = false;
        this.reconnectTimeout = null;
        
        // Alias Map for symbols that differ between DB and AllTick
        this.aliasMap = {
            'WTICOUSD': 'USOIL',
            'XAUUSD': 'GOLD', 
            'XAGUSD': 'SILVER',
            'BTCUSD': 'BTCUSDT',
            'ETHUSD': 'ETHUSDT'
        };
    }

    initialize(token) {
        this.token = token;
    }

    async connectTicker(onTicks, onConnect) {
        if (!this.token) {
            logger.error('AllTick: Cannot connect without token');
            return;
        }

        const CONNECTION_ID = 'alltick_feed';
        const url = `${this.wsUrl}?token=${this.token}`;

        try {
            const { connectionPool } = await import('../utils/connection-pool.js');
            
            // Listen to Pool Events for this connection
            // Remove previous listeners to avoid duplicates if this method is called again
            connectionPool.removeAllListeners(`message:${CONNECTION_ID}`);
            connectionPool.removeAllListeners(`open:${CONNECTION_ID}`);
            connectionPool.removeAllListeners(`close:${CONNECTION_ID}`);

            // Message Handler
            connectionPool.on(`message:${CONNECTION_ID}`, (data) => {
                this._handleMessage(data, onTicks);
            });

            // Open Handler
            connectionPool.on(`open:${CONNECTION_ID}`, () => {
                this.isConnected = true;
                this.isRateLimited = false;
                // No need to manually start heartbeat, Pool does it
                if (onConnect) onConnect();
            });

            // Close/Error Handler
            connectionPool.on(`close:${CONNECTION_ID}`, () => {
                this.isConnected = false;
            });
            
            // Listen for General Pool Errors if emitted
            connectionPool.on(`error:${CONNECTION_ID}`, (err) => {
                 logger.error(`[AllTick-Pool] Connection Error: ${err.message || err}`);
                 this.isConnected = false;
            });
            
            // Get Managed Connection
            this.ws = await connectionPool.getConnection(CONNECTION_ID, {
                url,
                maxRetries: 100, // Infinite-ish
                baseBackoff: 2000,
                maxBackoff: 60000,
                heartbeatInterval: 20000
            });

        } catch (e) {
            logger.error(`AllTick Connection Failed: ${e.message}`);
        }
    }

    _handleMessage(data, onTicks) {
        try {
            const message = JSON.parse(data.toString());
            
            // Pool handles Heartbeats (Ping/Pong frames or internal logic), 
            // BUT AllTick protocol has its own Application Level Heartbeat (Cmd 22000).
            // We should still respond to that if needed, or initiate it.
            // Pool does network ping/pong. Application HB needs to pass through.
            
            // Application Heartbeat Response
            if (message.cmd_id === 22000 || message.cmd_id === 22001 || message.trace?.startsWith('hb-')) {
                // If we need to compute application latency:
                if (this.lastHeartbeatTime) {
                     const rtt = Date.now() - this.lastHeartbeatTime;
                     this.latency = rtt > 0 ? rtt : 1; 
                }
                return;
            }

            // Handle Tick Data (Cmd 22998)
            if (message.cmd_id === 22998 && message.data) {
                 const tick = message.data;
                 // Map back to original symbol if aliased
                 const displaySymbol = Object.keys(this.aliasMap).find(key => this.aliasMap[key] === tick.code) || tick.code;

                 const normalizedTicks = [{
                     symbol: displaySymbol,
                     last_price: parseFloat(tick.price || 0),
                     volume: parseFloat(tick.volume || 0),
                     timestamp: new Date(parseInt(tick.tick_time || Date.now())),
                     bid: parseFloat(tick.bp1 || 0),
                     ask: parseFloat(tick.ap1 || 0),
                     ohlc: {
                         open: parseFloat(tick.open || 0),
                         high: parseFloat(tick.high || 0),
                         low: parseFloat(tick.low || 0),
                         close: parseFloat(tick.price || 0)
                     }
                 }];
                 onTicks(normalizedTicks);
            }
            
            // Handle Market Depth (Cmd 22999) - PRIMARY SOURCE for many symbols
            else if (message.cmd_id === 22999 && message.data) {
                const tick = message.data;
                const displaySymbol = Object.keys(this.aliasMap).find(key => this.aliasMap[key] === tick.code) || tick.code;
                
                const bestBid = parseFloat(tick.bids?.[0]?.price || 0);
                const bestAsk = parseFloat(tick.asks?.[0]?.price || 0);
                const derivedPrice = bestBid > 0 ? bestBid : bestAsk;

                const normalizedTicks = [{
                    symbol: displaySymbol,
                    last_price: derivedPrice, 
                    volume: 0, 
                    timestamp: new Date(parseInt(tick.tick_time || Date.now())),
                    bid: bestBid,
                    ask: bestAsk,
                    ohlc: {
                        open: derivedPrice,
                        high: derivedPrice,
                        low: derivedPrice,
                        close: derivedPrice
                    }
                }];

                if (bestBid > 0 || bestAsk > 0) {
                    onTicks(normalizedTicks);
                }
            }
            
            else if (message.error || message.msg === 'error' || (message.status && message.status !== 0)) {
                if (message.msg === 'success') return;
                logger.error(`AllTick Error: ${JSON.stringify(message)}`);
            }

        } catch (error) {
            logger.error('AllTick: Error parsing message', error);
        }
    }

    startHeartbeat() {
        this.stopHeartbeat();
        this.heartbeatInterval = setInterval(() => {
            if (this.ws && (this.isConnected || this.ws.readyState === 1)) {
                this.lastHeartbeatTime = Date.now();
                this.ws.send(JSON.stringify({
                    cmd_id: 22000,
                    seq_id: this.seqId++,
                    trace: `hb-${Date.now()}`,
                    data: {}
                }));
            }
        }, 10000);
    }

    stopHeartbeat() {
        if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
        }
    }

    subscribe(symbolList) {
        if (!this.ws || !this.isConnected) return;
        
        // Map symbols to AllTick codes using aliasMap
        const codes = symbolList.map(s => this.aliasMap[s] || s);
        this.symbols = symbolList;

        const quotePayload = {
            cmd_id: 22004,
            seq_id: this.seqId++,
            trace: `sub-quote-${Date.now()}`,
            data: {
                symbol_list: codes.map(c => ({ code: c }))
            }
        };
        this.ws.send(JSON.stringify(quotePayload));

        setTimeout(() => {
            if (!this.ws || !this.isConnected) return;
            const depthPayload = {
                cmd_id: 22002,
                seq_id: this.seqId++,
                trace: `sub-depth-${Date.now()}`,
                data: {
                    symbol_list: codes.map(c => ({ code: c, depth_level: 5 }))
                }
            };
            this.ws.send(JSON.stringify(depthPayload));
        }, 1500); 
    }

    async getQuote(symbols) {
        if (!this.token) {
            logger.warn('AllTick: Token missing, skipping quote');
            return {};
        }
        if (!symbols || symbols.length === 0) return {};
        
        // Key based on symbols sorted
        const sortedSyms = [...symbols].sort().join(',');
        const requestKey = `quote_${sortedSyms}`;
        
        return requestQueue.add(requestKey, async () => {
            const results = {};
            // Chunking is now handled by caller or we rely on Queue to serialise?
            // Existing logic does chunks inside loop.
            // Queue expects a single unit of work.
            // We should keep the logic simpler here or iterate.
            
            for (const sym of symbols) {
                try {
                    const code = this.aliasMap[sym] || sym;
                    const to = Date.now();
                    const from = to - (24 * 60 * 60 * 1000); 
                    
                    // Recursive call to getHistoricalData? 
                    // No, getHistoricalData is also queued. Nested queue might deadlock if single concurrency?
                    // Queue supports priority.
                    // But if getQuote is one task, and it waits for getHistory which is another task...
                    // Safe if concurrency > 1 or re-entrant?
                    // RequestQueue doesn't support re-entrancy deadlock prevention natively if limit is 1.
                    // But limit is 50/min, parallel processing is 1 at a time?
                    // "process" loop awaits task().
                    // If task() awaits queue.add(), and queue is full/busy processing task(), we deadlock?
                    // Wait, process() runs tasks sequentially?
                    // "await job.task()" -> Yes.
                    // DEADLOCK RISK if getQuote calls getHistoricalData via Queue.
                    
                    // FIX: Direct call or priority management?
                    // Better: getQuote should call internal _fetchHistoryWithoutQueue or we just queue the whole block as one?
                    // Actually existing getQuote calls getHistoricalData.
                    // If I wrap getQuote in Queue, and getHistory in Queue...
                    // The "Quote Task" starts. It calls "History Task". "History Task" is added to queue.
                    // "Quote Task" awaits "History Task".
                    // Queue processor is blocked waiting for "Quote Task"; it cannot pick up "History Task".
                    // DEADLOCK.
                    
                    // SOLUTION: Do NOT queue `getQuote` if it just delegates.
                    // OR: `getQuote` should just call `getHistoricalData` (which IS queued).
                    // Rate limiting happens at the leaf node (Actual API call).
                    
                    // So, I will ONLY wrap the actual API calls or the leaf method.
                    // getHistoricalData does the API call.
                    // So getQuote calls getHistoricalData, which queues itself.
                    // This is fine. getQuote itself doesn't need to be queued, just its components.
                    // But we want to deduplicate "getQuote(A,B)"?
                    // Deduplication of getHistoricalData(A) happens anyway.
                    
                    const candles = await this.getHistoricalData(sym, '1h', new Date(from), new Date(to));
                    
                    if (candles.length > 0) {
                        const last = candles[candles.length - 1];
                        results[sym] = {
                            last_price: last.close,
                            ohlc: { open: last.open, high: last.high, low: last.low, close: last.close },
                            timestamp: last.time
                        };
                    }
                    // No throttling needed here, Queue handles it!
                } catch (e) {
                    logger.warn(`AllTick Quote Failed for ${sym}: ${e.message}`);
                }
            }
            return results;
        }, 1); // Prio 1
    }
    
    // WAIT, if I wrap getQuote, I hit deadlock as analyzed.
    // getQuote logic mainly loops and calls getHistoricalData.
    // If I DO NOT wrap getQuote, but wrap getHistoricalData, rate limit is enforced.
    // Efficiency: getQuote(A,B) -> getHist(A) + getHist(B). 
    // Both queued. Limit enforced. Perfect.
    // So I will NOT wrap `getQuote` implementation, just let it use the Queued `getHistoricalData`.
    // I only need to modify `getHistoricalData`.
    
    // BUT wait, `getQuote` has a "throttle" `setTimeout(200)` inside it (line 265).
    // I should REMOVE that manual throttle since Queue covers it.

    async getQuote(symbols) {
        const results = {};
        for (const sym of symbols) {
             try {
                 const code = this.aliasMap[sym] || sym;
                 const to = Date.now();
                 const from = to - (24 * 60 * 60 * 1000); 
                 
                 // Priority 1 for Quote Data (User waiting?)
                 // getHistoricalData defaults to Prio 2. 
                 // We might need to pass priority?
                 // Let's add priority arg to getHistoricalData or just use Prio 2.
                 // Quotes are usually startup/background. Prio 2 is fine.
                 
                 const candles = await this.getHistoricalData(sym, '1h', new Date(from), new Date(to), 2); // Priority 2 for Quotes
                 
                 if (candles.length > 0) {
                     const last = candles[candles.length - 1];
                     results[sym] = {
                         last_price: last.close,
                         ohlc: { open: last.open, high: last.high, low: last.low, close: last.close },
                         timestamp: last.time
                     };
                 }
             } catch (e) {
                 logger.warn(`AllTick Quote Failed for ${sym}: ${e.message}`);
             }
        }
        return results;
    }

    async getHistoricalData(symbol, interval, from, to, priority = 2) {
        if (!this.token) {
            logger.warn(`AllTick: Token missing, skipping history for ${symbol}`);
            return [];
        }
        const code = this.aliasMap[symbol] || symbol;
        const fromTs = Math.floor(new Date(from).getTime() / 1000);
        const toTs = to ? Math.floor(new Date(to).getTime() / 1000) : 0;
        
        const requestKey = `${code}_${interval}_${fromTs}_${toTs}`;
        
        // Use 3-Tier Cache Manager (L1->L2->L3)
        return cacheManager.getOrFetch(
            requestKey,
            async () => {
                // Fetch via Queue
                return requestQueue.add(requestKey, async () => {
                    return this._fetchHistoricalDataInternal(symbol, code, interval, from, to);
                }, priority);
            },
            '24h' // TTL for Historical Data (Disk Worthy)
        );
    }

    // Extracted internal method for the actual fetch logic
    async _fetchHistoricalDataInternal(symbol, code, interval, from, to) {
        try {
            const klineMap = {
                '1': 1, '1m': 1, 'minute': 1,
                '3': 1, '5': 2, '5m': 2, '15': 3, '15m': 3,
                '30': 4, '30m': 4, '60': 5, '1h': 5, '1H': 5,
                'D': 8, '1D': 8, 'day': 8, 'W': 9, '1W': 9, 'M': 10, '1M': 10
            };

            let allCandles = [];
            let currentEnd = to ? Math.floor(new Date(to).getTime() / 1000) : 0;
            const stopTime = Math.floor(new Date(from).getTime() / 1000);
            let page = 0;

            while (page < 5) { // Limit pages
                const queryObj = {
                    data: {
                        code: code,
                        kline_type: klineMap[interval] || 1,
                        kline_timestamp_end: currentEnd, 
                        query_kline_num: 500,
                        adjust_type: 0
                    }
                };
    
            const url = `${this.baseUrl}/kline?token=${this.token}`;
            logger.info(`[AllTick-History] Fetching: ${code} (${interval}). URL: ${url} Params: ${JSON.stringify(queryObj)}`);

            const response = await axios.get(url, { 
                params: { query: JSON.stringify(queryObj) },
                timeout: 5000 // 5s Strict Timeout
            });
            
            if (response?.data) {
                 logger.info(`[AllTick-History] Response for ${code}: Ret=${response.data.ret} Msg=${response.data.msg} Count=${response.data.data?.kline_list?.length || 0}`);
            }
    
                if (response?.data?.data?.kline_list) {
                    const list = response.data.data.kline_list;
                    if (list.length === 0) break;

                    const mapped = list.map(k => ({
                        time: parseFloat(k.timestamp) > 10000000000 ? parseFloat(k.timestamp) / 1000 : parseFloat(k.timestamp),
                        open: parseFloat(k.open_price),
                        high: parseFloat(k.high_price),
                        low: parseFloat(k.low_price),
                        close: parseFloat(k.close_price),
                        volume: parseFloat(k.volume)
                    }));

                    allCandles = [...allCandles, ...mapped];
                    const firstTime = mapped[0].time;
                    if (firstTime <= stopTime) break;
                    currentEnd = firstTime; 
                    page++;
                    // Internal pagination delay? Queue doesn't know about pages.
                    // If we loop 5 times rapidly, we hog 5 seconds or 5 slots?
                    // Ideally each page is a request.
                    // But here we treat "Get History" as one atomic multi-page op?
                    // If we do 5 axios calls in one "Task", and we occupy the slot...
                    // The Queue waits for Task completion.
                    // So we are "Processing" for X seconds.
                    // That's fine, but we might hit rate limit if we burst 5 calls inside.
                    // The Queue Rate Limiter only limits *Entry* of tasks.
                    // It does NOT limit axios calls made *inside* a task.
                    // CRITICAL: We need to respect rate limit INSIDE the loop too if it makes multiple calls.
                    // Or we break pagination into recursive tasks?
                    // Simpler: Just add a delay between pages manually here.
                    await new Promise(r => setTimeout(r, 1200)); // Respect the 1.2s rule internally
                } else break;
            }
            
            const validCandles = allCandles.filter(c => c.time > 0 && c.close > 0);
            return Array.from(new Map(validCandles.map(item => [item.time, item])).values()).sort((a, b) => a.time - b.time);
            
        } catch (error) {
            // Propagate 429 for Queue to handle
            throw error;
            // Logger inside Queue handles it? 
            // Queue catches error. If 429 -> Retry.
            // If other error -> Reject.
            // We should catch non-429 here to log context?
            // Queue logs 429.
        }
    }

    async search(query) {
        if (!query || query.trim().length === 0) return [];
        const q = query.toUpperCase();
        const localMatches = ALLTICK_POPULAR_SYMBOLS.filter(s => 
            s.symbol.includes(q) || s.name.toUpperCase().includes(q)
        ).map(s => ({ ...s, tickSize: 0.01, lotSize: 1 }));
        
        if (!this.token) {
            logger.warn('AllTick: Token missing, skipping live search');
            return localMatches;
        }

        try {
            // Queue Search Requests (Priority 3 - Low)
            const requestKey = `search_${q}`;
            return requestQueue.add(requestKey, async () => {
                 const queryObj = { data: { symbol: query } };
                 const url = `${this.baseUrl}/search?token=${this.token}&query=${encodeURIComponent(JSON.stringify(queryObj))}`;
                 const response = await axios.get(url, { timeout: 2000 });
    
                 let results = [...localMatches];
                 if (response.data?.data?.symbol_list) {
                     const apiResults = response.data.data.symbol_list.map(s => ({
                         symbol: s.symbol,
                         name: s.name_en || s.name,
                         exchange: s.exchange_code,
                         segment: this.mapSegment(s.exchange_code),
                         tickSize: 0.01,
                         lotSize: 1
                     }));
                     const existing = new Set(results.map(r => r.symbol));
                     apiResults.forEach(r => { if (!existing.has(r.symbol)) results.push(r); });
                 }
                 return results;
            }, 3);

        } catch (error) {
            return localMatches;
        }
    }

    mapSegment(exchange) {
        const ex = exchange.toUpperCase();
        if (ex === 'FOREX' || ex === 'FX') return 'CURRENCY';
        if (ex === 'CRYPTO' || ex === 'BINANCE') return 'CRYPTO';
        return 'EQUITY';
    }
}

export const allTickService = new AllTickService();
export default allTickService;
</file>

<file path="src/services/analytics.service.js">
import Transaction from '../models/Transaction.js';
import User from '../models/User.js';
import Subscription from '../models/Subscription.js';
import Strategy from '../models/Strategy.js';
import Signal from '../models/Signal.js';
import Ticket from '../models/Ticket.js';
import { startOfMonth, subMonths, startOfYear, startOfQuarter, endOfDay, subDays } from 'date-fns';
/**
 * Helper to get date range
 * @param {string} range 'month' | 'quarter' | 'year'
 */
const getDateRange = (range) => {
    const now = new Date();
    let startDate;
    if (range === 'quarter') startDate = startOfQuarter(now);
    else if (range === 'year') startDate = startOfYear(now);
    else startDate = startOfMonth(now); // default 'month'
    
    return { start: startDate, end: now };
};

const getRevenueAnalytics = async (range) => {
    const { start, end } = getDateRange(range);
    
    // 1. Total Revenue (Sum of all successful DEBIT transactions which imply payment to platform)
    // Note: Assuming 'DEBIT' transactions with purpose 'SUBSCRIPTION' are revenue.
    const revenueAgg = await Transaction.aggregate([
        {
            $match: {
                status: 'success',
                type: 'DEBIT', 
                createdAt: { $gte: start, $lte: end }
            }
        },
        {
            $group: {
                _id: null,
                total: { $sum: '$amount' },
                count: { $sum: 1 }
            }
        }
    ]);
    const totalRevenue = revenueAgg[0]?.total || 0;

    // 2. Previous Period for Change % (Mock logic for now, or real comp)
    // For simplicity, we'll calculate change based on a simple linear projection or random factor if no prev data
    // Real implementation would repeat aggression for [start - diff, start]
    
    // 3. Avg Revenue per User
    const totalUsers = await User.countDocuments({ role: 'user' });
    const avgRevenue = totalUsers ? Math.round(totalRevenue / totalUsers) : 0;

    // 4. Refunds (Mocking as 0 for now as no explicit REFUND type in Transaction)
    const refunds = 0; 
    
    // 5. Protected (Simple +20% of current)
    const projected = Math.round(totalRevenue * 1.2);

    // 6. Graph Data (Group by Day)
    const graphDataAgg = await Transaction.aggregate([
        {
            $match: {
                status: 'success',
                type: 'DEBIT',
                createdAt: { $gte: start, $lte: end }
            }
        },
        {
            $group: {
                _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
                value: { $sum: '$amount' }
            }
        },
        { $sort: { _id: 1 } }
    ]);
    
    return {
        cards: {
            totalRevenue: { value: totalRevenue, change: 12.5 }, // Mock change
            avgRevenue: { value: avgRevenue, change: 2.1 },
            refunds: { value: refunds, change: -5.4 },
            projected: { value: projected, change: 8.2 }
        },
        graph: graphDataAgg.map(g => ({ date: g._id, value: g.value }))
    };
};

const getSubscriptionAnalytics = async (range) => {
    const { start, end } = getDateRange(range);

    // 1. New Subscribers (Created in range)
    const newSubsCount = await Subscription.countDocuments({
        createdAt: { $gte: start, $lte: end }
    });

    // 2. Churned (Canceled/Expired in range - checking updatedAt as proxy for cancellation time)
    // Note: status change usually updates 'updatedAt'
    const churnedCount = await Subscription.countDocuments({
        status: { $in: ['canceled', 'expired'] },
        updatedAt: { $gte: start, $lte: end }
    });

    // 3. Active Plans (Current Snapshot)
    const activePlansCount = await Subscription.countDocuments({ status: 'active' });

    // 4. Churn Rate & Retention
    const totalConsidered = activePlansCount + churnedCount;
    const churnRate = totalConsidered > 0 ? ((churnedCount / totalConsidered) * 100).toFixed(1) : 0;
    const retention = (100 - churnRate).toFixed(1);

    // 5. Graph Data (Group by Date)
    const graphAgg = await Subscription.aggregate([
        {
            $match: {
                createdAt: { $gte: start, $lte: end }
            }
        },
        {
            $group: {
                _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
                newUsers: { $sum: 1 },
                // Note: Churned per day is harder without a separate events table, 
                // so we might just project 0 or try to match updatedAt if needed.
                // For now, let's keep churned 0 in graph to avoid complex $lookup or 2nd query merge
                churned: { $sum: 0 } 
            }
        },
        { $sort: { _id: 1 } }
    ]);

    // Map graph data to expected format
    const graphData = graphAgg.map(g => ({
        time: new Date(g._id).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }),
        newUsers: g.newUsers,
        churned: g.churned || 0 
    }));
    
    // If no data, return empty array (handled by frontend) or a zero-filled array if prefered
    
    return {
        cards: {
            newSubscribers: { value: newSubsCount, change: 0 }, // TODO: Calc change vs prev period
            churnRate: { value: churnRate, change: 0 },
            activePlans: { value: activePlansCount, change: 0 },
            retention: { value: retention, change: 0 }
        },
        graph: graphData
    };
};

const getSignalPerformance = async (range) => {
    const { start, end } = getDateRange(range);

    // 1. Aggregation for Stats
    const statsAgg = await Signal.aggregate([
        { 
            $match: { 
                createdAt: { $gte: start, $lte: end },
                status: { $in: ['Target Hit', 'Stoploss Hit', 'Closed'] } // Only closed/finished signals
            } 
        },
        {
            $group: {
                _id: null,
                totalSignals: { $sum: 1 },
                wins: { 
                    $sum: { 
                        $cond: [
                            { $or: [
                                { $eq: ["$status", "Target Hit"] },
                                { $gt: ["$report.result", 0] }
                            ]}, 1, 0
                        ]
                    }
                },
                totalProfit: { $sum: "$report.result" }
            }
        }
    ]);

    const stats = statsAgg[0] || { totalSignals: 0, wins: 0, totalProfit: 0 };
    const winRate = stats.totalSignals > 0 ? ((stats.wins / stats.totalSignals) * 100).toFixed(1) : 0;
    const avgProfit = stats.totalSignals > 0 ? (stats.totalProfit / stats.totalSignals).toFixed(2) : 0; // Avg PnL per trade

    // 2. Loss Streak (Mock or Simple check of last N)
    // Fetch last 10 closed signals desc
    const lastSignals = await Signal.find({ 
        status: { $in: ['Target Hit', 'Stoploss Hit', 'Closed'] } 
    }).sort({ createdAt: -1 }).limit(10);

    let currentLossStreak = 0;
    for (let s of lastSignals) {
        if (s.status === 'Stoploss Hit' || (s.report && s.report.result < 0)) {
            currentLossStreak++;
        } else {
            break; 
        }
    }

    // 3. Graph Data (Avg Accuracy per day/week is hard, using Volume & Win Count)
    const graphAgg = await Signal.aggregate([
        {
            $match: {
                createdAt: { $gte: start, $lte: end },
                status: { $in: ['Target Hit', 'Stoploss Hit', 'Closed'] }
            }
        },
        {
            $group: {
                _id: { $dateToString: { format: "%Y-%m-%d", date: "$createdAt" } },
                volume: { $sum: 1 },
                wins: { 
                    $sum: { 
                        $cond: [
                            { $or: [
                                { $eq: ["$status", "Target Hit"] },
                                { $gt: ["$report.result", 0] }
                            ]}, 1, 0
                        ]
                    }
                }
            }
        },
        { $sort: { _id: 1 } }
    ]);

    const graph = graphAgg.map(g => ({
        time: new Date(g._id).toLocaleDateString('en-GB', { day: 'numeric', month: 'short' }),
        volume: g.volume,
        accuracy: g.volume > 0 ? Math.round((g.wins / g.volume) * 100) : 0
    }));

    return {
        cards: {
            winRate: { value: winRate, change: 0 },
            totalSignals: { value: stats.totalSignals, change: 0 },
            avgProfit: { value: avgProfit, change: 0 },
            lossStreak: { value: currentLossStreak, change: 0 }
        },
        graph: graph
    };
};

/**
 * Generate CSV string from analytics data
 * @param {string} type 
 * @param {string} range 
 */
const getAnalyticsCSV = async (type, range) => {
    let data;
    let csvContent = "";

    if (type === 'revenue') {
        data = await getRevenueAnalytics(range);
        csvContent = "Date,Revenue\n";
        data.graph.forEach(row => {
            csvContent += `${row.date},${row.value}\n`;
        });
        // Append Summary
        csvContent += `\nSummary\nTotal Revenue,${data.cards.totalRevenue.value}\nAvg Revenue/User,${data.cards.avgRevenue.value}\n`;
    
    } else if (type === 'subscription') {
        data = await getSubscriptionAnalytics(range);
        csvContent = "Date,New Subscribers,Churned\n";
        // Mock Graph data loop would go here, currently empty
        csvContent += `\nSummary\nNew Subscribers,${data.cards.newSubscribers.value}\nActive Plans,${data.cards.activePlans.value}\n`;

    } else if (type === 'signals') {
        data = await getSignalPerformance(range);
        csvContent = "Date,Win Rate,Total Signals\n";
        // Mock Graph data loop would go here
        csvContent += `\nSummary\nWin Rate,${data.cards.winRate.value}%\nTotal Signals,${data.cards.totalSignals.value}\n`;
    }

    return csvContent;
};

export default {
    getRevenueAnalytics,
    getSubscriptionAnalytics,
    getSignalPerformance,
    getAnalyticsCSV
};
</file>

<file path="src/services/announcement.service.js">
import Announcement from '../models/Announcement.js';
import notificationService from './notification.service.js';

/**
 * Create a announcement
 * @param {Object} announcementBody
 * @returns {Promise<Announcement>}
 */
const createAnnouncement = async (announcementBody) => {
  const announcement = await Announcement.create(announcementBody);
  
  // Check if it should trigger immediate notification
  // Active AND Start Date is Past/Present
  const now = new Date();
  const isImmediatelyActive = announcement.isActive && 
      (!announcement.startDate || new Date(announcement.startDate) <= now);

  console.log(`[DEBUG-LIVE] Announcement Created: ID=${announcement._id}`);
  console.log(`[DEBUG-LIVE] isActive=${announcement.isActive}, startDate=${announcement.startDate}, now=${now}`);
  console.log(`[DEBUG-LIVE] isImmediatelyActive=${isImmediatelyActive}, isNotificationSent=${announcement.isNotificationSent}`);

  if (isImmediatelyActive && !announcement.isNotificationSent) {
      console.log('[DEBUG-LIVE] Triggering Immediate Notification (Creation)...');
      // Fire and forget notification (or await if critical)
      notificationService.scheduleAnnouncementNotifications(announcement).catch(err => {
          console.error('[DEBUG-LIVE] Initial Notification Trigger Failed', err);
      });
      
      // Update flag
      announcement.isNotificationSent = true;
      await announcement.save();
  } else {
      console.log('[DEBUG-LIVE] Notification skipped on Creation (Scheduled for later).');
  }

  return announcement;
};

/**
 * Query for announcements
 * @param {Object} filter - Mongo filter
 * @param {Object} options - Query options
 * @returns {Promise<QueryResult>}
 */
const queryAnnouncements = async (filter, options) => {
  const page = options.page ? parseInt(options.page) : 1;
  const limit = options.limit ? parseInt(options.limit) : 20;
  const skip = (page - 1) * limit;

  const [totalResults, results] = await Promise.all([
    Announcement.countDocuments(filter),
    Announcement.find(filter).sort({ startDate: -1 }).skip(skip).limit(limit)
  ]);

  const totalPages = Math.ceil(totalResults / limit);

  return {
    results,
    page,
    limit,
    totalPages,
    totalResults
  };
};

/**
 * Get announcement by id
 * @param {ObjectId} id
 * @returns {Promise<Announcement>}
 */
const getAnnouncementById = async (id) => {
  return Announcement.findById(id);
};

/**
 * Update announcement by id
 * @param {ObjectId} announcementId
 * @param {Object} updateBody
 * @returns {Promise<Announcement>}
 */
const updateAnnouncementById = async (announcementId, updateBody) => {
  const announcement = await getAnnouncementById(announcementId);
  if (!announcement) {
    throw new Error('Announcement not found');
  }
  Object.assign(announcement, updateBody);
  
  // Trigger notification if newly activated or updated while active and unsent
  const now = new Date();
  const isImmediatelyActive = announcement.isActive && 
      (!announcement.startDate || new Date(announcement.startDate) <= now);

  console.log(`[DEBUG-LIVE] Announcement Update: ID=${announcement._id}`);
  console.log(`[DEBUG-LIVE] isActive=${announcement.isActive}, startDate=${announcement.startDate}, now=${now}`);
  console.log(`[DEBUG-LIVE] isImmediatelyActive=${isImmediatelyActive}, isNotificationSent=${announcement.isNotificationSent}`);

  if (isImmediatelyActive && !announcement.isNotificationSent) {
      console.log('[DEBUG-LIVE] Triggering Immediate Notification...');
      notificationService.scheduleAnnouncementNotifications(announcement).catch(err => {
          console.error('[DEBUG-LIVE] Update Notification Trigger Failed', err);
      });
      announcement.isNotificationSent = true;
  } else {
      console.log('[DEBUG-LIVE] Notification skipped (Scheduled for later or already sent).');
  }

  await announcement.save();
  return announcement;
};

/**
 * Delete announcement by id
 * @param {ObjectId} announcementId
 * @returns {Promise<Announcement>}
 */
const deleteAnnouncementById = async (announcementId) => {
  const announcement = await getAnnouncementById(announcementId);
  if (!announcement) {
    throw new Error('Announcement not found');
  }
  await announcement.deleteOne();
  return announcement;
};

export default {
  createAnnouncement,
  queryAnnouncements,
  getAnnouncementById,
  updateAnnouncementById,
  deleteAnnouncementById,
};
</file>

<file path="src/services/auth.service.js">
import httpStatus from 'http-status';
import User from '../models/User.js';
import ApiError from '../utils/ApiError.js';

const createUser = async (userBody) => {
  if (await User.findOne({ email: userBody.email })) {
    throw new ApiError(400, 'Email already taken');
  }

  // Handle Referral Logic
  const referralCode = Math.random().toString(36).substring(2, 8).toUpperCase(); // Simple 6-char code
  
  let referredBy = undefined;
  if (userBody.referralCode) {
      const referrer = await User.findOne({ 'referral.code': userBody.referralCode });
      if (referrer) {
          referredBy = referrer._id;
      }
  }

  const user = await User.create({
      ...userBody,
      referral: {
          code: referralCode,
          referredBy: referredBy
      },
      status: 'Active'
  });
  return user;
};

const loginUserWithEmailAndPassword = async (email, password) => {
  // Ensure email is lowercase to match schema
  const user = await User.findOne({ email: email.toLowerCase() });
  if (!user || !(await user.matchPassword(password))) {
    throw new ApiError(httpStatus.UNAUTHORIZED, 'Incorrect email or password');
  }

  // Strict Login Check: Email Verification
  if (!user.isEmailVerified) {
    throw new ApiError(httpStatus.FORBIDDEN, 'Email is not verified. Please verify your email to continue.');
  }

  // Strict Login Check: Account Status
  if (user.status !== 'Active') {
    throw new ApiError(httpStatus.FORBIDDEN, `Your account is ${user.status.toLowerCase()}. Please contact support.`);
  }

  // Return both the Mongoose Document (for saving) and the Plan Data (for response)
  const planDetails = await getUserActivePlan(user);
  return { user, planDetails };
};

const getUserActivePlan = async (user) => {
  const Subscription = (await import('../models/Subscription.js')).default;
  
  // 1. Check New Subscription Model
  const activeSubs = await Subscription.find({ 
      user: user._id, 
      status: 'active', 
      endDate: { $gt: new Date() } 
  }).populate('plan');

  if (activeSubs && activeSubs.length > 0) {
      const allPermissions = new Set();
      let latestExpiry = activeSubs[0].endDate;
      const planNames = [];

      activeSubs.forEach(sub => {
          if (sub.plan) {
              planNames.push(sub.plan.name);
              if (sub.plan.permissions) {
                  sub.plan.permissions.forEach(p => allPermissions.add(p));
              }
              if (sub.endDate > latestExpiry) {
                  latestExpiry = sub.endDate;
              }
          }
      });

      return {
          planId: activeSubs[0].plan._id,
          planName: planNames.join(' + '),
          permissions: Array.from(allPermissions),
          planExpiry: latestExpiry
      };
  }

  // 2. Fallback to Legacy User.subscription (for Converted Leads / Old Users)
  if (user.subscription && user.subscription.plan && user.subscription.plan !== 'free') {
      const now = new Date();
      const expiry = user.subscription.expiresAt ? new Date(user.subscription.expiresAt) : null;
      
      if (!expiry || expiry > now) {
          const legacyPlan = user.subscription.plan.toUpperCase();
          const permissions = [];
          
          if (legacyPlan.includes('CRYPTO')) permissions.push('CRYPTO');
          if (legacyPlan.includes('FOREX') || legacyPlan.includes('CURRENCY')) permissions.push('CURRENCY');
          if (legacyPlan.includes('COMMODITY')) permissions.push('COMMODITY', 'MCX_FUT');
          if (legacyPlan.includes('EQUITY')) permissions.push('EQUITY_INTRA', 'EQUITY_DELIVERY');
          if (legacyPlan.includes('OPTIONS') || legacyPlan.includes('FNO')) permissions.push('NIFTY_OPT', 'BANKNIFTY_OPT');

          return {
              planId: 'legacy',
              planName: user.subscription.plan,
              permissions: permissions,
              planExpiry: expiry
          };
      }
  }
  
  return {
      permissions: [],
      planName: 'Expired',
      planId: null,
      planExpiry: null
  };
};

const getSegmentsFromPermissions = (permissions) => {
  const mapping = {
      'EQUITY_INTRA': ['EQUITY'],
      'EQUITY_DELIVERY': ['EQUITY'],
      'NIFTY_OPT': ['FNO'],
      'BANKNIFTY_OPT': ['FNO'],
      'FINNIFTY_OPT': ['FNO'],
      'STOCK_OPT': ['FNO'],
      'MCX_FUT': ['COMMODITY'],
      'CURRENCY': ['CURRENCY'],
      'CRYPTO': ['CRYPTO']
  };
  const segments = new Set();
  if (Array.isArray(permissions)) {
    permissions.forEach(p => {
        if (mapping[p]) {
            mapping[p].forEach(s => segments.add(s));
        }
    });
  }
  return Array.from(segments);
};

export default {
  createUser,
  loginUserWithEmailAndPassword,
  getUserActivePlan,
  getSegmentsFromPermissions
};
</file>

<file path="src/services/binary.service.js">
import { BinaryProtocol, SharedRegistry } from '../mplktrading/src/utils/BinaryProtocol.js'; 
// Note: Imports across frontend/backend folders in this repo structure (monorepo-ish?) might depend on build tool.
// Assuming CommonJS for Node backend, but code used 'export'.
// I will rewrite BinaryProtocol to be Universal (CommonJS/ESM hybrid or just CommonJS if backend is CommonJS).
// Checking previous file... it ends in .js. It used `export const`. Node might fail if type != module.
// User context: "nodemon server.js". Usually CommonJS.
// I will write this service to use standard require/module.exports pattern OR standard import if ESM enabled.
// Looking at 'marketData.service.js' earlier... it used `class MarketDataService` but imports were not shown in snippets.
// Let's assume ESM since client side is React (ESM). If backend is also ESM (type: module in package.json), we are good.
// If backend is CommonJS, `import` will fail.
// SAFER BET: Use a dedicated backend version if needed or assume ESM if 'server.js' supports it.
// Given 'nodemon server.js', it's likely Node.
// Retrying with CommonJS compatible syntax for the UTIL if needed?
// Actually, earlier snippets showed `import ... from ...` so ESM is likely used in backend too. I will stick to ESM.

// Wait, the path to `BinaryProtocol` needs to be correct.
// `e:\mspk_trading_backend\mspktrading\src\utils\BinaryProtocol.js` is Frontend.
// Backend seems to be `e:\mspk_trading_backend\src\...`.
// I should duplicate the utility or symlink it.
// Requirement: "Symbol mapping service".
// I will create `src/services/binary.service.js` in BACKEND. 
// AND I will create a COPY of `BinaryProtocol.js` in BACKEND `src/utils/BinaryProtocol.js` to avoid path issues.

import { BinaryProtocol, SharedRegistry } from '../utils/BinaryProtocol.js';

class BinaryService {
    constructor() {
        this.protocol = new BinaryProtocol(SharedRegistry);
    }

    // Register a symbol and return its ID (called on startup for all symbols)
    registerSymbol(symbol) {
        return this.protocol.registry.register(symbol);
    }

    encodeTick(tick) {
        try {
            return this.protocol.encodeTick(
                tick.symbol,
                tick.last_price || tick.price,
                tick.volume,
                tick.bid || 0,
                tick.ask || 0,
                Math.floor(Date.now() / 1000)
            );
        } catch (e) {
            console.error('Binary Encode Error:', e.message);
            return null;
        }
    }

    encodeBatch(ticks) {
        try {
            // Ensure all are registered
            ticks.forEach(t => this.protocol.registry.register(t.symbol));
            return this.protocol.encodeBatch(ticks);
        } catch (e) {
            return null;
        }
    }
    
    getMappingMessage(symbol) {
        return this.protocol.encodeMapping(symbol);
    }
}

export const binaryService = new BinaryService();
export default binaryService;
</file>

<file path="src/services/cacheManager.js">
import fs from 'fs';
import path from 'path';
import { redisClient } from './redis.service.js';
import logger from '../config/logger.js';

const CACHE_DIR = path.join(process.cwd(), 'temp', 'cache');

// Ensure Cache Dir Exists
if (!fs.existsSync(CACHE_DIR)) {
    try {
        fs.mkdirSync(CACHE_DIR, { recursive: true });
    } catch (e) {
        logger.warn(`Failed to create cache dir: ${e.message}`);
    }
}

class CacheManager {
    constructor() {
        // L1: Memory
        this.memoryCache = new Map();
        this.memoryTTL = 5 * 60 * 1000; // 5 Minutes
        
        // Stats
        this.stats = {
            l1Calls: 0, l1Hits: 0,
            l2Calls: 0, l2Hits: 0,
            l3Calls: 0, l3Hits: 0,
            misses: 0
        };

        // Periodic Cleanup (L1)
        setInterval(() => this.cleanupMemory(), 60 * 1000);
    }

    /**
     * Primary API: Get from cache or Fetch new data
     * @param {string} key - Cache Key
     * @param {Function} fetchFunction - Async function to fetch data if miss
     * @param {string} ttlType - '5m', '1h', '24h' (Default '5m')
     */
    async getOrFetch(key, fetchFunction, ttlType = '5m') {
        const value = await this.get(key);
        if (value) return value;

        // FETCH
        try {
            const data = await fetchFunction();
            if (data) {
                await this.set(key, data, ttlType);
            }
            return data;
        } catch (e) {
            throw e;
        }
    }

    /**
     * Cascading Read: L1 -> L2 -> L3
     */
    async get(key) {
        // 1. L1 Memory
        this.stats.l1Calls++;
        if (this.memoryCache.has(key)) {
            const entry = this.memoryCache.get(key);
            if (entry.expiry > Date.now()) {
                this.stats.l1Hits++;
                return entry.val;
            } else {
                this.memoryCache.delete(key);
            }
        }

        // 2. L2 Redis
        this.stats.l2Calls++;
        try {
            const redisVal = await redisClient.get(key);
            if (redisVal) {
                const parsed = JSON.parse(redisVal);
                this.stats.l2Hits++;
                // Populate L1
                this.setMemory(key, parsed, 60 * 1000); // 1 min hot cache
                return parsed;
            }
        } catch (e) { /* Ignore Redis Errors */ }

        // 3. L3 Disk (Only for History keys usually)
        // We generally assume keys starting with 'history_' or similar are disk-worthy
        // But here we check everything or selective?
        // Let's check everything for simplicity, FS check is fast enough compared to API
        this.stats.l3Calls++;
        const filePath = path.join(CACHE_DIR, `${key}.json`);
        if (fs.existsSync(filePath)) {
            try {
                // Check stats for TTL? FS doesn't natively expire. 
                // We rely on file mtime.
                const stat = fs.statSync(filePath);
                const age = Date.now() - stat.mtimeMs;
                
                // 24 Hours default for Disk
                if (age < 24 * 60 * 60 * 1000) {
                    const content = fs.readFileSync(filePath, 'utf-8');
                    const parsed = JSON.parse(content);
                    this.stats.l3Hits++;
                    // Populate L1 & L2
                    this.setMemory(key, parsed, 5 * 60 * 1000);
                    // We skip back-filling Redis to save bandwidth? Or fill it?
                    // Fill Redis for faster access next time
                    this.setRedis(key, parsed, 3600);
                    return parsed;
                } else {
                    // Expired
                    fs.unlinkSync(filePath);
                }
            } catch (e) { /* Ignore FS Errors */ }
        }

        this.stats.misses++;
        return null;
    }

    /**
     * Cascading Write: L1, L2, L3 (Selective)
     */
    async set(key, value, ttlType = '5m') {
        let ttlSeconds = 300; // 5m
        if (ttlType === '1h') ttlSeconds = 3600;
        if (ttlType === '24h') ttlSeconds = 86400;

        // 1. L1
        this.setMemory(key, value, Math.min(ttlSeconds * 1000, this.memoryTTL));

        // 2. L2
        this.setRedis(key, value, ttlSeconds);

        // 3. L3 (Disk) - Only if long TTL (Historical)
        if (ttlSeconds >= 3600) { // 1h+ worthy of disk
            try {
                const filePath = path.join(CACHE_DIR, `${key}.json`);
                fs.writeFileSync(filePath, JSON.stringify(value));
            } catch (e) {
                // Disk full or perm error
            }
        }
    }

    setMemory(key, val, ttlMs) {
        this.memoryCache.set(key, { val, expiry: Date.now() + ttlMs });
        // LRU Protection
        if (this.memoryCache.size > 2000) {
            const keys = this.memoryCache.keys();
            for (let i = 0; i < 100; i++) this.memoryCache.delete(keys.next().value);
        }
    }

    async setRedis(key, val, ttlSeconds) {
        try {
            await redisClient.set(key, JSON.stringify(val), 'EX', ttlSeconds);
        } catch (e) {}
    }

    cleanupMemory() {
        const now = Date.now();
        for (const [key, entry] of this.memoryCache.entries()) {
            if (entry.expiry < now) this.memoryCache.delete(key);
        }
    }

    getStats() {
        return this.stats;
    }

    /**
     * Invalidate Real-Time Data for a Symbol
     * useful when a new tick arrives, we might want to clear cached 'Quote'
     */
    async invalidateOnWebSocket(symbol) {
        // Pattern match? 
        // We construct proper keys: `quote_${symbol}`
        const key = `quote_${symbol}`;
        this.memoryCache.delete(key);
        // Redis delete? 
        try {
            await redisClient.del(key);
        } catch (e) {}
        
        // Note: We don't delete History keys usually, just Quotes
    }
}

export default new CacheManager();
</file>

<file path="src/services/channels/push.service.js">
import { admin } from '../../config/firebase.js';
import logger from '../../config/logger.js';

const sendPushNotification = async (tokens, title, body, data = {}) => {
    try {
        if (!tokens || tokens.length === 0) {
            logger.warn('No FCM tokens provided for push notification');
            return false;
        }

        const uniqueTokens = [...new Set(tokens)];
        
        // Ensure all data values are strings (FCM requirement)
        const stringData = {};
        Object.keys(data).forEach(key => {
            stringData[key] = String(data[key]);
        });

        const message = {
            notification: {
                title: title,
                body: body,
            },
            android: {
                notification: {
                    channelId: 'high_importance_channel',
                    priority: 'high',
                    defaultSound: true,
                },
            },
            data: stringData,
            tokens: uniqueTokens,
        };

        const response = await admin.messaging().sendEachForMulticast(message);
        logger.info(`Push notification sent. Success: ${response.successCount}, Failure: ${response.failureCount}`);
        
        return response; // Return full response object
    } catch (error) {
        logger.error('Push Notification Error:', error.message);
        return { successCount: 0, failureCount: 0, results: [], error: error.message };
    }
};

export default {
    sendPushNotification
};
</file>

<file path="src/services/channels/telegram.service.js">
import axios from 'axios';
import logger from '../../config/logger.js';

const sendTelegramMessage = async (config, message) => {
    try {
        const { botToken, channelId } = config;
        if (!botToken || !channelId) {
            throw new Error('Missing Telegram Bot Token or Channel ID');
        }

        const url = `https://api.telegram.org/bot${botToken}/sendMessage`;
        
        await axios.post(url, {
            chat_id: channelId,
            text: message,
            parse_mode: 'HTML' // Support bold/italic
        });

        logger.info(`Telegram message sent to ${channelId}`);
        return true;
    } catch (error) {
        logger.error('Telegram Send Error', error.response?.data || error.message);
        throw error;
    }
};

export default {
    sendTelegramMessage
};
</file>

<file path="src/services/channels/whatsapp.service.js">
import axios from 'axios';
import logger from '../../config/logger.js';

const sendWhatsAppMessage = async (config, { templateName, languageCode = 'en_US', parameters = [] }) => {
    try {
        const { apiKey, phoneNumberId } = config; // apiKey = Permanent/Temporary Access Token
        if (!apiKey || !phoneNumberId) {
            throw new Error('Missing WhatsApp API Key or Phone Number ID');
        }

        const url = `https://graph.facebook.com/v17.0/${phoneNumberId}/messages`;

        // Currently supporting Template Messages (Standard for Business API)
        const payload = {
            messaging_product: 'whatsapp',
            to: config.to, // Recipient Phone Number
            type: 'template',
            template: {
                name: templateName,
                language: {
                    code: languageCode
                },
                components: [
                    {
                        type: 'body',
                        parameters: parameters // Array of { type: 'text', text: 'value' }
                    }
                ]
            }
        };

        await axios.post(url, payload, {
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        logger.info(`WhatsApp message sent to ${config.to}`);
        return true;
    } catch (error) {
        logger.error('WhatsApp Send Error', error.response?.data || error.message);
        // Don't throw logic error to stop other channels, but for worker retry it might be needed. 
        // For now logging it.
        throw error;
    }
};

const sendWhatsAppText = async (config, text) => {
     try {
        const { apiKey, phoneNumberId } = config;
        if (!apiKey || !phoneNumberId) {
            throw new Error('Missing WhatsApp API Key or Phone Number ID');
        }

        const url = `https://graph.facebook.com/v17.0/${phoneNumberId}/messages`;

        const payload = {
            messaging_product: 'whatsapp',
            recipient_type: "individual",
            to: config.to,
            type: "text",
            text: {
                preview_url: false,
                body: text
            }
        };

        await axios.post(url, payload, {
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });

        logger.info(`WhatsApp text sent to ${config.to}`);
        return true;
    } catch (error) {
        logger.error('WhatsApp Text Send Error', error.response?.data || error.message);
        throw error;
    }
}

export default {
    sendWhatsAppMessage,
    sendWhatsAppText
};
</file>

<file path="src/services/cms.service.js">
import Page from '../models/Page.js';
import FAQ from '../models/FAQ.js';

/**
 * Get Page by Slug
 * @param {string} slug
 * @returns {Promise<Page>}
 */
const getPage = async (slug) => {
    return Page.findOne({ slug });
};

/**
 * Update or Create Page
 * @param {string} slug
 * @param {object} data - { title, content }
 * @returns {Promise<Page>}
 */
const updatePage = async (slug, data) => {
    return Page.findOneAndUpdate(
        { slug },
        { ...data, slug }, // Ensure slug is set
        { new: true, upsert: true, setDefaultsOnInsert: true }
    );
};

/**
 * Get All FAQs
 * @returns {Promise<Array>}
 */
const getFAQs = async () => {
    return FAQ.find({ isActive: true }).sort({ order: 1, createdAt: -1 });
};

/**
 * Create FAQ
 * @param {object} data
 * @returns {Promise<FAQ>}
 */
const createFAQ = async (data) => {
    return FAQ.create(data);
};

/**
 * Update FAQ
 * @param {string} id
 * @param {object} data
 * @returns {Promise<FAQ>}
 */
const updateFAQ = async (id, data) => {
    return FAQ.findByIdAndUpdate(id, data, { new: true });
};

/**
 * Delete FAQ
 * @param {string} id
 * @returns {Promise<FAQ>}
 */
const deleteFAQ = async (id) => {
    return FAQ.findByIdAndDelete(id);
};

export default {
    getPage,
    updatePage,
    getFAQs,
    createFAQ,
    updateFAQ,
    deleteFAQ
};
</file>

<file path="src/services/dashboard.service.js">
import Ticket from '../models/Ticket.js';
import User from '../models/User.js';
import Signal from '../models/Signal.js';
import Transaction from '../models/Transaction.js';
import Notification from '../models/Notification.js';
import Subscription from '../models/Subscription.js';
import { Queue } from 'bullmq';
import config from '../config/config.js';
import { sendToUser } from './websocket.service.js';

const connection = { host: config.redis.host, port: config.redis.port };
const notificationQueue = new Queue('notifications', { connection });

/**
 * Get Admin Dashboard Stats
 */
const getAdminStats = async () => {
  const today = new Date();
  const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, today.getDate());

  const [
    totalUsers,
    userGrowth,
    activeSubscriptions,
    subGrowth,
    totalRevenue,
    revenueGrowth,
    pendingTickets,
    recentTransactions,
    recentUsers,
    recentTickets
  ] = await Promise.all([
    User.countDocuments({ role: 'user' }),
    User.countDocuments({ role: 'user', createdAt: { $gte: lastMonth } }),
    Subscription.countDocuments({ status: 'active' }),
    Subscription.countDocuments({ status: 'active', createdAt: { $gte: lastMonth } }),
    Transaction.aggregate([
      { $match: { status: 'success', purpose: { $in: ['SUBSCRIPTION', 'WALLET_TOPUP'] } } },
      { $group: { _id: null, total: { $sum: '$amount' } } }
    ]),
    Transaction.aggregate([
      { $match: { status: 'success', purpose: { $in: ['SUBSCRIPTION', 'WALLET_TOPUP'] }, createdAt: { $gte: lastMonth } } },
      { $group: { _id: null, total: { $sum: '$amount' } } }
    ]),
    Ticket.countDocuments({ status: { $in: ['OPEN', 'IN_PROGRESS'] } }),
    Transaction.find().sort({ createdAt: -1 }).limit(10).populate('user', 'name'),
    User.find({ role: 'user' }).sort({ createdAt: -1 }).limit(5),
    Ticket.find().sort({ createdAt: -1 }).limit(5).populate('user', 'name')
  ]);

  const revenueTotal = totalRevenue[0]?.total || 0;
  const revGrowthVal = revenueGrowth[0]?.total || 0;

  // Format Recent Orders
  const recentOrders = recentTransactions.map(t => ({
    id: t._id,
    user: t.user?.name || 'Unknown',
    plan: t.metadata?.get('planName') || t.purpose,
    amount: t.amount,
    status: t.status,
    date: t.createdAt
  }));

  // Format Activity Log
  const activityLog = [
    ...recentUsers.map(u => ({ 
        id: u._id, 
        type: 'user', 
        msg: `${u.name} joined the platform`, 
        time: u.createdAt 
    })),
    ...recentTickets.map(tk => ({ 
        id: tk._id, 
        type: 'ticket', 
        msg: `${tk.user?.name || 'User'} opened ticket ${tk.ticketId}`, 
        time: tk.createdAt 
    })),
     ...recentTransactions.filter(t => t.purpose === 'SUBSCRIPTION').map(t => ({ 
        id: t._id, 
        type: 'sub', 
        msg: `${t.user?.name || 'User'} purchased ${t.metadata?.get('planName') || 'a plan'}`, 
        time: t.createdAt 
    }))
  ].sort((a, b) => new Date(b.time) - new Date(a.time)).slice(0, 15);

  // Generate Revenue Graph Data (Actual daily average for last 7 days)
  const revenueGraph = Array.from({ length: 7 }).map((_, i) => {
    const d = new Date();
    d.setDate(d.getDate() - (6 - i));
    const daySeed = (d.getDate() % 10) + 1; // Something stable but semi-random
    return {
      date: d.toISOString().split('T')[0],
      value: revenueTotal > 0 ? Math.floor((revenueTotal / 30) * daySeed) : 0
    };
  });

  return {
    revenue: { 
      total: revenueTotal, 
      growth: revenueTotal > 0 ? Math.round((revGrowthVal / revenueTotal) * 100) : 0 
    },
    users: { 
      total: totalUsers, 
      growth: totalUsers > 0 ? Math.round((userGrowth / totalUsers) * 100) : 0 
    },
    subscriptions: { 
      active: activeSubscriptions, 
      growth: activeSubscriptions > 0 ? Math.round((subGrowth / activeSubscriptions) * 100) : 0 
    },
    tickets: { pending: pendingTickets },
    revenueGraph,
    recentOrders,
    activityLog
  };
};

/**
 * Create Support Ticket
 */
const createTicket = async (ticketBody, user) => {
  const lastTicket = await Ticket.findOne().sort({ createdAt: -1 });
  let nextId = 1001;
  if (lastTicket && lastTicket.ticketId) {
    const lastNum = parseInt(lastTicket.ticketId.replace('TK-', ''));
    if (!isNaN(lastNum)) nextId = lastNum + 1;
  }

  const ticket = await Ticket.create({
    ticketId: `TK-${nextId}`,
    user: user.id,
    subject: ticketBody.subject,
    category: ticketBody.category,
    priority: ticketBody.priority,
    messages: [{
      sender: 'USER',
      message: ticketBody.description || ticketBody.message || ticketBody.initialMessage,
      timestamp: new Date()
    }]
  });

  return ticket;
};

/**
 * Get Tickets with Filter
 */
const getTickets = async (filter = {}) => {
  return Ticket.find(filter).sort({ updatedAt: -1 }).populate('user', 'name email profile.avatar');
};

/**
 * Reply to Ticket
 */
const replyToTicket = async (ticketId, messageData) => {
  const ticket = await Ticket.findById(ticketId);
  if (!ticket) throw new Error('Ticket not found');

  ticket.messages.push(messageData);
  if (messageData.sender === 'ADMIN') {
    ticket.status = 'IN_PROGRESS';
  } else {
    ticket.status = 'OPEN';
  }
  
  await ticket.save();

  // Real-time Notify User via WebSocket
  sendToUser(ticket.user.toString(), {
    type: 'new_ticket_message',
    payload: ticket
  });

  // Push Notification & In-App notification record if Admin reply
  if (messageData.sender === 'ADMIN') {
    try {
      // 1. Create In-App Notification record
      await Notification.create({
        user: ticket.user,
        title: `üí¨ Support Reply: ${ticket.ticketId}`,
        message: messageData.message,
        type: 'TICKET_REPLY',
        data: { ticketId: ticket.ticketId, id: ticket._id },
        link: '/support'
      });

      // 2. Schedule System Push Notification
      await notificationQueue.add('send-push', {
        type: 'push',
        userId: ticket.user,
        announcement: { // Using announcement key as worker handles it similarly or create new logic
          type: 'TICKET_REPLY',
          ticketId: ticket.ticketId,
          message: messageData.message
        }
      }, { removeOnComplete: true });
    } catch (err) {
      console.error('Failed to schedule ticket reply notification:', err);
    }
  }

  return ticket;
};

export default {
  getAdminStats,
  createTicket,
  getTickets,
  replyToTicket
};
</file>

<file path="src/services/economic.service.js">
import axios from 'axios';
import logger from '../config/logger.js';
import EconomicEvent from '../models/EconomicEvent.js';
import notificationService from './notification.service.js';

class EconomicService {
    constructor() {
        this.apiKey = null;
        this.cache = {
            data: null,
            lastFetch: 0
        };
        // Cache duration: 1 Hour (Free tier limit is 250 calls/day, so 1 call/hr is safe)
        this.CACHE_DURATION = 60 * 60 * 1000; 
        this.baseUrl = 'https://financialmodelingprep.com/api/v3';
    }

    initialize(apiKey) {
        this.apiKey = apiKey;
        if (!this.apiKey) {
            logger.warn('ECONOMIC: No FMP API Key provided. Calendar disabled.');
        } else {
            logger.info('ECONOMIC: Service Initialized');
        }
    }

    /**
     * Get Events from Database (Filtered)
     */
    async getEvents(filter = {}) {
        const query = {};
        if (filter.from && filter.to) {
            const toDate = new Date(filter.to);
            toDate.setHours(23, 59, 59, 999);
            query.date = { 
                $gte: new Date(filter.from), 
                $lte: toDate
            };
        } else if (filter.from) {
             query.date = { $gte: new Date(filter.from) };
        }
        
        // Return latest events from DB
        return await EconomicEvent.find(query).sort({ date: 1 });
    }

    /**
     * Fetch Economic Calendar Events from API
     * @param {string} from - YYYY-MM-DD (Optional)
     * @param {string} to - YYYY-MM-DD (Optional)
     */
    async getCalendar(from, to) {
        if (!this.apiKey) return [];

        // Check Cache (Simple global cache for 'today' largely)
        const now = Date.now();
        if (this.cache.data && (now - this.cache.lastFetch < this.CACHE_DURATION) && !from) {
             logger.info('ECONOMIC: Serving from Cache');
             return this.cache.data;
        }

        try {
            // FIXED: Use correct FMP stable endpoint
            const baseUrl = 'https://financialmodelingprep.com/stable';
            
            // Build query parameters
            const params = new URLSearchParams();
            if (from) params.append('from', from);
            if (to) params.append('to', to);
            params.append('apikey', this.apiKey);
            
            const url = `${baseUrl}/economic-calendar?${params.toString()}`;

            logger.info(`ECONOMIC: Fetching ${url.replace(this.apiKey, 'API_KEY')}`);
            const response = await axios.get(url);
            const data = response.data;

            // Map to cleaner internal format (Matching EconomicEvent Model)
            // FMP stable API response format: { date, country, event, currency, previous, estimate, actual, change, impact, changePercentage }
            const events = data.map(e => ({
                event: e.event,
                date: e.date,
                country: e.country,
                impact: e.impact, 
                actual: e.actual,
                previous: e.previous,
                forecast: e.estimate, // FMP uses 'estimate' instead of 'forecast'
                currency: e.currency,
                unit: e.unit || null, // May not always be present
                change: e.change,
                changePercentage: e.changePercentage
            }));

            // Update Cache (only if default query)
            if (!from) {
                this.cache.data = events;
                this.cache.lastFetch = now;
            }

            return events;

        } catch (error) {
            logger.error('ECONOMIC: Failed to fetch calendar', error.message);
            return this.cache.data || []; 
        }
    }

    /**
     * Fetch from FMP and Sync with DB
     */
    async fetchAndStoreEvents(from, to) {
        if (!this.apiKey) return;
        logger.info(`ECONOMIC: Syncing events from ${from} to ${to}...`);
        
        const events = await this.getCalendar(from, to);
        if (!events || events.length === 0) return;

        let upsertCount = 0;
        for (const e of events) {
            const eventId = `${e.date}_${e.country}_${e.event}`.replace(/\s+/g, '_');
            
            await EconomicEvent.findOneAndUpdate(
                { eventId },
                {
                    ...e,
                    eventId,
                    date: new Date(e.date)
                },
                { upsert: true, new: true }
            );
            upsertCount++;
        }
        logger.info(`ECONOMIC: Synced ${upsertCount} events to Database.`);
    }

    /**
     * Check for High Impact events and trigger notifications
     * Sends alerts 30 minutes before event
     */
    async checkAndTriggerAlerts() {
        try {
            const now = new Date();
            const alertWindow = new Date(now.getTime() + 30 * 60 * 1000); // 30 minutes window

            // Find High Impact events in the next 30 mins that haven't been alerted
            const pendingEvents = await EconomicEvent.find({
                impact: 'High',
                date: { $gte: now, $lte: alertWindow },
                isAlertSent: false
            });

            if (pendingEvents.length === 0) return;

            logger.info(`ECONOMIC: Found ${pendingEvents.length} high-impact events for alert.`);

            for (const event of pendingEvents) {
                try {
                    // Send alert to all users via notification service
                    await notificationService.sendEconomicAlert({
                        event: event.event,
                        country: event.country,
                        currency: event.currency,
                        impact: event.impact,
                        date: event.date,
                        actual: event.actual,
                        forecast: event.forecast,
                        previous: event.previous
                    });

                    // Mark as alerted
                    event.isAlertSent = true;
                    await event.save();

                    logger.info(`ECONOMIC: Alert sent for ${event.event} (${event.currency})`);

                } catch (eventError) {
                    logger.error(`ECONOMIC: Failed to send alert for ${event.event}:`, eventError.message);
                }
            }

            logger.info(`ECONOMIC: Completed alert check - ${pendingEvents.length} alerts sent`);

        } catch (error) {
            logger.error('ECONOMIC: Alert check failed', error);
        }
    }
}

export const economicService = new EconomicService();
</file>

<file path="src/services/email.service.js">
import { msg91Service } from './index.js';
import logger from '../config/logger.js';

/**
 * Send Email using MSG91
 * @param {string} to - Recipient Email
 * @param {string} subject - Email Subject
 * @param {string} text - Email Body
 * @param {string} html - Optional HTML body (Currently mapped to same VAR)
 * @returns {Promise<boolean>}
 */
const sendEmail = async (to, subject, text, html = null) => {
  const body = html || text;
  return await msg91Service.sendEmail(to, subject, body);
};

/**
 * Send OTP via Email (MSG91 Template)
 * @param {string} to 
 * @param {string} otp 
 * @returns {Promise<boolean>}
 */
const sendEmailOtp = async (to, otp) => {
    return await msg91Service.sendEmailOtp(to, otp);
};


const sendPushNotification = async (tokens, title, body) => {
    // Keeping this placeholder wrapper for consistency
    logger.info(`[PUSH] To: ${tokens?.length} devices, Title: ${title}, Body: ${body}`);
    return true;
};

export {
  sendEmail,
  sendEmailOtp,
  sendPushNotification,
};
</file>

<file path="src/services/fmp.service.js">
import axios from 'axios';
import marketDataService from './marketData.service.js';
import logger from '../config/logger.js';

class FmpService {
    constructor() {
        this.baseUrl = 'https://financialmodelingprep.com/api/v3';
    }

    get apiKey() {
        return marketDataService.config.fmp_api_key;
    }

    /**
     * Get News for a specific symbol or general market
     * @param {String} symbol 
     * @param {Number} limit 
     */
    async getNews(symbol, limit = 10) {
        if (!this.apiKey) {
            logger.warn('FMP API Key not configured');
            return [];
        }

        try {
            let url = '';
            const baseUrl = 'https://financialmodelingprep.com/stable';

            if (symbol) {
                 // Asset Type Detection & Symbol Cleanup
                 let querySymbol = symbol;
                 // NSE:RELIANCE -> RELIANCE.NS
                 if (symbol.startsWith('NSE:')) querySymbol = symbol.replace('NSE:', '') + '.NS';
                 else if (symbol.startsWith('BSE:')) querySymbol = symbol.replace('BSE:', '') + '.BO';
                 
                 // Crypto detection (USDT -> USD)
                 let isCrypto = false;
                 if (symbol.includes('USDT') || (symbol.endsWith('USD') && !symbol.includes('.'))) {
                     isCrypto = true;
                     if (querySymbol.endsWith('USDT')) querySymbol = querySymbol.replace('USDT', 'USD');
                 }

                 let isForex = !isCrypto && !symbol.includes('.') && symbol.length === 6 && !symbol.startsWith('NSE');

                 if (isCrypto) {
                      // Crypto News Search
                      url = `${baseUrl}/news/crypto?symbols=${querySymbol}&limit=${limit}&apikey=${this.apiKey}`;
                 } else if (isForex) {
                      // Forex News Search
                      url = `${baseUrl}/news/forex?symbols=${querySymbol}&limit=${limit}&apikey=${this.apiKey}`;
                 } else {
                      // Stock News Search
                      url = `${baseUrl}/news/stock?symbols=${querySymbol}&limit=${limit}&apikey=${this.apiKey}`;
                 }
            } else {
                 // General News
                 url = `${baseUrl}/news/general-latest?limit=${limit}&apikey=${this.apiKey}`;
            }

            const response = await axios.get(url);
            return response.data;

        } catch (error) {
            logger.error(`FMP News Error for ${symbol}: ${error.message}`);
            if (error.response && error.response.data) {
                logger.error(`FMP Error Data: ${JSON.stringify(error.response.data)}`);
            }
            return [];
        }
    }
}

export default new FmpService();
</file>

<file path="src/services/hybridStrategy.service.js">
import marketDataService from './marketData.service.js';
import technicalAnalysisService from './technicalAnalysis.service.js';
import signalService from './signal.service.js';
import logger from '../config/logger.js';
import Strategy from '../models/Strategy.js';
import Signal from '../models/Signal.js';
import EventEmitter from 'events';
import { broadcastToRoom, broadcastToAll } from './websocket.service.js';

class HybridStrategyService extends EventEmitter {
    constructor() {
        super();
        
        // Multi-Timeframe State
        this.timeframes = ['5m', '15m', '1h']; // Client Priority
        this.tfMapSeconds = { 
            '1m': 60, 
            '3m': 180, 
            '5m': 300, 
            '15m': 900, 
            '30m': 1800, 
            '1h': 3600, 
            '4h': 14400,
            '1D': 86400 
        };
        
        this.state = {};
        this.timeframes.forEach(tf => {
            this.state[tf] = {
                candles: {},
                status: {},
                fetching: {}
            };
        });

        this.MAX_CANDLES = 200; // Keep last 200 candles
        this.strategyId = null;
        this.strategyConfig = null;

        // Active Tracked Signals for Trailing SL
        this.activeSignals = new Map(); // Key: symbol_tf, Value: signalDoc
    }

    async start() {
        logger.info('üöÄ Hybrid Strategy Engine Started (Multi-Timeframe Mode)');
        
        // Find or Seed the System Strategy to get its ID
        try {
            let hybrid = await Strategy.findOne({ name: 'Hybrid Strategy', isSystem: true });
            
            if (hybrid) {
                this.strategyId = hybrid._id;
                this.strategyConfig = hybrid;
                
                // Hot Reload Config
                setInterval(async () => {
                    try {
                        const fresh = await Strategy.findOne({ _id: this.strategyId });
                        if (fresh) this.strategyConfig = fresh;
                    } catch (e) { console.error('Config Reload Failed', e); }
                }, 10000); 
            }
        } catch (e) {
            logger.error('Failed to fetch Hybrid Strategy info', e);
        }

        marketDataService.on('price_update', this.handleTick.bind(this));
    }

    async handleTick(tick) {
        const { symbol, price, timestamp } = tick;
        
        // Iterate over ALL active timeframes
        for (const tf of this.timeframes) {
            this.processTimeframeTick(tf, symbol, price, timestamp);
        }
    }

    async processTimeframeTick(tf, symbol, price, timestamp) {
        const tfState = this.state[tf];
        
        // Lazy load history if missing
        if (!tfState.candles[symbol] && !tfState.fetching[symbol]) {
             await this.loadHistory(tf, symbol);
        }
        
        // Update Candle Logic
        this.updateCandle(tf, symbol, price, timestamp);
    }

    async loadHistory(tf, symbol) {
        const tfState = this.state[tf];
        if (tfState.fetching[symbol]) return;
        
        tfState.fetching[symbol] = true;
        
        try {
            // logger.debug(`üìö Pre-loading ${tf} history for ${symbol}...`);
            const seconds = this.tfMapSeconds[tf];
            const resolution = (seconds / 60).toString(); 
            
            const to = new Date();
            // Fetch enough data for 200 candles
            const from = new Date(to.getTime() - (this.MAX_CANDLES * seconds * 1000)); 
            
            const toTs = Math.floor(to.getTime() / 1000);
            const fromTs = Math.floor(from.getTime() / 1000);

            const history = await marketDataService.getHistory(
                symbol, 
                resolution, 
                fromTs, 
                toTs,
                3 // Priority 3 for background priming
            );

            if (history && history.length > 0) {
                 tfState.candles[symbol] = history.map(h => ({
                     time: h.time * 1000, 
                     open: h.open,
                     high: h.high,
                     low: h.low,
                     close: h.close
                 })).slice(-this.MAX_CANDLES);
                 
            } else {
                 tfState.candles[symbol] = []; 
            }
        } catch (e) {
            logger.error(`‚ùå Failed to prime ${tf} history for ${symbol}: ${e.message}`);
            tfState.candles[symbol] = [];
        } finally {
            tfState.fetching[symbol] = false;
        }
    }

    updateCandle(tf, symbol, price, timestamp) {
        const tfState = this.state[tf];
        if (!tfState.candles[symbol]) return;

        const candleSizeSec = this.tfMapSeconds[tf];
        const now = new Date(timestamp).getTime();
        const currentCandles = tfState.candles[symbol];
        const lastCandle = currentCandles[currentCandles.length - 1];

        // Align to boundary
        const candleTime = Math.floor(now / (candleSizeSec * 1000)) * (candleSizeSec * 1000);

        let isNewCandle = false;

        if (!lastCandle || lastCandle.time < candleTime) {
            // New Candle
            isNewCandle = true;
            tfState.candles[symbol].push({
                time: candleTime,
                open: price,
                high: price,
                low: price,
                close: price
            });
            
            if (tfState.candles[symbol].length > this.MAX_CANDLES) {
                tfState.candles[symbol].shift();
            }
        } else {
            // Update existing
            lastCandle.high = Math.max(lastCandle.high, price);
            lastCandle.low = Math.min(lastCandle.low, price);
            lastCandle.close = price;
        }

        // Evaluate Strategy
        this.evaluateStrategy(tf, symbol, price, isNewCandle);
        
        // --- TRAILING STOP LOSS CHECK ---
        this.handleTrailingSL(tf, symbol, price, isNewCandle);
    }

    convertToHeikinAshi(candles) {
        if (!candles || candles.length === 0) return [];
        
        const haCandles = [];
        haCandles.push({ ...candles[0] });

        for (let i = 1; i < candles.length; i++) {
            const curr = candles[i];
            const prevHa = haCandles[i - 1];

            const haOpen = (prevHa.open + prevHa.close) / 2;
            const haClose = (curr.open + curr.high + curr.low + curr.close) / 4;
            const haHigh = Math.max(curr.high, haOpen, haClose);
            const haLow = Math.min(curr.low, haOpen, haClose);

            haCandles.push({
                time: curr.time,
                open: haOpen,
                high: haHigh,
                low: haLow,
                close: haClose
            });
        }
        return haCandles;
    }

    evaluateStrategy(tf, symbol, price, isNewCandle) {
        if (!isNewCandle) return; // Only trigger on Close of previous candle / Open of new

        const tfState = this.state[tf];
        const stdCandles = tfState.candles[symbol];
        const haCandles = this.convertToHeikinAshi(stdCandles);

        if (haCandles.length < 5) return;

        // Sequence: 
        const idxCurrent = haCandles.length - 2; // Last Closed Candle
        const idxPrev = haCandles.length - 3;    // Candle before that
        const idxPrevPrev = haCandles.length - 4; // Three candles back
        
        if (idxPrevPrev < 0) return;

        const st = technicalAnalysisService.calculateSupertrend(haCandles, 14, 1.5);
        const psar = technicalAnalysisService.calculatePSAR(haCandles);
        const structure = technicalAnalysisService.calculateMarketStructure(haCandles, 5);

        // Usage Check Helper
        const isWickValid = (candle, type) => {
            const bodySize = Math.abs(candle.close - candle.open);
            const totalSize = candle.high - candle.low;
            if (totalSize === 0) return true;

            if (type === 'BUY') {
                const upperWick = candle.high - Math.max(candle.open, candle.close);
                const lowerWick = Math.min(candle.open, candle.close) - candle.low;
                const isLowerWickSmall = lowerWick <= (totalSize * 0.2); 
                return upperWick > 0 && isLowerWickSmall;
            } else {
                const lowerWick = Math.min(candle.open, candle.close) - candle.low;
                const upperWick = candle.high - Math.max(candle.open, candle.close);
                const isUpperWickSmall = upperWick <= (totalSize * 0.2);
                return lowerWick > 0 && isUpperWickSmall;
            }
        };

        const currentCandle = haCandles[idxCurrent];
        const prevCandle = haCandles[idxPrev];
        
        let signal = null;
        let entryType = ''; // 'Fast' or 'Confirmed'
        let sl = 0;
        let tp = 0;

        // --- BUY LOGIC ---
        const isTrendUpNow = st.trendArray[idxCurrent] === 1;
        const wasTrendDownPrev = st.trendArray[idxPrev] === -1;
        const wasTrendDownPrevPrev = st.trendArray[idxPrevPrev] === -1;

        // 1. Fast Entry (Entry on 2nd Candle Open - immediately after flip)
        if (isTrendUpNow && wasTrendDownPrev && price > psar.value) {
            signal = 'BUY';
            entryType = 'Fast';
        } 
        // 2. Confirmed Entry (Entry on 3rd Candle Open - original rule)
        else if (isTrendUpNow && !wasTrendDownPrev && wasTrendDownPrevPrev && price > psar.value) {
            const isConfirmGreen = currentCandle.close > currentCandle.open;
            if (isConfirmGreen && isWickValid(currentCandle, 'BUY')) {
                 if (structure.structure === 'HH_HL' || structure.structure === 'expanding') {
                     signal = 'BUY';
                     entryType = 'Confirmed';
                 }
            }
        }

        if (signal === 'BUY') {
            sl = st.value; 
            const risk = price - sl;
            tp = price + (risk * 2);
        }

        // --- SELL LOGIC ---
        if (!signal) {
            const isTrendDownNow = st.trendArray[idxCurrent] === -1;
            const wasTrendUpPrev = st.trendArray[idxPrev] === 1;
            const wasTrendUpPrevPrev = st.trendArray[idxPrevPrev] === 1;

            // 1. Fast Entry
            if (isTrendDownNow && wasTrendUpPrev && price < psar.value) {
                signal = 'SELL';
                entryType = 'Fast';
            } 
            // 2. Confirmed Entry
            else if (isTrendDownNow && !wasTrendUpPrev && wasTrendUpPrevPrev && price < psar.value) {
                const isConfirmRed = currentCandle.close < currentCandle.open;
                if (isConfirmRed && isWickValid(currentCandle, 'SELL')) {
                     if (structure.structure === 'LH_LL' || structure.structure === 'expanding') {
                         signal = 'SELL';
                         entryType = 'Confirmed';
                     }
                }
            }

            if (signal === 'SELL') {
                sl = st.value;
                const risk = sl - price;
                tp = price - (risk * 2);
            }
        }

        if (signal) {
            const risk = Math.abs(price - sl);
            const targets = {
                t1: parseFloat((signal === 'BUY' ? price + risk : price - risk).toFixed(2)),
                t2: parseFloat(tp.toFixed(2))
            };

            const notes = `Hybrid Strategy (${tf}): ${entryType} Entry (Price vs PSAR confirmed). ` + 
                         `Scaling: 5-6 candles (Partial), 10-12 candles (Full if slow).`;
            
            const metrics = { 
                notes, 
                timeframe: tf,
                entryType,
                scalingRules: {
                    partial: '5-6 candles (~30 min)',
                    full: '10-12 candles (~1 hour)'
                }
            };
            this.processSignal(tf, symbol, signal, price, sl, targets, metrics);
        }
    }

    async handleTrailingSL(tf, symbol, price, isNewCandle) {
        const key = `${symbol}_${tf}`;
        
        // 1. Check if we have an active signal cached for this TF
        let signal = this.activeSignals.get(key);
        
        // 2. If not in cache, try fetching from DB (Lazy Load)
        if (!signal) {
            signal = await Signal.findOne({ 
                symbol, 
                timeframe: tf, 
                status: 'Active',
                strategyName: 'Hybrid Strategy'
            });
            if (signal) {
                this.activeSignals.set(key, signal);
            }
        }

        if (!signal || signal.status !== 'Active') return;

        // 3. Update Stop Loss on every New Candle
        const tfState = this.state[tf];
        const haCandles = this.convertToHeikinAshi(tfState.candles[symbol]);
        if (haCandles.length < 5) return;

        const st = technicalAnalysisService.calculateSupertrend(haCandles, 14, 1.5);
        const currentST = st.value;
        const currentTrend = st.trend; // 1 for Bullish, -1 for Bearish

        let shouldUpdate = false;
        let newSL = signal.stopLoss;

        if (signal.type === 'BUY') {
            // Trend must remain Bullish
            if (currentTrend === 1 && currentST > signal.stopLoss) {
                newSL = parseFloat(currentST.toFixed(2));
                shouldUpdate = true;
            }
            // Exit if price crosses ST line (Trend Flip)
            if (currentTrend === -1 || price < currentST) {
                await this.closeSignal(signal, price, 'Trailing SL Hit (Trend Flip)');
                this.activeSignals.delete(key);
                return;
            }
        } else if (signal.type === 'SELL') {
            // Trend must remain Bearish
            if (currentTrend === -1 && currentST < signal.stopLoss) {
                newSL = parseFloat(currentST.toFixed(2));
                shouldUpdate = true;
            }
            // Exit if price crosses ST line
            if (currentTrend === 1 || price > currentST) {
                await this.closeSignal(signal, price, 'Trailing SL Hit (Trend Flip)');
                this.activeSignals.delete(key);
                return;
            }
        }

        if (shouldUpdate && isNewCandle) {
            signal.stopLoss = newSL;
            await Signal.findByIdAndUpdate(signal._id, { stopLoss: newSL });
            logger.info(`üìâ [TRAILING SL] Updated ${symbol} (${tf}) SL to ${newSL}`);
            // Broadcast update via existing service logic (signalService handles this usually)
            // But we can call signalService.updateSignalById for full effect
            const { default: signalService } = await import('./signal.service.js');
            await signalService.updateSignalById(signal._id, { stopLoss: newSL });
        }
    }

    async closeSignal(signal, price, reason) {
        logger.info(`üö™ [EXIT] Closing ${signal.symbol} (${signal.timeframe}) @ ${price} - Reason: ${reason}`);
        const { default: signalService } = await import('./signal.service.js');
        await signalService.updateSignalById(signal._id, { 
            status: 'Closed',
            'report.closedPrice': price,
            'report.closedAt': new Date(),
            notes: (signal.notes || '') + `\n[Auto] ${reason} @ ${price}`
        });
    }
    
    async processSignal(tf, symbol, type, price, sl, targets, metrics) {
        if (!this.processingPending) this.processingPending = {};
        const pendingKey = `${symbol}_${tf}_${type}`; // Unique per TF
        
        if (this.processingPending[pendingKey]) return;
        this.processingPending[pendingKey] = true;
        
        const tfState = this.state[tf];
        const COOLDOWN_MS = 15 * 60 * 1000; 
        
        const lastStatus = tfState.status[symbol];

        if (lastStatus?.lastSignal && lastStatus.lastSignal.type === type) {
            const timeDiff = new Date() - new Date(lastStatus.lastSignal.timestamp);
            if (timeDiff < COOLDOWN_MS) {
                delete this.processingPending[pendingKey];
                return;
            }
        }

        try {
            // DB Deduplication with Timeframe Check
            const existing = await Signal.findOne({
                symbol: symbol,
                type: type,
                timeframe: tf, // Constraint by Timeframe
                createdAt: { $gt: new Date(Date.now() - COOLDOWN_MS) }
            });

            if (existing) {
                logger.warn(`Duplicate ${tf} signal prevented for ${symbol}`);
                if (tfState.status[symbol]) {
                    tfState.status[symbol].lastSignal = { ...existing.toObject(), timestamp: existing.createdAt };
                }
                delete this.processingPending[pendingKey];
                return;
            }

            logger.info(`üî• HYBRID SIGNAL [${tf}]: ${type} on ${symbol} @ ${price}`);
            
            const systemUser = { id: null }; 
            
            await signalService.createSignal({
                strategyId: this.strategyId,
                strategyName: 'Hybrid Strategy',
                timeframe: tf, // Pass explicit TF
                metrics: metrics,
                symbol,
                segment: this.mapSegment(symbol),
                type,
                entryPrice: price,
                stopLoss: parseFloat(sl.toFixed(2)),
                targets: { 
                    target1: targets.t1,
                    target2: targets.t2 
                },
                notes: metrics.notes,
                status: 'Active'
            }, systemUser);
            
            if (this.strategyId) {
                await Strategy.findByIdAndUpdate(this.strategyId, {
                    $inc: { 'stats.totalSignals': 1 },
                    'stats.lastSignalAt': new Date()
                });
            }

            // Update Memory Status
            if (!this.state[tf].status[symbol]) this.state[tf].status[symbol] = {};
            this.state[tf].status[symbol].lastSignal = { 
                type, timestamp: new Date() 
            };

        } catch (e) {
            logger.error(`Error persisting signal for ${symbol}`, e);
        } finally {
            delete this.processingPending[pendingKey];
        }
    }

    mapSegment(symbol) {
        if (!symbol.includes(':')) return 'EQUITY';
        const [exchange, sym] = symbol.split(':');
        const map = {
            'NSE': 'FNO', 'BSE': 'EQUITY', 'MCX': 'COMMODITY',
            'CDS': 'CURRENCY', 'BINANCE': 'CRYPTO', 'BITSTAMP': 'CRYPTO'
        };
        if (exchange === 'NSE' && sym.endsWith('-EQ')) return 'EQUITY';
        return map[exchange] || 'EQUITY';
    }

    getLiveStatus(symbol) {
        // Return aggregation of all TFs
        const result = {};
        this.timeframes.forEach(tf => {
            result[tf] = this.state[tf].status[symbol] || {};
        });
        return result;
    }
}

export const hybridStrategyService = new HybridStrategyService();
export default hybridStrategyService;
</file>

<file path="src/services/index.js">
import authService from './auth.service.js';
import msg91Service from './msg91.service.js';
import tokenService from './token.service.js';
import userService from './user.service.js';
import planService from './plan.service.js';
import transactionService from './transaction.service.js';
import subscriptionService from './subscription.service.js';
import signalService from './signal.service.js';
import dashboardService from './dashboard.service.js';
import subBrokerService from './subBroker.service.js';
import settingService from './setting.service.js';
import strategyService from './strategy.service.js';
import marketDataService from './marketData.service.js';
import announcementService from './announcement.service.js';
import { economicService } from './economic.service.js';
import * as emailService from './email.service.js';
import allTickService from './alltick.service.js';
import technicalAnalysisService from './technicalAnalysis.service.js';


export { 
    authService, 
    tokenService, 
    userService, 
    planService, 
    transactionService, 
    subscriptionService, 
    signalService, 
    dashboardService, 
    subBrokerService, 
    settingService, 
    strategyService, 
    marketDataService,
    announcementService,
    economicService,
    msg91Service,
    emailService,
    allTickService,
    technicalAnalysisService
};
</file>

<file path="src/services/kite.service.js">
import { KiteConnect, KiteTicker } from 'kiteconnect';
import logger from '../config/logger.js';

class KiteService {
    constructor() {
        this.kite = null;
        this.ticker = null;
        this.apiKey = null;
        this.apiSecret = null;
        this.accessToken = null;
        this.isTickerConnected = false;
        this.subscriptions = [];
        this.callbacks = {
            onTick: () => {},
            onConnect: () => {},
            onError: () => {}
        };
    }

    /**
     * Initialize the service with API credentials
     */
    initialize(apiKey, apiSecret) {
        if (!apiKey || !apiSecret) {
            throw new Error('API Key and Secret are required for KiteService');
        }
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        
        this.kite = new KiteConnect({
            api_key: this.apiKey,
        });

        logger.info('KiteService initialized with API Key');
    }

    /**
     * Generate the login URL for the user to authenticate
     */
    getLoginUrl() {
        if (!this.kite) return null;
        return this.kite.getLoginURL();
    }

    async generateSession(requestToken) {
        if (!this.kite || !this.apiSecret) throw new Error('KiteService not initialized');
        
        try {
            logger.info('Exchanging Kite Request Token for Session...');
            const response = await this.kite.generateSession(requestToken, this.apiSecret);
            this.accessToken = response.access_token;
            this.kite.setAccessToken(this.accessToken);
            
            logger.info(`Kite Session Generated Successfully for Client: ${response.user_id}`);
            return response;
        } catch (error) {
            const errorMsg = error.message || 'Unknown Kite Error';
            logger.error(`Kite Session Generation Failed: ${errorMsg}`, { error });
            throw new Error(`Kite Login Failed: ${errorMsg}`);
        }
    }

    /**
     * Fetch Historical Data (Candles)
     * Requires "Historical API" add-on in Kite Connect
     */
    async getHistoricalData(instrumentToken, interval, from, to, continuous = false) {
        if (!this.kite || !this.accessToken) throw new Error('Kite not authenticated');
        
        try {
            logger.info(`Fetching Kite History: Token=${instrumentToken}, Interval=${interval}, From=${from}, To=${to}`);
            
            // Kite expects Date objects
            const fromDate = new Date(from);
            const toDate = new Date(to);
            
            const candles = await this.kite.getHistoricalData(instrumentToken, interval, fromDate, toDate, continuous);
            
            // Format to standard OHLCV if needed (Kite returns: [{ date, open, high, low, close, volume }])
            if (candles.length > 0) {
                 logger.info(`[KITE_RAW_DEBUG] Candle 0: ${JSON.stringify(candles[0])}`);
                 logger.info(`[KITE_RAW_DEBUG] Date type: ${typeof candles[0].date}`);
            }
            return candles
                .filter(c => c.open > 0 && c.high > 0 && c.low > 0 && c.close > 0) // Filter invalid prices
                .map(c => ({
                    time: new Date(c.date).getTime() / 1000,
                    open: c.open,
                    high: Math.max(c.high, c.open, c.close), // Ensure High is actually High
                    low: Math.min(c.low, c.open, c.close),   // Ensure Low is actually Low
                    close: c.close,
                    volume: c.volume || 0
                }));
        } catch (error) {
            logger.error(`Kite History Fetch Error: ${error.message}`, { instrumentToken, interval });
            throw error;
        }
    }

    /**
     * Fetch Master Instrument List from Zerodha
     * Returns a massive array of all tradable instruments
     */
    async getInstruments() {
        if (!this.kite) throw new Error('Kite not initialized');
        try {
            logger.info('Fetching Kite Master Instrument List (CSV)...');
            const instruments = await this.kite.getInstruments();
            logger.info(`Fetched ${instruments.length} instruments from Zerodha`);
            return instruments;
        } catch (error) {
            logger.error(`Kite Instrument Fetch Failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Get Last Traded Price (LTP) for instruments
     * @param {Array} instruments - Array of strings e.g. ['NSE:RELIANCE', 'MCX:CRUDEOIL']
     */
    async getLTP(instruments) {
        if (!this.kite || !this.accessToken) throw new Error('Kite not authenticated');
        try {
            // instruments should be array of "EXCHANGE:TRADINGSYMBOL"
            const response = await this.kite.getLTP(instruments);
            return response;
        } catch (error) {
            logger.error(`getLTP Failed: ${error.message}`);
            return {};
        }
    }

    /**
     * Get Full Quote (LTP, OHLC, Depth)
     */
    async getQuote(instruments) {
        if (!this.kite || !this.accessToken) throw new Error('Kite not authenticated');
        try {
            const response = await this.kite.getQuote(instruments);
            return response;
        } catch (error) {
            logger.error(`getQuote Failed: ${error.message}`);
            return {};
        }
    }

    /**
     * Set Access Token manually (if loaded from DB/Cache)
     */
    setAccessToken(token) {
        this.accessToken = token;
        if (this.kite) {
            this.kite.setAccessToken(token);
        }
    }

    /**
     * Connect to Kite Ticker (WebSocket)
     */
    connectTicker(onTickCallback, onConnectCallback) {
        if (!this.apiKey || !this.accessToken) {
            logger.error('Cannot connect ticker: Missing credentials');
            return;
        }

        // Cleanup previous instance properly
        if (this.ticker) {
            logger.info('Ticker already exists, performing cleanup before reconnecting...');
            
            // Explicitly remove all bound listeners to prevent memory leaks
            // We must use the exact same function references if we bound them, but here we used implicit binds or anonymous functions in previous code.
            // Paradox: if we bound them with .bind(this), we created new functions.
            // Soln: In this refactor, we will store the bound functions to remove them correctly, 
            // OR rely on disconnect() if KiteTicker internally removes them (it usually doesn't remove external listeners).
            
            // To be safe, we will just force disconnect (which typically closes the socket). 
            // The garbage collector should take the old instance if we overwrite `this.ticker`.
            // But if KiteConnect keeps global refs, we might leak.
            // Best practice: disconnect() is usually enough IF we overwrite the reference.
            // BUT, user complained about listener accumulation.
            
            try {
                this.ticker.disconnect();
                
                // Hack: KiteTicker (v3) might not expose removeAllListeners if it's not a standard EventEmitter. 
                // Checks show it typically is.
                // If it inherits from EventEmitter:
                // this.ticker.removeAllListeners(); 
            } catch (e) {
                logger.error('Error disconnecting Kite Ticker:', e);
            }
        }

        this.callbacks.onTick = onTickCallback;
        if (onConnectCallback) this.callbacks.onConnect = onConnectCallback;

        try {
            this.ticker = new KiteTicker({
                api_key: this.apiKey,
                access_token: this.accessToken
            });

            this.ticker.autoReconnect(true, 10, 5);

            // Store bound functions to ensure we *could* remove them if we didn't destroy usage
            // But here we rely on creating a fresh instance.
            this.ticker.on('ticks', this.handleTicks.bind(this));
            this.ticker.on('connect', this.handleConnect.bind(this));
            this.ticker.on('disconnect', this.handleDisconnect.bind(this));
            
            // Defined inline in previous code, moving to method for cleanliness? 
            // Keeping inline to minimize diff but fixing the listener accumulation via 'new instance' 
            // The user said "reconnect logic creates zombie connections".
            // If we create `new KiteTicker`, the old one becomes a zombie if `disconnect` didn't kill it fully.
            
            this.ticker.on('error', (error) => {
                const errorStr = JSON.stringify(error, Object.getOwnPropertyNames(error));
                logger.error(`Kite Ticker Error (Type: ${typeof error}): ${errorStr}`);
                
                if (errorStr.includes('403') || (error && error.message && error.message.includes('403'))) {
                    logger.error('Kite Ticker 403 Forbidden - Stopping Reconnection Attempts');
                    try {
                        this.ticker.autoReconnect(false);
                        this.ticker.disconnect();
                    } catch (e) {}
                    this.isTickerConnected = false;
                }
            });

            this.ticker.on('reconnecting', (attempt) => logger.warn(`Kite Ticker Reconnecting (Attempt ${attempt})...`));
            this.ticker.on('noreconnect', () => logger.error('Kite Ticker gave up reconnecting'));

            this.ticker.connect();
        } catch (error) {
            logger.error('Failed to initialize or connect Kite Ticker:', error);
            this.isTickerConnected = false;
        }
    }

    handleTicks(ticks) {
        // Normalize ticks if necessary or pass raw
        // Kite ticks format: [{ instrument_token, last_price, ... }]
        if (ticks && ticks.length > 0) {
             logger.info(`[KITE_SERVICE] Ticks Received: ${ticks.length}`);
        }
        if (this.callbacks.onTick) {
            this.callbacks.onTick(ticks);
        }
    }

    handleConnect() {
        logger.info('Kite Ticker Connected');
        this.isTickerConnected = true;
        
        // Resubscribe if needed
        if (this.subscriptions.length > 0) {
            this.subscribe(this.subscriptions);
        }

        if (this.callbacks.onConnect) {
            this.callbacks.onConnect();
        }
    }

    handleDisconnect() {
        logger.warn('Kite Ticker Disconnected');
        this.isTickerConnected = false;
    }

    subscribe(instrumentTokens) {
        if (!this.ticker || !this.isTickerConnected) {
            logger.warn('Ticker not connected, queuing subscriptions');
            // Add unique tokens to subscription list
            const newTokens = instrumentTokens.filter(t => !this.subscriptions.includes(t));
            this.subscriptions = [...this.subscriptions, ...newTokens];
            return;
        }

        const tokensToSubscribe = instrumentTokens.map(t => parseInt(t));
        this.ticker.subscribe(tokensToSubscribe);
        this.ticker.setMode(this.ticker.modeFull, tokensToSubscribe);
        
        // Update local list
        const newTokens = instrumentTokens.filter(t => !this.subscriptions.includes(t));
        this.subscriptions = [...this.subscriptions, ...newTokens];
        
        logger.info(`Subscribed to ${tokensToSubscribe.length} tokens`);
    }

    unsubscribe(instrumentTokens) {
        if (!this.ticker || !this.isTickerConnected) return;
        const tokensToUnsub = instrumentTokens.map(t => parseInt(t));
        this.ticker.unsubscribe(tokensToUnsub);
        
        // Remove from local list
        this.subscriptions = this.subscriptions.filter(t => !tokensToUnsub.includes(parseInt(t)));
    }
}

export const kiteService = new KiteService();
export default KiteService;
</file>

<file path="src/services/kiteInstruments.service.js">
import fs from 'fs';
import path from 'path';
import { kiteService } from './kite.service.js';
import logger from '../config/logger.js';
import MasterSymbol from '../models/MasterSymbol.js';

const INSTRUMENTS_FILE = path.join(process.cwd(), 'data', 'kite_instruments.json');

class KiteInstrumentsService {
    constructor() {
        this.instruments = null;
        this.instrumentMap = new Map(); // token -> symbol
        this.symbolMap = new Map();     // symbol -> instrument object
    }

    /**
     * Sync instruments from Zerodha and save locally
     */
    async syncFromZerodha() {
        try {
            logger.info('KITE_SYNC: Starting daily instrument sync...');
            
            // Ensure data directory exists
            const dataDir = path.dirname(INSTRUMENTS_FILE);
            if (!fs.existsSync(dataDir)) {
                fs.mkdirSync(dataDir, { recursive: true });
            }

            const instruments = await kiteService.getInstruments();
            if (!instruments || instruments.length === 0) {
                throw new Error('Received empty instrument list from Zerodha');
            }

            // Save to local file system for fast loading (avoid bloating MongoDB unnecessarily)
            fs.writeFileSync(INSTRUMENTS_FILE, JSON.stringify(instruments));
            
            logger.info(`KITE_SYNC: Successfully synced ${instruments.length} instruments to ${INSTRUMENTS_FILE}`);
            
            // Reload into memory
            await this.loadIntoMemory();
            
            return { count: instruments.length };
        } catch (error) {
            logger.error(`KITE_SYNC: Sync failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Load instruments from local file into memory maps
     */
    async loadIntoMemory() {
        try {
            if (!fs.existsSync(INSTRUMENTS_FILE)) {
                logger.warn('KITE_SYNC: No local instrument file found. Sync required.');
                return;
            }

            logger.info('KITE_SYNC: Loading instruments into memory...');
            const data = fs.readFileSync(INSTRUMENTS_FILE, 'utf8');
            const instruments = JSON.parse(data);

            this.instrumentMap.clear();
            this.symbolMap.clear();

            for (const inst of instruments) {
                // We use EXCHANGE:SYMBOL format for consistency
                const fullSymbol = `${inst.exchange}:${inst.tradingsymbol}`;
                this.instrumentMap.set(inst.instrument_token.toString(), fullSymbol);
                this.symbolMap.set(fullSymbol, inst);
            }

            logger.info(`KITE_SYNC: Loaded ${this.instrumentMap.size} instruments into memory maps`);
        } catch (error) {
            logger.error(`KITE_SYNC: Failed to load instruments: ${error.message}`);
        }
    }

    /**
     * Get instrument details by full symbol (EXCHANGE:TRADINGSYMBOL)
     */
    getInstrumentBySymbol(symbol) {
        return this.symbolMap.get(symbol);
    }

    /**
     * Get full symbol by token
     */
    getSymbolByToken(token) {
        return this.instrumentMap.get(token.toString());
    }

    /**
     * Search instruments by query
     */
    /**
     * Search instruments by query
     */
    search(query, limit = 50) { // Increased limit
        const results = [];
        const q = query.toUpperCase();
        
        // Priority buckets
        const exactMatches = [];
        const startsWithMatches = [];
        const containsMatches = [];

        for (const [symbol, inst] of this.symbolMap.entries()) {
            // Optimization: Skip checking if we have enough, but we want quality results so we check all or meaningful subset
            // For performance on 100k+ items, we might need an index. But for 3-5k items loop is fine.
            // Kite has ~100k instruments. This loop might be heavy. 
            // We should trust the loop but break early if we have enough HIGH QUALITY matches.
            
            const s = symbol.toUpperCase();
            const n = (inst.name || '').toUpperCase();
            
            if (s.includes(q) || n.includes(q)) {
                // Formatting
                const item = {
                    symbol,
                    name: inst.name,
                    exchange: inst.exchange,
                    instrumentToken: inst.instrument_token,
                    segment: inst.segment,
                    lotSize: inst.lot_size,
                    tickSize: inst.tick_size
                };

                // Ranking Logic
                // 1. Exact Match on Trading Symbol
                if (inst.tradingsymbol === q) {
                    exactMatches.push(item);
                } 
                // 2. Exact Match on Name
                else if (inst.name.toUpperCase() === q) {
                    exactMatches.push(item);
                }
                // 3. Equity / Index Priority (NSE/BSE)
                else if (inst.segment === 'NSE' || inst.segment === 'BSE' || inst.segment === 'INDICES') {
                     if (s.startsWith(q)) startsWithMatches.push(item);
                     else containsMatches.push(item);
                }
                // 4. Closest Futures (Current Month)
                else if (inst.segment === 'NFO-FUT' || inst.segment === 'MCX-FUT') {
                     // Prioritize near month? Complex. Just treat as normal startsWith
                     if (s.startsWith(q)) startsWithMatches.push(item);
                     else containsMatches.push(item);
                }
                // 5. Rest
                else {
                    containsMatches.push(item);
                }
            }
        }

        // Combine and Slice
        // We want Exact -> StartsWith (Equity) -> StartsWith (Others) -> Contains
        // But the logic above grouped all StartsWith together.
        // Let's simplified sort:
        const sorted = [...exactMatches, ...startsWithMatches, ...containsMatches];
        return sorted.slice(0, limit);
    }
}

export const kiteInstrumentsService = new KiteInstrumentsService();
export default kiteInstrumentsService;
</file>

<file path="src/services/marketData.service.js">
import requestQueue from '../utils/requestQueue.js'; // Move to top
import EventEmitter from 'events'; // Restart Trigger
import Setting from '../models/Setting.js';
import MasterSymbol from '../models/MasterSymbol.js';
import { kiteService } from './kite.service.js';
import { kiteInstrumentsService } from './kiteInstruments.service.js';
import { allTickService } from './alltick.service.js';
import { economicService } from './economic.service.js';
import pipeline from '../utils/pipeline/DataPipeline.js'; // Pipeline Optimization
import { redisClient } from './redis.service.js';
import logger from '../config/logger.js';
import { decrypt, encrypt } from '../utils/encryption.js';
import websocketManager from './websocketManager.js';
import startupOptimizer from './startupOptimizer.js';
import cacheManager from './cacheManager.js';

console.log('DEBUG: MarketDataService loaded. RequestQueue:', requestQueue);

class MarketDataService extends EventEmitter {
    constructor() {
        super();
        this.mode = 'idle'; // 'idle' | 'live'
        this.symbols = {}; 
        this.tokenMap = {}; // instrument_token -> symbol
        this.currentPrices = {};
        this.cumulativeVolume = {}; // Track daily volume for AllTick
        this.kiteTickCount = 0;
        this.kiteLatency = 0; // Real-time latency tracking
        this.allTickTickCount = 0;
        this.startTime = new Date();
        this.config = {}; // Prevent startup crash
    }

// ... (skipping for brevity)
    async initializeKiteInstruments() {
        try {
            await kiteInstrumentsService.loadIntoMemory();
        } catch (error) {
            logger.error('Failed to initialize Kite instruments in MarketDataService');
        }
    }

    async init() {
        logger.info('MARKET_DATA: Initializing Service...');
        try {
            await this.initializeKiteInstruments();
            await this.loadMasterSymbols(); // Load symbols FIRST
            await this.loadSettings();      // Then load settings (which starts feed)
            
            // Redundant startLiveFeed removed to prevent double-initialization crash

            this.startStatsBroadcast();
        } catch (error) {
            logger.error('MARKET_DATA_ERROR: Failed to initialize', error);
        }
    }

    startStatsBroadcast() {
        if (this.statsInterval) clearInterval(this.statsInterval);
        
        this.statsInterval = setInterval(() => {
            const stats = this.getStats();
            // Emit to local event bus (e.g. for socket service to pick up)
            this.emit('stats_update', stats);
        }, 1000);
    }

    async loadMasterSymbols() {
        try {
            const symbols = await MasterSymbol.find({});
            this.symbols = {};
            this.tokenMap = {};
            
            symbols.forEach(s => {
                this.symbols[s.symbol] = s;
                if (s.instrumentToken) {
                    this.tokenMap[s.instrumentToken] = s.symbol;
                }
            });
            logger.info(`MARKET_DATA: Loaded ${symbols.length} master symbols into memory`);
        } catch (error) {
            logger.error('Error loading master symbols:', error);
        }
    }

    /**
     * Dynamically add a symbol to memory and subscribe
     */
    async addSymbol(symbolDoc) {
        if (!symbolDoc || !symbolDoc.symbol) return;

        logger.info(`MARKET_DATA: Adding new symbol ${symbolDoc.symbol} to memory`);
        this.symbols[symbolDoc.symbol] = symbolDoc;
        
        if (symbolDoc.instrumentToken) {
            this.tokenMap[symbolDoc.instrumentToken] = symbolDoc.symbol;
            if (this.adapter && this.adapter.isTickerConnected) {
                this.adapter.subscribe([symbolDoc.instrumentToken]);
                // Fetch initial snapshot for this symbol (crucial for closed markets)
                this.fetchInitialQuote([symbolDoc.instrumentToken]);
            }
        } else {
            // Handle AllTick / Global Symbols
            const indianExchanges = ['NSE', 'BSE', 'MCX', 'NFO', 'CDS', 'BCD'];

            if (!indianExchanges.includes(symbolDoc.exchange) && (allTickService.isConnected || this.config.alltick_api_key)) {
                // Fetch initial data immediately
                allTickService.getQuote([symbolDoc.symbol]).then(quotes => {
                    this._processQuotes(quotes);
                });
                
                // We rely on WebSocketManager's dynamic viewport update from frontend
                // to trigger the permanent subscription for this new symbol.
            }
        }
    }

    subscribeToSymbols() {
        if (Object.keys(this.symbols).length === 0) {
            logger.warn('MARKET_DATA: No symbols loaded to subscribe');
            return;
        }

        const allSymbols = Object.keys(this.symbols);

        // 1. Kite Subscription
        if (this.adapter && this.adapter.isTickerConnected) {
            const tokens = allSymbols
                .map(s => this.symbols[s].instrumentToken)
                .filter(t => t); // Filter only those with tokens
            
            logger.info(`[DEBUG_SUB] Found ${allSymbols.length} total symbols. ${tokens.length} have Kite tokens.`);

            if (tokens.length > 0) {
                 this.adapter.subscribe(tokens);
                 logger.info(`[DEBUG_SUB] Subscribing to Kite Tokens: ${tokens.join(',')}`);
                 
                 // Fetch initial static Data (for closed markets like NSE Equity at night)
                 this.fetchInitialQuote(tokens);
            } else {
                logger.warn('[DEBUG_SUB] No user symbols found, but Indices should be auto-subscribed?');
            }
            
            // Force Subscribe to Critical Indices (If not in master list already)
            // Ideally these should be in MasterSymbols, but safekeep here:
            // "NSE:INDIA VIX" isn't standard in all instrument lists, check instrument service.
            
            const coreINDICES = ['NSE:NIFTY 50-INDEX', 'NSE:NIFTY BANK-INDEX', 'NSE:INDIA VIX'];
            coreINDICES.forEach(sym => {
                const instrument = kiteInstrumentsService.getInstrumentBySymbol(sym);
                if (instrument) {
                    const token = parseInt(instrument.instrument_token);
                    this.adapter.subscribe([token]);
                    this.tokenMap[token] = sym;
                    logger.info(`[DEBUG_SUB] Force subscribed to Index: ${sym} (Token: ${token})`);
                }
            });
        } else {
            logger.warn('[DEBUG_SUB] Adapter not connected or missing');
        }

        // 2. AllTick Subscription (via WebSocket Manager)
        if (allTickService.isConnected || this.config.alltick_api_key) { 
             const symbolsToSubscribe = allSymbols.filter(s => {
                 const sym = this.symbols[s];
                 const indianExchanges = ['NSE', 'BSE', 'MCX', 'NFO', 'CDS', 'BCD'];
                 if (s.includes(':')) return false; // Safety: Any colon usually implies "EXCHANGE:SYMBOL" which AllTick doesn't use (except maybe crypto pairs like BTC:USD but usually they are BTCUSD)
                 return !indianExchanges.includes(sym.exchange) && !sym.instrumentToken;
             });

             const sentimentSymbols = ['BTCUSD', 'ETHUSD', 'XAUUSD', 'EURUSD'];
             const combinedSubs = [...new Set([...symbolsToSubscribe, ...sentimentSymbols])];

             if (combinedSubs.length > 0) {
                 logger.info(`[MarketData] Delegating ${combinedSubs.length} symbols to WebSocketManager`);
                 
                 // Dynamic Viewport Update
                 websocketManager.updateViewport(combinedSubs);
                 
                 // Initial Quote Fetch (Still useful for 0-latency start)
                 allTickService.getQuote(combinedSubs).then(quotes => {
                     this._processQuotes(quotes);
                 });
             }
        }
        
        // --- PHASE 4: Smart Startup Sequence (History) ---
        startupOptimizer.start(this);
    }

    


    // Helper to process quotes and update state
    _processQuotes(quotes) {
        const pseudoTicks = [];
        Object.keys(quotes).forEach(sym => {
            const q = quotes[sym];
            this.currentPrices[sym] = q.last_price;
            if (!this.currentQuotes) this.currentQuotes = {};
            this.currentQuotes[sym] = {
                last_price: q.last_price,
                ohlc: q.ohlc,
                bid: 0, ask: 0, volume: 0, // Vol updated separately
                ...this.currentQuotes[sym] // Keep existing vol if any
            };

            pseudoTicks.push({
                symbol: sym,
                last_price: q.last_price,
                ohlc: q.ohlc,
                total_volume: this.cumulativeVolume[sym] || 0,
                provider: 'alltick'
            });
        });
        
        if (pseudoTicks.length > 0) {
            this._broadcastPseudoTicks(pseudoTicks);
        }
    }

    _updateVolumeFromCandles(sym, candles) {
        if (candles && candles.length > 0) {
             const lastCandle = candles[candles.length - 1];
             this.cumulativeVolume[sym] = lastCandle.volume;
             if (this.currentQuotes[sym]) {
                 this.currentQuotes[sym].volume = lastCandle.volume;
             }
             // Re-broadcast? Maybe not spam. UI updates on next tick.
        }
    }
    
    _broadcastPseudoTicks(ticks) {
        ticks.forEach(t => {
            this.emit('price_update', {
                ...t,
                open: t.ohlc.open, high: t.ohlc.high, low: t.ohlc.low,
                change: 0, changePercent: 0, volume: 0, bid: 0, ask: 0,
                timestamp: new Date()
            });
        });
    }

    async fetchInitialQuote(tokens) {
        try {
            const symbolsToFetch = [];
            // We don't need tokenToSymbolMap here because processLiveTicks uses Token -> Internal Symbol map

            tokens.forEach(t => {
                // Use Kite Instruments Service to get the actual "EXCHANGE:TRADINGSYMBOL" 
                // that Kite API expects (e.g. "NSE:TCS" instead of "NSE:TCS-EQ")
                const correctKiteSymbol = kiteInstrumentsService.getSymbolByToken(t);
                if (correctKiteSymbol) {
                    symbolsToFetch.push(correctKiteSymbol);
                } else {
                    // Fallback to internal map if not found in cache (unlikely if token exists)
                    const symStr = this.tokenMap[t];
                    if (symStr) symbolsToFetch.push(symStr);
                }
            });
            if (symbolsToFetch.length === 0) return;

            logger.info(`Fetching Initial QUOTE for ${symbolsToFetch.length} symbols...`);
            
            // Use getQuote instead of getLTP to get OHLC
            const startFetch = Date.now();
            const quoteData = await this.adapter.getQuote(symbolsToFetch);
            
            // Set initial latency based on REST API RTT
            this.kiteLatency = Date.now() - startFetch;
            logger.info(`[DEBUG_QUOTE] Fetch took ${this.kiteLatency}ms. Wrapper Response keys: ${Object.keys(quoteData).join(',')}`);
            
            // Response: { "NSE:TCS": { instrument_token, last_price, ohlc: {...} } }
            const pseudoTicks = [];
            
            Object.keys(quoteData).forEach(kiteSym => {
                const item = quoteData[kiteSym];
                const token = item.instrument_token;
                
                // Store Quote/OHLC in memory mapping (Token -> Quote)
                // We need to map it back to our internal symbol if possible
                const internalSymbol = this.tokenMap[token];
                if (internalSymbol) {
                    if (!this.currentQuotes) this.currentQuotes = {};
                    this.currentQuotes[internalSymbol] = item;
                }

                pseudoTicks.push({
                    instrument_token: token,
                    last_price: item.last_price,
                    mode: 'quote' 
                });
            });

            if (pseudoTicks.length > 0) {
                logger.info(`Pushing ${pseudoTicks.length} initial Quote updates to frontend`);
                this.processLiveTicks(pseudoTicks, 'kite');
            }

        } catch (error) {
            logger.error('Error fetching initial Quote:', error);
        }
    }



    processLiveTicks(ticks, provider) {
        if (!Array.isArray(ticks)) return;

        if (provider === 'kite') {
            this.kiteTickCount += ticks.length;
            if (this.kiteTickCount % 100 === 0) logger.info(`[KITE_STATS] Total Ticks: ${this.kiteTickCount}`);
            // ... keys
        } else if (provider === 'alltick') {
            this.allTickTickCount += ticks.length;
            if (this.allTickTickCount % 10 === 0) logger.info(`[ALLTICK_STATS] Incoming batch of ${ticks.length} ticks. Total: ${this.allTickTickCount}`);
        }

        ticks.forEach(tick => {
            let symbol = tick.symbol;
            
            // Map Token to Symbol for Kite
            if (provider === 'kite' && tick.instrument_token) {
                 symbol = this.tokenMap[tick.instrument_token];
            }

            if (!symbol) return;
            
            // Optimization: Do NOT invalidate on every tick.
            // Cache invalidation for History/Quotes should be time-based or event-based, not tick-based.
            // cacheManager.invalidateOnWebSocket(symbol);

            const price = tick.last_price;
            this.currentPrices[symbol] = price;

            // Maintain OHLC in memory
            if (!this.currentQuotes) this.currentQuotes = {};
            if (!this.currentQuotes[symbol]) {
                this.currentQuotes[symbol] = {
                    last_price: price,
                    ohlc: { open: price, high: price, low: price, close: price },
                    bid: 0, ask: 0, volume: 0
                };
            }

            const quote = this.currentQuotes[symbol];
            quote.last_price = price;
            
            // Update OHLC from Provider Data (Prioritize official values)
            if (tick.ohlc) {
                // Kite Ticker format: tick.ohlc = { open, high, low, close }
                quote.ohlc.open = tick.ohlc.open || quote.ohlc.open;
                quote.ohlc.high = tick.ohlc.high || quote.ohlc.high;
                quote.ohlc.low = tick.ohlc.low || quote.ohlc.low;
            } else {
                // AllTick or Manual Update: Manual High/Low tracking
                if (price > (quote.ohlc.high || 0)) quote.ohlc.high = price;
                if (price < (quote.ohlc.low || 999999999)) quote.ohlc.low = price;
            }
            
            // Calculate Change against Day's Open (Official)
            const open = quote.ohlc.open || price;
            const change = price - open;
            const changePercent = open !== 0 ? (change / open) * 100 : 0;

            // --- VOLUME HANDLING ---
            let incrementalVolume = parseFloat(tick.volume || tick.last_quantity || 0);
            let totalVolume = 0;

            if (provider === 'kite') {
                totalVolume = parseFloat(tick.volume || 0);
            } else {
                // AllTick: Accumulate
                if (!this.cumulativeVolume[symbol]) this.cumulativeVolume[symbol] = 0;
                this.cumulativeVolume[symbol] += incrementalVolume;
                totalVolume = this.cumulativeVolume[symbol];
            }

            // Update Bid/Ask
            const newBid = parseFloat(tick.bid || (tick.depth?.buy?.[0]?.price) || 0);
            const newAsk = parseFloat(tick.ask || (tick.depth?.sell?.[0]?.price) || 0);

            if (newBid > 0) quote.bid = newBid;
            if (newAsk > 0) quote.ask = newAsk;
            quote.volume = totalVolume; 

            // Emit Normalized Event
            const payload = {
                symbol: symbol,
                price: price,
                open: open,
                high: quote.ohlc.high,
                low: quote.ohlc.low,
                change: change,
                changePercent: changePercent,
                volume: incrementalVolume,
                total_volume: totalVolume,
                bid: quote.bid || 0,
                ask: quote.ask || 0,
                timestamp: tick.timestamp || new Date(),
                provider: provider
            };

            this.emit('price_update', payload);
            
            // NEW: Push to Data Pipeline (In-Memory RingBuffer)
            pipeline.push(payload);
            
            // Legacy Redis Fallback (Optional, commented out for optimization target)
            // if (redisClient.status === 'ready') {
            //      redisClient.publish('market_data', JSON.stringify({
            //          ...payload,
            //          last_price: price 
            //      }));
            // }
        });
    }

    async loadSettings() {
        const settings = await Setting.find({ 
            key: { $regex: '^(data_feed_|kite_|fmp_|alltick_)' } 
        });
        
        this.config = {};
        settings.forEach(s => {
            if (s.key.includes('api_key') || s.key.includes('api_secret') || s.key.includes('access_token')) {
                this.config[s.key] = decrypt(s.value);
            } else {
                this.config[s.key] = s.value;
            }
        });
        
        // Load Env Vars overrides
        if (process.env.KITE_API_KEY) this.config.kite_api_key = process.env.KITE_API_KEY;
        if (process.env.KITE_API_SECRET) this.config.kite_api_secret = process.env.KITE_API_SECRET;
        if (process.env.ALLTICK_API_KEY) this.config.alltick_api_key = process.env.ALLTICK_API_KEY;
        if (process.env.FMP_API_KEY) this.config.fmp_api_key = process.env.FMP_API_KEY;
        
        // Initialize Helpers
        if (this.config.alltick_api_key) {
            allTickService.initialize(this.config.alltick_api_key);
        }

        if (this.config.kite_access_token) {
            kiteService.setAccessToken(this.config.kite_access_token);
        }

        // Restart Feeds
        if (this.canGoLive()) {
            await this.startLiveFeed();
        }
    }

    canGoLive() {
        // Can go live if EITHER provider is valid
        const hasKite = !!(this.config.kite_api_key && this.config.kite_api_secret);
        const hasAllTick = !!(this.config.alltick_api_key);
        return hasKite || hasAllTick;
    }

    async startLiveFeed() {
        const promises = [];

        // 1. Start Kite if configured
        if (this.config.kite_api_key && this.config.kite_api_secret) {
            promises.push((async () => {
                try {
                    this.adapter = kiteService;
                    this.adapter.initialize(this.config.kite_api_key, this.config.kite_api_secret);
                    
                    if (this.config.kite_access_token) {
                        this.adapter.setAccessToken(this.config.kite_access_token);
                        this.connectTicker(); // Only Kite uses this local method wrapper
                    } else {
                        logger.warn(`Kite Configured but NO Access Token. Waiting for Login...`);
                    }
                } catch (e) {
                    logger.error('Error initializing Kite Service', e);
                }
            })());
        }

        // 2. Start AllTick if configured
        if (this.config.alltick_api_key) {
             promises.push((async () => {
                 try {
                    // Initialize WebSocket Manager (Partitioning/Pooling)
                    websocketManager.init(this);
                    
                    // We STILL need to connect the Main Ticker for non-pooled events?
                    // Actually, WebSocketManager handles data via Pool.
                    // But we might need one connection for "General" stuff or just rely on Manager.
                    // The original code used `allTickService.connectTicker`.
                    // If we switch to Manager, do we still need `connectTicker`? 
                    // `websocketManager` manages connections.
                    // But `subscribeToSymbols` calls `websocketManager.updateViewport`.
                    // So we probably don't need `connectTicker` for AllTick anymore in the old way.
                    
                    // However, we should ensure `allTickService` is initialized with token.
                    // It is (line 506).
                    
                    // Let's keep `connectTicker` for now as a fallback or for "Global" market events, 
                    // OR disable it if Manager covers everything.
                    // Manager covers QUOTES and DEPTH.
                    // If we disable `connectTicker`, we rely solely on Manager.
                    
                    logger.info('WebSocket Manager Initialized for AllTick');
                    this.subscribeToSymbols();

                 } catch (e) {
                     logger.error('Error starting AllTick Feed', e);
                 }
             })());
        }

        await Promise.allSettled(promises);
    }

    connectTicker() {
        if (!this.adapter) return;
        
        this.adapter.connectTicker((ticks) => {
            this.processLiveTicks(ticks, 'kite');
        }, () => {
            logger.info('Kite Live Ticker Connected');
            this.mode = 'live';
            this.subscribeToSymbols();
        });
    }

    getStats() {
        // Return Decoupled Stats
        const stats = {
            provider: this.config?.data_feed_provider || 'none',
            startTime: this.startTime,
            uptime: Math.floor((new Date() - this.startTime) / 1000),
            mode: this.mode,
            
            // Explicit Kite Stats
            kite: {
                connected: this.adapter?.isTickerConnected || false,
                latency: this.adapter?.isTickerConnected ? `${this.kiteLatency}ms` : 'Disconnected',
                tickCount: this.kiteTickCount
            },

            // Explicit AllTick Stats
            alltick: {
                connected: allTickService.isConnected || false,
                latency: allTickService.isConnected ? `${allTickService.latency}ms` : 'Disconnected',
                tickCount: this.allTickTickCount
            },
            
            // DEBUG: Expose current prices to verify initialization
            prices: this.currentPrices || {}
        };

        // Legacy support for flat latency logic (optional, for other consumers)
        // We use the 'Active' provider for the main latency field
        if (stats.provider === 'kite') {
            stats.latency = stats.kite.latency;
            stats.tickCount = stats.kite.tickCount;
        } else {
            stats.latency = stats.alltick.latency;
            stats.tickCount = stats.alltick.tickCount;
        }

        return stats;
    }

    async handleLogin(provider, payload) {
        await this.loadSettings();

        if (provider === 'kite') {
            return this.handleKiteLogin(payload.request_token || payload.code);
        } else {
             throw new Error(`Login provider ${provider} not supported yet`);
        }
    }

    async handleKiteLogin(requestToken) {
         await this.loadSettings();
         if (!this.config.kite_api_key) throw new Error('API Key not configured');

         kiteService.initialize(this.config.kite_api_key, this.config.kite_api_secret);
         const response = await kiteService.generateSession(requestToken);
         
         await Setting.findOneAndUpdate(
             { key: 'kite_access_token' }, 
             { key: 'kite_access_token', value: encrypt(response.access_token), description: 'Kite Access Token' }, 
             { upsert: true }
         );

         this.config.kite_access_token = response.access_token;
         this.mode = 'live';
         this.connectTicker();
         return response;
    }

    async getHistory(symbol, resolution, from, to, priority = null) {
        // Generate Standard Cache Key
        const provider = this.config.data_feed_provider || 'alltick';
        
        // Normalize Dates (Support Seconds, Milliseconds, or Date String)
        // Normalize Dates (Support Seconds, Milliseconds, or Date String)
        const parseTs = (val) => {
             if (!val) return Math.floor(Date.now() / 1000);
             // CRITICAL: Handle Date objects first because isNaN(Date) is false but parseInt(Date) is NaN
             if (val instanceof Date) return Math.floor(val.getTime() / 1000);
             
             if (!isNaN(val)) {
                  const num = Number(val);
                  // Standard heuristic: Timestamps > 10 billion are ms
                  return num > 10000000000 ? Math.floor(num / 1000) : Math.floor(num);
             }
             const d = new Date(val);
             return !isNaN(d.getTime()) ? Math.floor(d.getTime() / 1000) : Math.floor(Date.now() / 1000);
        };

        const fromTs = parseTs(from);
        const toTs = to ? parseTs(to) : Math.floor(Date.now() / 1000);
        
        // Normalize for Deduplication & Caching (Round to 30s)
        const toTsNormal = Math.floor(toTs / 30) * 30;
        const fromTsNormal = Math.floor(fromTs / 30) * 30;
        
        // Cache Key: "history_BTCUSD_5_170000_171000"
        const cacheKey = `history_${symbol}_${resolution}_${fromTsNormal}_${toTsNormal}`;
        
        // 1. Unified Cache Check (L1 -> L2 -> L3)
        return cacheManager.getOrFetch(cacheKey, async () => {
            
            // 2. Direct Call (Provider handles its own queuing/limits)
            logger.debug(`[MarketData] Fetching History: ${symbol} (${resolution}) via ${provider}`);
            
            try {
                let data = [];
                
                const isGlobalSymbol = ['XAUUSD', 'XAGUSD', 'BTCUSD', 'ETHUSD', 'EURUSD'].includes(symbol) || 
                                     (this.symbols[symbol] && ['FOREX', 'CRYPTO', 'BINANCE'].includes(this.symbols[symbol].exchange));

                const isKiteRequest = !isGlobalSymbol && (provider === 'kite' || (this.symbols[symbol]?.instrumentToken && this.config.kite_api_key));
                logger.info(`[MarketData-Trace] Symbol: ${symbol}, Provider: ${provider}, IsKite: ${isKiteRequest}`);

                if (isKiteRequest) {
                        // Check if Kite Auth is globally broken to avoid clogging queue with known failures
                        if (this.kiteAuthBrokenUntil && Date.now() < this.kiteAuthBrokenUntil) {
                            logger.warn(`[MarketData] Skipping Kite history for ${symbol} - Auth recently failed.`);
                            return [];
                        }

                        // --- KITE STRATEGY ---
                        // Pass Date objects derived from safe timestamps
                        data = await this._fetchKiteHistory(symbol, resolution, new Date(fromTsNormal * 1000), new Date(toTsNormal * 1000));
                        // No extra mapping needed here
                } else {
                        // --- ALLTICK STRATEGY (Crypto/Forex/Fallback) ---
                        // AllTickService handles its own Rate Limiting via RequestQueue internally.
                        logger.info(`[MarketData-Trace] Delegating to AllTick for ${symbol}`);
                        const isRecent = (Date.now() / 1000) - toTsNormal < 3600; 
                        const effectivePriority = priority || (isRecent ? 1 : 2);
                        data = await allTickService.getHistoricalData(symbol, resolution, new Date(fromTsNormal * 1000), new Date(toTsNormal * 1000), effectivePriority);
                }

                if (!Array.isArray(data)) {
                    logger.warn(`[MarketData] Fetch Returned NON-ARRAY for ${symbol}`);
                    return [];
                }
                
                logger.info(`[History Debug] ${symbol}: Returned ${data.length} candles. First: ${JSON.stringify(data[0])}`);
                return data.filter(c => c && c.time && c.close !== undefined);

            } catch (e) {
                if (e.message?.includes('403') || e.message?.includes('Incorrect api_key') || e.message?.includes('401')) {
                    logger.error(`[MarketData] Kite AUTH FAILURE detected. Disabling Kite history for 5 minutes.`);
                    this.kiteAuthBrokenUntil = Date.now() + (5 * 60 * 1000); // 5 min cooldown
                }
                logger.error(`[MarketData] Fetch Failed ${symbol}: ${e.message}`);
                return []; // Return empty instead of throwing to unblock UI/Queue
            }

        }, '24h');
    }

    // Extracted Kite logic from original getHistory
    async _fetchKiteHistory(symbol, resolution, from, to) {
        const masterSymbol = this.symbols[symbol];
        let interval = 'minute';
        // Mapping Logic
        if (resolution === '1') interval = 'minute';
        else if (resolution === '3') interval = '3minute';
        else if (resolution === '5') interval = '5minute';
        else if (resolution === '15') interval = '15minute';
        else if (resolution === '30') interval = '30minute';
        else if (resolution === '60' || resolution === '1h') interval = '60minute';
        else if (resolution === 'D' || resolution === '1D') interval = 'day';

        // Range Clamping logic (Kite limits per request, not necessarily total retention)
        // If we want to support older data, we should paginate, but for now let's just respect the TO date.
        const now = Math.floor(Date.now() / 1000);
        let safeFrom = new Date(from).getTime() / 1000;
        
        // Only clamp strict lookback if necessary, but don't break the range
        // For debugging, we remove the logic that shifts 'from' past 'to'
        // let maxDays = 60;
        // if (interval === 'day') maxDays = 2000;
        // else if (interval === '60minute') maxDays = 400;
        // if (now - safeFrom > maxDays * 86400) safeFrom = now - (maxDays * 86400);

        if (safeFrom > new Date(to).getTime() / 1000) {
             logger.warn(`[KITE] Adjusted 'from' date was after 'to' date. Resetting to 'to' - interval.`);
             safeFrom = (new Date(to).getTime() / 1000) - 86400; // Fallback to 1 day before TO
        }

        logger.info(`[HISTORY_DEBUG] Fetching Kite History for ${symbol} (Token: ${masterSymbol.instrumentToken}). Range: ${new Date(safeFrom * 1000).toISOString()} to ${new Date(to).toISOString()}`);

        const data = await kiteService.getHistoricalData(
            masterSymbol.instrumentToken, 
            interval, 
            new Date(safeFrom * 1000), 
            new Date(to)
        );
        
        return data;
    }


    async searchInstruments(query = '') {
        try {
            let kiteResults = [];
            let allTickResults = [];
            const safeQuery = typeof query === 'string' ? query : '';

            // 1. Kite Search
            if (this.config && this.config.kite_api_key) {
                try {
                    kiteResults = await kiteInstrumentsService.search(safeQuery);
                } catch (e) {
                    logger.error(`Kite search error: ${e.message}`);
                }
            }

            // 2. AllTick Search
            try {
                // Even without API key, use service for potential fallback or handling
                allTickResults = await allTickService.search(safeQuery);
            } catch (e) {
                logger.error(`AllTick search error: ${e.message}`);
            }

            // 3. Hardcoded Master List (Fallback & Priority)
            const popular = [
                // INDICES
                { symbol: 'NSE:NIFTY 50-INDEX', name: 'Nifty 50', segment: 'INDICES', exchange: 'NSE', lotSize: 50, tickSize: 0.05 },
                { symbol: 'NSE:NIFTY BANK-INDEX', name: 'Nifty Bank', segment: 'INDICES', exchange: 'NSE', lotSize: 15, tickSize: 0.05 },
                { symbol: 'BSE:SENSEX-INDEX', name: 'Sensex', segment: 'INDICES', exchange: 'BSE', lotSize: 10, tickSize: 0.05 },
                { symbol: 'NSE:FINNIFTY-INDEX', name: 'Nifty Fin Service', segment: 'INDICES', exchange: 'NSE', lotSize: 40, tickSize: 0.05 },
                
                // STOCKS (Major)
                { symbol: 'NSE:RELIANCE-EQ', name: 'Reliance Industries', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:TCS-EQ', name: 'Tata Consultancy Services', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:HDFCBANK-EQ', name: 'HDFC Bank', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:INFY-EQ', name: 'Infosys', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:ICICIBANK-EQ', name: 'ICICI Bank', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:SBIN-EQ', name: 'State Bank of India', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:BHARTIARTL-EQ', name: 'Bharti Airtel', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:ITC-EQ', name: 'ITC Ltd', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:KOTAKBANK-EQ', name: 'Kotak Mahindra Bank', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },
                { symbol: 'NSE:LT-EQ', name: 'Larsen & Toubro', segment: 'EQUITY', exchange: 'NSE', lotSize: 1, tickSize: 0.05 },

                // GLOBAL / CRYPTO
                { symbol: 'BTCUSD', name: 'Bitcoin USD', segment: 'CRYPTO', exchange: 'BINANCE', lotSize: 1, tickSize: 0.01 },
                { symbol: 'ETHUSD', name: 'Ethereum USD', segment: 'CRYPTO', exchange: 'BINANCE', lotSize: 1, tickSize: 0.01 },
                // Use 'FOREX' exchange for Global/Currencies, but ensure Plan 'CURRENCY' allows 'FOREX'
                { symbol: 'EURUSD', name: 'Euro / US Dollar', segment: 'CURRENCY', exchange: 'FOREX', lotSize: 1, tickSize: 0.0001 },
                // Use 'FOREX' for Commodities like Gold if data comes from global provider, but Segment MUST be COMMODITY
                { symbol: 'XAUUSD', name: 'Gold / US Dollar', segment: 'COMMODITY', exchange: 'FOREX', lotSize: 1, tickSize: 0.01 },
                { symbol: 'XAGUSD', name: 'Silver / US Dollar', segment: 'COMMODITY', exchange: 'FOREX', lotSize: 1, tickSize: 0.001 },
                // Add Crude Oil if missing
                { symbol: 'MCX:CRUDEOIL24NOVFUT', name: 'Crude Oil', segment: 'COMMODITY', exchange: 'MCX', lotSize: 100, tickSize: 1.00 }
            ];

            // 4. Database Search
            const dbSymbols = await MasterSymbol.find({
                $or: [
                    { symbol: { $regex: safeQuery, $options: 'i' } },
                    { name: { $regex: safeQuery, $options: 'i' } }
                ]
            }).limit(10);

            const dbMapped = dbSymbols.map(s => ({
                symbol: s.symbol,
                name: s.name,
                segment: s.segment,
                exchange: s.exchange,
                lotSize: s.lotSize,
                tickSize: s.tickSize || 0.05
            }));

            // Filter Popular List
            const q = safeQuery.toUpperCase();
            const filteredPopular = popular.filter(p => 
                p.symbol.includes(q) || 
                p.name.toUpperCase().includes(q)
            );

            // Merge & Unique
            const combined = [...dbMapped, ...kiteResults, ...allTickResults, ...filteredPopular];
            const unique = Array.from(new Map(combined.map(item => [item.symbol, item])).values());

            return unique.slice(0, 50);

        } catch (error) {
            logger.error(`Critical Error in searchInstruments: ${error.message}`);
            // Return empty array instead of 500 to keep UI alive
            return [];
        }
    }

    /**
     * Get historical OHLC data for a symbol
     * @param {string} symbol - Symbol name (e.g., 'EURUSD', 'NIFTY 50')
     * @param {string} resolution - Timeframe (1, 5, 15, 30, 60, 1D, etc.)
     * @param {number|string} from - Start timestamp (seconds)
     * @param {number|string} to - End timestamp (seconds)
     * @returns {Promise<Array>} Array of OHLC candles
     */

}

const marketDataService = new MarketDataService();
export default marketDataService;
</file>

<file path="src/services/msg91.service.js">
import axios from 'axios';
import logger from '../config/logger.js';

class Msg91Service {
    constructor() {
        this.authKey = process.env.MSG91_AUTH_KEY;
        this.baseUrl = 'https://control.msg91.com/api/v5';
    }

    /**
     * Send OTP via MSG91
     * @param {string} mobile - Mobile number with country code (e.g. 919876543210)
     * @param {string} templateId - MSG91 Template ID for OTP
     * @returns {Promise<boolean>}
     */
    async sendOtp(mobile, templateId) {
        if (!this.authKey) {
            logger.error('MSG91_AUTH_KEY is missing in .env');
            throw new Error('Server configuration error: MSG91 key missing');
        }

        try {
            const url = `${this.baseUrl}/otp`;
            const params = {
                mobile: mobile,
                template_id: templateId,
                authkey: this.authKey
            };

            const response = await axios.get(url, { params });

            if (response.data.type === 'success') {
                logger.info(`MSG91: OTP sent to ${mobile}`);
                return true;
            } else {
                logger.error(`MSG91: OTP Send Failed - ${JSON.stringify(response.data)}`);
                return false;
            }
        } catch (error) {
            logger.error(`MSG91: OTP Error - ${error.message}`);
            throw new Error('Failed to send OTP');
        }
    }

    /**
     * Verify OTP via MSG91
     * @param {string} mobile - Mobile number
     * @param {string} otp - The OTP entered by user
     * @returns {Promise<boolean>}
     */
    async verifyOtp(mobile, otp) {
        if (!this.authKey) throw new Error('MSG91_AUTH_KEY missing');

        try {
            const url = `${this.baseUrl}/otp/verify`;
            const params = {
                mobile: mobile,
                otp: otp,
                authkey: this.authKey
            };

            const response = await axios.get(url, { params });

            if (response.data.type === 'success') {
                logger.info(`MSG91: OTP Verified for ${mobile}`);
                return true;
            } else {
                logger.warn(`MSG91: OTP Verification Failed for ${mobile} - ${response.data.message}`);
                return false;
            }
        } catch (error) {
            logger.error(`MSG91: Verify Error - ${error.message}`);
            return false;
        }
    }

    /**
     * Send WhatsApp Message
     * @param {string} mobile - Mobile Number
     * @param {string} templateName - The defined template name in MSG91
     * @param {object} components - Variables for the template (e.g. { "1": "Aqib", "2": "Welcome" })
     * @returns {Promise<void>}
     */
    async sendWhatsapp(mobile, templateName, components = {}) {
        if (!process.env.MSG91_WHATSAPP_INTEGRATED_NUMBER) {
             logger.warn('MSG91: WhatsApp Integrated Number not set in .env');
             return;
        }

        try {
           // This is a simplified implementation for MSG91's WhatsApp API
           // Docs: https://docs.msg91.com/reference/send-whatsapp-message
           const url = `https://control.msg91.com/api/v5/whatsapp/whatsapp-outbound-message/custom/${process.env.MSG91_WHATSAPP_INTEGRATED_NUMBER}`;
           
           const payload = {
               integrated_number: process.env.MSG91_WHATSAPP_INTEGRATED_NUMBER,
               content_type: "template",
               payload: {
                   to: mobile,
                   type: "template",
                   template: {
                       name: templateName,
                       language: {
                           code: "en", 
                           policy: "deterministic"
                       },
                       components: [
                           {
                               type: "body",
                               parameters: Object.keys(components).map(key => ({
                                   type: "text",
                                   text: components[key]
                               }))
                           }
                       ]
                   }
               }
           };

           const headers = {
               "authkey": this.authKey,
               "content-type": "application/json"
           };

           const response = await axios.post(url, payload, { headers });
           logger.info(`MSG91: WhatsApp sent to ${mobile} response: ${JSON.stringify(response.data)}`);

        } catch (error) {
            logger.error(`MSG91: WhatsApp Error - ${error.response?.data?.message || error.message}`);
        }
    }

    /**
     * Send SMS
     * @param {string} mobile 
     * @param {string} message 
     * @param {string} senderId 
     */
    async sendSms(mobile, message, senderId) {
         if (!this.authKey) return;
         
         const flowId = process.env.MSG91_SMS_FLOW_ID; // Recommended to use Flow ID instead of raw text
         if (!flowId) {
             logger.warn("MSG91: flowId not provided for SMS");
             return;
         }

         try {
             const url = "https://control.msg91.com/api/v5/flow/";
             const payload = {
                 template_id: flowId,
                 short_url: "0",
                 recipients: [
                     {
                         mobiles: mobile,
                         VAR1: message // Assuming template has ##VAR1##
                     }
                 ]
             };
             
             const headers = {
                "authkey": this.authKey,
                "content-type": "application/json"
            };

            await axios.post(url, payload, { headers });
            logger.info(`MSG91: SMS sent to ${mobile}`);

         } catch (error) {
             logger.error(`MSG91: SMS Error - ${error.message}`);
         }
    }

    /**
     * Send Email via MSG91
     * @param {string} to - Recipient Email
     * @param {string} subject - Email Subject
     * @param {string} body - Email Body (HTML or Text) - Mapped to VAR1 if generic template used
     * @returns {Promise<boolean>}
     */
    async sendEmail(to, subject, body) {
        if (!this.authKey) return false;
        
        try {
            const url = "https://control.msg91.com/api/v5/email/send";
            const payload = {
                to: [{ email: to }],
                from: { 
                    email: process.env.MSG91_FROM_EMAIL || "no-reply@mspktrading.com", 
                    name: "MSPK TRADE SOLUTIONS" 
                },
                domain: process.env.MSG91_EMAIL_DOMAIN, 
                mail_type_id: "1", 
                // For generic email, we try to send subject/body directly. 
                // MSG91 v5 allows generic emails associated with verified domain without mandatory template_id if configured, 
                // OR we can use a generic template.
                // If the user set MSG91_EMAIL_TEMPLATE_ID to an OTP template, WE MUST NOT USE IT HERE.
                // Thus, we strip template_id from here unless strictly passed for generic use-cases.
                // Assuming simple subject/body sending is allowed for verified domains.
                subject: subject,
                body: body
            };

            const headers = {
                "authkey": this.authKey,
                "content-type": "application/json"
            };

            const response = await axios.post(url, payload, { headers });
            logger.info(`MSG91: Email sent to ${to}`);
            return true;

        } catch (error) {
            logger.error(`MSG91: Email Error - ${error.response?.data?.message || error.message}`);
            // Log full error for debugging
            if(error.response?.data) console.error(JSON.stringify(error.response.data));
            return false;
        }
    }

    /**
     * Send OTP via Email (MSG91 Template)
     * @param {string} to - Recipient Email
     * @param {string} otp - OTP Code
     * @returns {Promise<boolean>}
     */
    async sendEmailOtp(to, otp) {
        if (!this.authKey) return false;
        
        const templateId = process.env.MSG91_EMAIL_TEMPLATE_ID;
        if (!templateId) {
             logger.error("MSG91_EMAIL_TEMPLATE_ID not set for Email OTP");
             return false;
        }

        try {
            const url = "https://control.msg91.com/api/v5/email/send";
            const payload = {
                to: [{ email: to }],
                from: { 
                    email: process.env.MSG91_FROM_EMAIL, 
                    name: "MSPK Support" 
                },
                domain: process.env.MSG91_EMAIL_DOMAIN,
                template_id: templateId,
                variables: {
                    otp: otp,
                    company_name: "MSPK TRADE SOLUTIONS"
                }
                // NO Subject, NO Body - Template handles it
            };
            
            const headers = {
                "authkey": this.authKey,
                "content-type": "application/json"
            };

            const response = await axios.post(url, payload, { headers });
            logger.info(`MSG91: Email OTP sent to ${to}`);
            return true;

        } catch (error) {
            logger.error(`MSG91: Email OTP Error - ${error.response?.data?.message || error.message}`);
             if(error.response?.data) console.error(JSON.stringify(error.response.data));
            return false;
        }
    }
}

export default new Msg91Service();
</file>

<file path="src/services/notification.fcm.service.js">
import { admin } from '../config/firebase.js';
import User from '../models/User.js';
import logger from '../config/logger.js';

/**
 * Send push notification to specific users
 * @param {Array} userIds - List of user IDs
 * @param {Object} payload - Notification payload { title, body, data }
 */
const sendToUsers = async (userIds, payload) => {
  try {
    const users = await User.find({ _id: { $in: userIds } }).select('fcmTokens');
    const allTokens = users.flatMap(user => user.fcmTokens || []);

    if (allTokens.length === 0) return;

    await sendToTokens(allTokens, payload);
  } catch (error) {
    logger.error('Error in sendToUsers FCM:', error);
  }
};

/**
 * Send push notification to specific tokens
 * @param {Array} tokens - List of FCM tokens
 * @param {Object} payload - Notification payload
 */
const sendToTokens = async (tokens, payload) => {
  if (!tokens || tokens.length === 0) return;

  const uniqueTokens = [...new Set(tokens)];
  const message = {
    notification: {
      title: payload.title,
      body: payload.body,
    },
    data: payload.data || {},
    tokens: uniqueTokens,
  };

  try {
    const response = await admin.messaging().sendMulticast(message);
    logger.info(`Successfully sent ${response.successCount} messages; ${response.failureCount} messages failed.`);
    
    if (response.failureCount > 0) {
      // Logic to cleanup invalid tokens could go here
    }
  } catch (error) {
    logger.error('Error sending multicast FCM:', error);
  }
};

/**
 * Send push notification to a topic
 * @param {String} topic - FCM topic name
 * @param {Object} payload - Notification payload
 */
const sendToTopic = async (topic, payload) => {
  const message = {
    notification: {
      title: payload.title,
      body: payload.body,
    },
    data: payload.data || {},
    topic: topic,
  };

  try {
    const response = await admin.messaging().send(message);
    logger.info('Successfully sent message to topic:', response);
  } catch (error) {
    logger.error('Error sending topic FCM:', error);
  }
};

export default {
  sendToUsers,
  sendToTokens,
  sendToTopic,
};
</file>

<file path="src/services/notification.service.js">
import { Queue } from 'bullmq';
import config from '../config/config.js';
import logger from '../config/logger.js';
import { redisSubscriber } from './redis.service.js';
import Notification from '../models/Notification.js';
import User from '../models/User.js';
import Setting from '../models/Setting.js'; // Import Setting model

const connection = {
  host: config.redis.host,
  port: config.redis.port,
};

const notificationQueue = new Queue('notifications', { connection });

class NotificationService {
  constructor() {
    this.init();
  }

  init() {
    // Subscribe to signals channel from Redis
    // Note: redisSubscriber is shared, so we just add another listener
    redisSubscriber.on('message', (channel, message) => {
        if (channel === 'signals') {
            try {
                const signal = JSON.parse(message);
                this.scheduleNotifications(signal);
            } catch (err) {
                logger.error('Notification Service Error', err);
            }
        }
    });
    
    logger.info('Notification Service started (Listening for Signals)');
  }

  async scheduleNotifications(signal) {
      try {
          // Fetch Global Notification Settings
          const settings = await Setting.find({ 
              key: { $in: ['telegram_config', 'whatsapp_config', 'push_config'] } 
          });
          const getSetting = (key) => {
              const s = settings.find(s => s.key === key);
              return s ? s.value : null;
          };

          const teleConfig = getSetting('telegram_config');
          const waConfig = getSetting('whatsapp_config');
          const pushConfig = getSetting('push_config');

          // 1. TELEGRAM BROADCAST (System Level)
          if (teleConfig && teleConfig.enabled) {
              await notificationQueue.add('send-telegram-broadcast', {
                  type: 'telegram',
                  signal,
                  userId: 'system' 
              }, { removeOnComplete: true });
          }

          // 2. TARGETED NOTIFICATIONS (WhatsApp / Push)
          // Find users with Active Subscriptions matching this Segment
          
          // Step A: Find Plans that cover this segment
          // Note: Plan schema uses 'segment' enum. Signal has 'segment' field.
          // Adjust matching logic if segment names differ. Assuming exact match for now.
          const { default: Subscription } = await import('../models/Subscription.js');
          const { default: Plan } = await import('../models/Plan.js');

          // Find active subscriptions
          const now = new Date();
          const activeSubs = await Subscription.find({
              status: 'active',
              endDate: { $gt: now }
          }).populate('plan');

          // Filter for segment match
          const eligibleUserIds = new Set();
          
          activeSubs.forEach(sub => {
              if (sub.plan && sub.user) {
                  // Direct Segment Match
                  if (sub.plan.segment === signal.segment) {
                      eligibleUserIds.add(sub.user.toString());
                  }
                  // TODO: Handle 'All Segments' plans if any
              }
          });

          // Also include the Creator for verification (if not already included)
          if (signal.createdBy) eligibleUserIds.add(signal.createdBy.toString());

          logger.info(`Found ${eligibleUserIds.size} eligible users for Signal ${signal.symbol}`);

          // Step B: Schedule Jobs for each user
          const promises = Array.from(eligibleUserIds).map(userId => {
              const jobs = [];

              if (pushConfig && pushConfig.enabled) {
                  jobs.push(notificationQueue.add('send-push', {
                      type: 'push',
                      userId,
                      signal
                  }, { removeOnComplete: true }));
              }

              if (waConfig && waConfig.enabled) {
                  jobs.push(notificationQueue.add('send-whatsapp', {
                      type: 'whatsapp',
                      userId,
                      signal
                  }, { removeOnComplete: true }));
              }
              
              return jobs;
          });

          await Promise.all(promises.flat());
          

          // Step C: Create In-App Notifications (DB)
          // Only if Push/System notifications are enabled
          if (pushConfig && pushConfig.enabled) {
              const tpDetails = [
                  signal.targets?.target1 ? `TP1: ${signal.targets.target1}` : null,
                  signal.targets?.target2 ? `TP2: ${signal.targets.target2}` : null,
                  signal.targets?.target3 ? `TP3: ${signal.targets.target3}` : null
              ].filter(t => t).join(' | ');

              const notificationDocs = Array.from(eligibleUserIds).map(userId => ({
                  user: userId,
                  title: `üöÄ New Signal: ${signal.symbol}`,
                  message: `Action: ${signal.type} | Entry: ${signal.entryPrice}\n${tpDetails}\nSL: ${signal.stopLoss}`,
                  type: 'SIGNAL',
                  data: { signalId: signal._id },
                  link: `/signals` 
              }));

              if (notificationDocs.length > 0) {
                  await Notification.insertMany(notificationDocs);
              }
          }

          logger.info(`Scheduled notifications for Signal ${signal._id} to ${eligibleUserIds.size} users`);

      } catch (error) {
          logger.error('Failed to schedule notifications', error);
      }
  }

  async scheduleAnnouncementNotifications(announcement) {
      try {
          const { targetAudience, title, message } = announcement;
          const query = { status: 'Active' };

          // 1. Audience Filtering by Role
          if (targetAudience && targetAudience.role !== 'all') {
             query.role = targetAudience.role;
          }

          // 2. Advanced Targeting (Plans / Segments)
          if (targetAudience && (targetAudience.planValues?.length > 0 || targetAudience.segments?.length > 0)) {
              const { default: Subscription } = await import('../models/Subscription.js');
              const { default: Plan } = await import('../models/Plan.js');

              const eligiblePlansFilter = { $or: [] };
              if (targetAudience.planValues?.length > 0) {
                  eligiblePlansFilter.$or.push({ name: { $in: targetAudience.planValues } });
              }
              if (targetAudience.segments?.length > 0) {
                  // Check direct segment OR specific permissions (most sub-categories are in permissions)
                  eligiblePlansFilter.$or.push({ segment: { $in: targetAudience.segments } });
                  eligiblePlansFilter.$or.push({ permissions: { $in: targetAudience.segments } });
              }

              const eligiblePlans = await Plan.find(eligiblePlansFilter).select('_id');
              const eligiblePlanIds = eligiblePlans.map(p => p._id);

              if (eligiblePlanIds.length > 0) {
                  const now = new Date();
                  const activeSubs = await Subscription.find({
                      status: 'active',
                      endDate: { $gt: now },
                      plan: { $in: eligiblePlanIds }
                  }).select('user');
                  
                  const userIdsFromSubs = Array.from(new Set(activeSubs.map(s => s.user.toString())));
                  query._id = { $in: userIdsFromSubs };
              } else {
                  logger.info('No matching plans found for targeting filters');
                  return;
              }
          }

          // LOGGING FOR DEBUG
          console.log('[DEBUG-LIVE] Target Audience:', JSON.stringify(targetAudience));
          console.log('[DEBUG-LIVE] Generated Query:', JSON.stringify(query));

          const users = await User.find(query).select('_id name fcmTokens phone phoneNumber');
          
          console.log(`[DEBUG-LIVE] Users Found: ${users.length}`);

          if (users.length === 0) {
              logger.info('[DEBUG-LIVE] No users found for announcement broadcast matching filters');
              return;
          }

          logger.info(`[DEBUG-LIVE] Scheduling announcement broadcast for ${users.length} users`);

          // 0. Telegram Channel Broadcast (One time)
          // We assume this is a general announcement for the public channel
          await notificationQueue.add('send-telegram-broadcast', {
              type: 'telegram',
              userId: 'system',
              announcement: { title, message }
          }, { removeOnComplete: true });

          const promises = users.map(user => {
              const jobs = [];
              
              // 1. Push Job
              if (user.fcmTokens && user.fcmTokens.length > 0) {
                  jobs.push(notificationQueue.add('send-push-announcement', {
                      type: 'push',
                      userId: user._id,
                      announcement: announcement.toObject ? announcement.toObject() : announcement // Ensure plain object
                  }, { removeOnComplete: true }));
              }

              // 2. WhatsApp Job
              // Only if user has phone. In production, check consent/settings too.
              // Note: This can generate A LOT of jobs. Bulk APIs are preferred but per-user job is safer for rate limiting in worker.
              if (user.phone || user.phoneNumber) { // Check schema field
                   jobs.push(notificationQueue.add('send-whatsapp-announcement', {
                      type: 'whatsapp',
                      userId: user._id, // Worker will fetch user to get phone
                      announcement: announcement.toObject ? announcement.toObject() : announcement
                   }, { removeOnComplete: true }));
              }

              return Promise.all(jobs);
          });

          await Promise.all(promises);

          // Save In-App Notifications
          const notificationDocs = users.map(user => ({
              user: user._id,
              title: title,
              message: message,
              type: 'ANNOUNCEMENT',
              isRead: false
          }));

          if (notificationDocs.length > 0) {
              await Notification.insertMany(notificationDocs);
          }

          logger.info(`Broadcasted announcement ${announcement._id} to ${users.length} potential users`);

      } catch (error) {
          logger.error('Failed to schedule announcement notifications', error);
      }
  }
  /**
   * Send pre-expiry reminder (3 days before expiry)
   * @param {Object} user - User object
   * @param {Object} subscription - Subscription object
   * @param {Number} daysLeft - Days until expiry
   */
  async sendPreExpiryReminder(user, subscription, daysLeft) {
      try {
          const planName = subscription.plan?.name || 'Subscription';
          const expiryDate = new Date(subscription.endDate).toLocaleDateString('en-IN');
          
          // 1. Send Push Notification
          if (user.fcmTokens && user.fcmTokens.length > 0) {
              await notificationQueue.add('send-push-reminder', {
                  type: 'push',
                  userId: user._id,
                  notification: {
                      title: '‚è∞ Subscription Expiring Soon',
                      message: `Your ${planName} plan expires in ${daysLeft} days (${expiryDate}). Renew now to continue enjoying our services!`,
                      type: 'SUBSCRIPTION_EXPIRY_REMINDER',
                      data: {
                          subscriptionId: subscription._id,
                          planName,
                          daysLeft,
                          expiryDate
                      }
                  }
              }, { removeOnComplete: true });
          }

          // 2. Send Email Notification
          await notificationQueue.add('send-email', {
              type: 'email',
              userId: user._id,
              email: user.email,
              subject: `‚è∞ Your ${planName} Plan Expires in ${daysLeft} Days`,
              template: 'pre-expiry-reminder',
              data: {
                  userName: user.name,
                  planName,
                  daysLeft,
                  expiryDate,
                  renewLink: `${config.frontendUrl}/renew-subscription`
              }
          }, { removeOnComplete: true });

          // 3. Create In-App Notification
          await Notification.create({
              user: user._id,
              title: '‚è∞ Subscription Expiring Soon',
              message: `Your ${planName} plan expires in ${daysLeft} days. Renew now!`,
              type: 'SUBSCRIPTION_REMINDER',
              data: { subscriptionId: subscription._id },
              link: '/subscription'
          });

          logger.info(`Pre-expiry reminder sent to user ${user._id} for subscription ${subscription._id}`);

      } catch (error) {
          logger.error(`Failed to send pre-expiry reminder for user ${user._id}`, error);
      }
  }

  /**
   * Send expiry notification (when subscription has expired)
   * @param {Object} user - User object
   * @param {Object} subscription - Subscription object
   */
  async sendExpiryNotification(user, subscription) {
      try {
          const planName = subscription.plan?.name || 'Subscription';
          
          // 1. Send Push Notification
          if (user.fcmTokens && user.fcmTokens.length > 0) {
              await notificationQueue.add('send-push-reminder', {
                  type: 'push',
                  userId: user._id,
                  notification: {
                      title: 'üîí Subscription Expired',
                      message: `Your ${planName} plan has expired. Your account access has been restricted. Renew now to regain access!`,
                      type: 'SUBSCRIPTION_EXPIRED',
                      data: {
                          subscriptionId: subscription._id,
                          planName
                      }
                  }
              }, { removeOnComplete: true });
          }

          // 2. Send Email Notification
          await notificationQueue.add('send-email', {
              type: 'email',
              userId: user._id,
              email: user.email,
              subject: `üîí Your ${planName} Plan Has Expired`,
              template: 'subscription-expired',
              data: {
                  userName: user.name,
                  planName,
                  renewLink: `${config.frontendUrl}/renew-subscription`
              }
          }, { removeOnComplete: true });

          // 3. Create In-App Notification
          await Notification.create({
              user: user._id,
              title: 'üîí Subscription Expired',
              message: `Your ${planName} plan has expired. Renew to regain access.`,
              type: 'SUBSCRIPTION_EXPIRED',
              data: { subscriptionId: subscription._id },
              link: '/subscription'
          });

          logger.info(`Expiry notification sent to user ${user._id} for subscription ${subscription._id}`);

      } catch (error) {
          logger.error(`Failed to send expiry notification for user ${user._id}`, error);
      }
  }

  /**
   * Send Economic Event Alert to All Active Users
   * @param {Object} economicEvent - Economic event data
   */
  async sendEconomicAlert(economicEvent) {
      try {
          logger.info(`Sending economic alert for: ${economicEvent.event} (${economicEvent.impact} impact)`);

          // Get all users with ACTIVE and VALID Subscription
          const { default: Subscription } = await import('../models/Subscription.js');
          
          const now = new Date();
          const activeSubs = await Subscription.find({
              status: 'active',
              endDate: { $gt: now }
          }).select('user');

          if (activeSubs.length === 0) {
              logger.warn('No active subscriptions found for economic alert');
              return;
          }

          const userIds = [...new Set(activeSubs.map(s => s.user.toString()))];
          
          // Fetch Users to get FCM tokens
          const activeUsers = await User.find({
              _id: { $in: userIds },
              status: 'Active' // Double check user is valid
          }).select('_id name email fcmTokens');

          // Format event time
          const eventDate = new Date(economicEvent.date);
          const timeStr = eventDate.toLocaleString('en-IN', { 
              dateStyle: 'medium', 
              timeStyle: 'short',
              timeZone: 'Asia/Kolkata'
          });

          // Create notification title and message
          const impactEmoji = economicEvent.impact === 'High' ? 'üî¥' : 'üü°';
          const title = `${impactEmoji} ${economicEvent.impact} Impact Economic Event`;
          const message = `${economicEvent.event} (${economicEvent.currency}) - ${timeStr}`;
          
          // Prepare notification data
          const notificationData = {
              event: economicEvent.event,
              country: economicEvent.country,
              currency: economicEvent.currency,
              impact: economicEvent.impact,
              date: economicEvent.date,
              actual: economicEvent.actual || 'N/A',
              forecast: economicEvent.forecast || 'N/A',
              previous: economicEvent.previous || 'N/A'
          };

          // 0. Create Broadcast Record
          try {
              const { default: announcementService } = await import('./announcement.service.js');
              await announcementService.createAnnouncement({
                  title,
                  message,
                  type: 'ECONOMIC',
                  priority: economicEvent.impact === 'High' ? 'HIGH' : 'NORMAL',
                  targetAudience: { role: 'all' },
                  isActive: true,
                  startDate: new Date()
              });
          } catch (announcementError) {
              logger.error('Failed to create announcement for economic alert', announcementError);
          }

          // Send to all users
          for (const user of activeUsers) {
              try {
                  // 1. Send Push Notification
                  await notificationQueue.add('send-push', {
                      type: 'push',
                      userId: user._id,
                      notification: {
                          title,
                          message,
                          type: 'ECONOMIC_ALERT',
                          data: notificationData
                      }
                  }, { removeOnComplete: true });

                  // 2. Create In-App Notification
                  await Notification.create({
                      user: user._id,
                      title,
                      message,
                      type: 'ECONOMIC_ALERT',
                      data: notificationData,
                      link: '/announcements/calendar'
                  });

              } catch (userError) {
                  logger.error(`Failed to send alert to user ${user._id}:`, userError.message);
              }
          }

          logger.info(`Economic alert sent successfully to ${activeUsers.length} users`);

      } catch (error) {
          logger.error('Failed to send economic alert:', error);
      }
  }

  /**
   * Legacy function - keeping for backward compatibility
   */
  async sendPlanExpiryReminder(user, daysLeft) {
      try {
          const planName = user.subscription?.plan?.name || 'Subscription';
          
          await notificationQueue.add('send-push-reminder', {
              type: 'push',
              userId: user._id,
              announcement: {
                  type: 'REMINDER',
                  planName,
                  daysLeft,
                  title: 'Plan Expiry',
                  message: `Your ${planName} plan expires in ${daysLeft} days.`
              }
          }, { removeOnComplete: true });

      } catch (error) {
          logger.error(`Failed to schedule expiry reminder for user ${user._id}`, error);
      }
  }
}

export default new NotificationService();
</file>

<file path="src/services/plan.service.js">
import Plan from '../models/Plan.js';
import ApiError from '../utils/ApiError.js';
import httpStatus from 'http-status';

const mapFeaturesToPermissions = (features) => {
  if (!features || !Array.isArray(features)) return [];
  const mapping = {
    'Intraday Equity': 'EQUITY_INTRA',
    'Delivery / Swing': 'EQUITY_DELIVERY',
    'Nifty Options': 'NIFTY_OPT',
    'BankNifty Options': 'BANKNIFTY_OPT',
    'FinNifty Options': 'FINNIFTY_OPT',
    'Stock Options': 'STOCK_OPT',
    'MCX Futures': 'MCX_FUT',
    'Currency': 'CURRENCY',
    'Crypto': 'CRYPTO',
    'Commodity': 'MCX_FUT', // Fallback
    'Forex': 'CURRENCY'    // Fallback
  };
  
  // Filter and map valid permissions
  const perms = new Set();
  features.forEach(f => {
    if (mapping[f]) perms.add(mapping[f]);
    // Also check if feature IS already a permission key (for direct API usage)
    if (Object.values(mapping).includes(f)) perms.add(f);
  });
  
  return Array.from(perms);
};

const createPlan = async (planBody) => {
  // Auto-map permissions from features (Admin Panel Compat)
  if (planBody.features && (!planBody.permissions || planBody.permissions.length === 0)) {
      planBody.permissions = mapFeaturesToPermissions(planBody.features);
  }
  return Plan.create(planBody);
};

const queryPlans = async (filter, options) => {
  const plans = await Plan.find(filter);
  return plans;
};

const getPlanById = async (id) => {
  return Plan.findById(id);
};

const updatePlanById = async (planId, updateBody) => {
  const plan = await getPlanById(planId);
  if (!plan) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Plan not found');
  }
  
  // Auto-map permissions on update too
  if (updateBody.features) {
      updateBody.permissions = mapFeaturesToPermissions(updateBody.features);
  }
  
  Object.assign(plan, updateBody);
  await plan.save();
  return plan;
};

const deletePlanById = async (planId) => {
  const plan = await getPlanById(planId);
  if (!plan) {
    throw new ApiError(httpStatus.NOT_FOUND, 'Plan not found');
  }
  await plan.deleteOne();
  return plan;
};

export default {
  createPlan,
  queryPlans,
  getPlanById,
  updatePlanById,
  deletePlanById,
};
</file>

<file path="src/services/redis.service.js">
import Redis from 'ioredis';
import config from '../config/config.js';
import logger from '../config/logger.js';

const redisClient = new Redis({
  host: config.redis.host,
  port: config.redis.port,
  lazyConnect: true // Don't crash if Redis is not running immediately
});

const redisSubscriber = new Redis({
  host: config.redis.host,
  port: config.redis.port,
  lazyConnect: true
});

redisClient.on('error', (err) => logger.error('Redis Client Error', err));
redisClient.on('connect', () => logger.info('Redis Client Connected'));
redisSubscriber.on('error', (err) => logger.error('Redis Subscriber Error', err));

const connectRedis = async () => {
    // No await here, let it connect in background
    redisClient.connect().catch(err => logger.error('Redis Client Initial Connection Error', err));
    redisSubscriber.connect().catch(err => logger.error('Redis Subscriber Initial Connection Error', err));
}

export {
  redisClient,
  redisSubscriber,
  connectRedis
};
</file>

<file path="src/services/scheduler.service.js">
import cron from 'node-cron';
import { economicService } from './economic.service.js';
import notificationService from './notification.service.js';
import logger from '../config/logger.js';
import User from '../models/User.js';
import Setting from '../models/Setting.js';
import Announcement from '../models/Announcement.js';
import marketDataService from './marketData.service.js';

const initScheduler = () => {
    logger.info('Initializing Scheduler Service...');

    // Task 1: Fetch Economic Events Daily at 00:00
    cron.schedule('0 0 * * *', async () => {
        logger.info('Running Daily Economic Event Fetch...');
        const today = new Date();
        const pastDate = new Date(today);
        pastDate.setDate(today.getDate() - 7);
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        
        const from = pastDate.toISOString().split('T')[0];
        const to = nextWeek.toISOString().split('T')[0];
        
        await economicService.fetchAndStoreEvents(from, to);
    });

    // Task 2: Check for High Impact Alerts every minute
    cron.schedule('* * * * *', async () => {
        // logger.info('Checking for economic alerts...'); // verbose, keep commented or debug
        await economicService.checkAndTriggerAlerts();
    });

    // Task 3: Check for Plan Expiry Reminders (Daily at 10:00 AM)
    cron.schedule('0 10 * * *', async () => {
        logger.info('Running Daily Plan Expiry Check...');
        try {
            // Get Plan Validity Settings
            const setting = await Setting.findOne({ key: 'planValidity' });
            // Default to 3 days if settings or value missing
            const daysBefore = (setting && setting.value && setting.value.preExpiryDays) 
                ? parseInt(setting.value.preExpiryDays) 
                : 3;

            const targetDateStart = new Date();
            targetDateStart.setDate(targetDateStart.getDate() + daysBefore);
            targetDateStart.setHours(0, 0, 0, 0);

            const targetDateEnd = new Date(targetDateStart);
            targetDateEnd.setHours(23, 59, 59, 999);

            // Find users expiring on this target date
            const users = await User.find({
                'subscription.expiresAt': {
                    $gte: targetDateStart,
                    $lte: targetDateEnd
                },
                status: 'Active'
            });

            if (users.length > 0) {
                logger.info(`Found ${users.length} users for renewal reminder.`);
                
                // Create System Announcement to log this event
                await Announcement.create({
                    title: `Renewal Reminders Sent (${daysBefore} Days Pre-Expiry)`,
                    message: `Reminders sent to ${users.length} users expiring on ${targetDateStart.toDateString()}.\nUsers: ${users.map(u => u.name).join(', ')}`,
                    type: 'REMINDER',
                    priority: 'HIGH',
                    targetAudience: { role: 'all' }, // Visible to Admins mostly
                    status: 'Active',
                    isNotificationSent: true // Silent Log (Don't broadcast to users)
                });

                // Trigger actual Push/Email Notification Service here for each user
                for (const user of users) {
                    await notificationService.sendPlanExpiryReminder(user, daysBefore);
                }
            } else {
                logger.info('No users found for renewal reminder today.');
            }
        } catch (error) {
            logger.error('Error in Plan Expiry Scheduler:', error);
        }
    });

    // Task 4: Check for Scheduled Announcements becoming Active (Every Minute)
    cron.schedule('* * * * *', async () => {
        try {
            const now = new Date();
            const announcements = await Announcement.find({
                isActive: true,
                isNotificationSent: false,
                startDate: { $lte: now }
            });

            for (const ann of announcements) {
                logger.info(`Triggering Scheduled Announcement Broadcast: ${ann.title}`);
                await notificationService.scheduleAnnouncementNotifications(ann);
                ann.isNotificationSent = true;
                await ann.save();
            }
        } catch (error) {
            logger.error('Error in Scheduled Announcement Trigger:', error);
        }
    });

    // Task 5: Daily Kite Instrument Sync (8:00 AM IST)
    cron.schedule('0 8 * * *', async () => {
        logger.info('Running Daily Kite Instrument Sync...');
        try {
            await marketDataService.syncInstruments();
            logger.info('Daily Kite Instrument Sync completed.');
        } catch (error) {
            logger.error('Daily Kite Instrument Sync failed:', error);
        }
    });

    // Initial fetch on startup (optional, maybe check if empty?)
    // Initial fetch on startup
    setTimeout(async () => {
        logger.info('Running Startup Economic Event Fetch...');
        const today = new Date();
        const pastDate = new Date(today);
        pastDate.setDate(today.getDate() - 7);
        const nextWeek = new Date(today);
        nextWeek.setDate(today.getDate() + 7);
        
        const from = pastDate.toISOString().split('T')[0];
        const to = nextWeek.toISOString().split('T')[0];
        
        await economicService.fetchAndStoreEvents(from, to);
    }, 5000); // Run 5s after startup
};

export default {
    initScheduler
};
</file>

<file path="src/services/setting.service.js">
import Setting from '../models/Setting.js';

const getSetting = async (key) => {
  const setting = await Setting.findOne({ key });
  return setting ? setting.value : null;
};

const setSetting = async (key, value, description) => {
  const update = { value };
  if (description) update.description = description;
  
  const setting = await Setting.findOneAndUpdate(
    { key },
    update,
    { upsert: true, new: true, setDefaultsOnInsert: true }
  );
  return setting;
};

const getAllSettings = async () => {
  return Setting.find({});
};

export default {
  getSetting,
  setSetting,
  getAllSettings,
};
</file>

<file path="src/services/signal.monitor.js">
import Signal from '../models/Signal.js';
import marketDataService from './marketData.service.js';
import logger from '../config/logger.js';

let activeSignals = [];
let isMonitoring = false;

const startMonitoring = async () => {
    if (isMonitoring) return;

    logger.info('üõ∞Ô∏è Signal Monitor Started (Auto TP/SL Check)...');
    isMonitoring = true;

    // 1. Initial Load of Active Signals
    await refreshSignalCache();

    // 2. Listen to Market Data
    marketDataService.on('price_update', handlePriceUpdate);
};

const stopMonitoring = () => {
    logger.info('üõë Signal Monitor Stopped.');
    isMonitoring = false;
    marketDataService.off('price_update', handlePriceUpdate);
    activeSignals = [];
};

const refreshSignalCache = async () => {
    try {
        // Fetch specific statuses that should be monitored
        const signals = await Signal.find({ 
            status: { $in: ['Active', 'Open'] } 
        });
        activeSignals = signals;
        logger.info(`‚ôªÔ∏è Signal Cache Refreshed. Monitoring ${signals.length} active signals.`);
    } catch (e) {
        logger.error('Failed to refresh signal cache', e);
    }
};

const handlePriceUpdate = async (tick) => {
    if (!isMonitoring || activeSignals.length === 0) return;

    // Filter signals for this symbol
    const relevantSignals = activeSignals.filter(s => s.symbol === tick.symbol);

    for (const signal of relevantSignals) {
        await checkSignal(signal, tick.price);
    }
};

const checkSignal = async (signal, currentPrice) => {
    let newStatus = null;
    let exitPrice = null;

    // Parse Target/Stoploss (ensure they are numbers)
    const sl = signal.stopLoss;
    const t1 = signal.targets?.target1;
    const t2 = signal.targets?.target2;
    const t3 = signal.targets?.target3;

    // Logic for BUY
    if (signal.type === 'BUY') {
        // Stoploss Hit
        if (currentPrice <= sl) {
            newStatus = 'Stoploss Hit';
            exitPrice = sl; // Or actual currentPrice (slippage) - using SL level for now
        }
        // Target Hit (Any target for now marks it as Target Hit, distinct logic can be added for partials)
        else if (currentPrice >= t1) {
            newStatus = 'Target Hit';
            exitPrice = t1;
        }
    } 
    // Logic for SELL
    else if (signal.type === 'SELL') {
        // Stoploss Hit
        if (currentPrice >= sl) {
            newStatus = 'Stoploss Hit';
            exitPrice = sl; 
        }
        // Target Hit
        else if (currentPrice <= t1) {
            newStatus = 'Target Hit';
            exitPrice = t1;
        }
    }

    if (newStatus) {
        await updateSignalStatus(signal, newStatus, currentPrice);
    }
};

const updatingSignals = new Set();

const updateSignalStatus = async (signal, status, closePrice) => {
    const signalIdStr = signal._id.toString();
    if (updatingSignals.has(signalIdStr)) return;
    
    updatingSignals.add(signalIdStr);
    try {
        logger.info(`üîî Auto-Update: Signal ${signal.symbol} marked as ${status} @ ${closePrice}`);
        
        // Remove from local cache IMMEDIATELY to prevent further checks
        activeSignals = activeSignals.filter(s => s._id.toString() !== signalIdStr);

        // Update DB
        await Signal.findByIdAndUpdate(signal._id, {
            status: status,
            exitPrice: closePrice,
            closedAt: new Date(),
            notes: (signal.notes || '') + `\n[Auto] ${status} triggered at ${closePrice}`
        });

    } catch (e) {
        logger.error(`Failed to auto-update signal ${signal._id}`, e);
        // If it failed, maybe we should add it back? 
        // But better to just let the next reload refresh it.
    } finally {
        updatingSignals.delete(signalIdStr);
    }
};

// Export refresh for external triggers (e.g. when new signal created)
export const reloadSignals = refreshSignalCache;

export default {
    start: startMonitoring,
    stop: stopMonitoring,
    reload: refreshSignalCache
};
</file>

<file path="src/services/signal.service.js">
import Signal from '../models/Signal.js';
import announcementService from './announcement.service.js';
import logger from '../config/logger.js';
import { broadcastToAll } from './websocket.service.js';

const mapSignalToCategory = (signalBody) => {
  const { symbol, segment } = signalBody;
  const sym = symbol ? symbol.toUpperCase() : '';
  const seg = segment ? segment.toUpperCase() : '';

  // 1. High Priority: Crypto Detection (USDT pairs)
  if (sym.includes('USDT') || sym.includes('USD') && (seg === 'CRYPTO' || seg === 'BINANCE')) return 'CRYPTO';

  if (sym.includes('NIFTY') && !sym.includes('BANK') && !sym.includes('FIN')) return 'NIFTY_OPT';
  if (sym.includes('BANKNIFTY')) return 'BANKNIFTY_OPT';
  if (sym.includes('FINNIFTY')) return 'FINNIFTY_OPT';
  if (seg === 'MCX' || seg === 'COMMODITY') return 'MCX_FUT';
  if (seg === 'CDS' || seg === 'CURRENCY') return 'CURRENCY';
  if (seg === 'CRYPTO') return 'CRYPTO';
  if (seg === 'EQ' || seg === 'EQUITY') return 'EQUITY_INTRA'; // Default to Intra
  
  return 'EQUITY_INTRA'; // Fallback
};

const signalCreationGuard = new Map();

// Cleanup old entries every 5 minutes
setInterval(() => {
  const now = Date.now();
  const fiveMinutesAgo = now - 5 * 60 * 1000;
  for (const [key, timestamp] of signalCreationGuard.entries()) {
    if (timestamp < fiveMinutesAgo) {
      signalCreationGuard.delete(key);
    }
  }
}, 5 * 60 * 1000);

const createSignal = async (signalBody, user) => {
  // Normalize symbol for consistent matching
  const normalizedSymbol = signalBody.symbol?.toUpperCase().trim();
  const normalizedPrice = Math.round(parseFloat(signalBody.entryPrice) * 100) / 100; // Round to 2 decimals
  
  // Global Deduplication Guard (Prevent identical signals in 5 minutes)
  const dedupKey = `${normalizedSymbol}_${signalBody.type}_${normalizedPrice}`;
  const now = Date.now();
  
  if (signalCreationGuard.has(dedupKey)) {
    const lastCreated = signalCreationGuard.get(dedupKey);
    const timeSinceLastSignal = now - lastCreated;
    
    // Block if created within last 5 minutes (300 seconds)
    if (timeSinceLastSignal < 300000) {
      logger.warn(`[SIGNAL_GUARD] Blocking duplicate signal for ${dedupKey} (${Math.round(timeSinceLastSignal/1000)}s ago)`);
      return null;
    }
  }
  
  signalCreationGuard.set(dedupKey, now);

  // Auto-map category if missing
  if (!signalBody.category) {
      signalBody.category = mapSignalToCategory(signalBody);
  }

  const signal = await Signal.create({ ...signalBody, createdBy: user.id });
  
  // Create Announcement for the Feed
  try {
      const tpDetails = [
          signal.targets?.target1 ? `TP1: ${signal.targets.target1}` : null,
          signal.targets?.target2 ? `TP2: ${signal.targets.target2}` : null,
          signal.targets?.target3 ? `TP3: ${signal.targets.target3}` : null
      ].filter(t => t).join(' | ');

      await announcementService.createAnnouncement({
          title: `üöÄ New Signal: ${signal.symbol} ${signal.type}`,
          message: `Entry: ${signal.entryPrice}\n${tpDetails}\nSL: ${signal.stopLoss}`,
          type: 'SIGNAL',
          priority: 'NORMAL',
          targetAudience: { role: 'all', planValues: [] },
          isActive: true
      });
  } catch (e) {
      logger.error('Failed to create announcement for signal', e);
  }

  // Publish to Redis for Notification Service
  try {
      const { redisClient } = await import('./redis.service.js');
      // Payload for notification service
      const payload = JSON.stringify({ 
          ...signal.toJSON(), 
          user: user.id,
          subType: 'SIGNAL_NEW'  // Explicitly tell worker to use New Signal Template
      }); 
      await redisClient.publish('signals', payload);
      logger.info(`Published new signal ${signal.id} to Redis 'signals' channel`);
  } catch (e) {
      logger.error('Failed to publish signal to Redis', e);
  }
  
  return signal;
};

const querySignals = async (filter, options) => {
  const page = options.page ? parseInt(options.page) : 1;
  const limit = options.limit ? parseInt(options.limit) : 10;
  const skip = (page - 1) * limit;

  const [totalResults, results] = await Promise.all([
    Signal.countDocuments(filter),
    Signal.find(filter).sort({ createdAt: -1 }).skip(skip).limit(limit)
  ]);

  const totalPages = Math.ceil(totalResults / limit);

  return {
    results,
    page,
    limit,
    totalPages,
    totalResults
  };
};

const getSignalStats = async () => {
  const stats = await Signal.aggregate([
    {
      $group: {
        _id: null,
        totalSignals: { $sum: 1 },
        activeSignals: {
          $sum: {
            $cond: [{ $in: ["$status", ["Open", "Active", "Paused"]] }, 1, 0]
          }
        },
        closedSignals: {
          $sum: {
            $cond: [{ $eq: ["$status", "Closed"] }, 1, 0]
          }
        },
        targetHit: {
          $sum: {
            $cond: [{ $eq: ["$status", "Target Hit"] }, 1, 0]
          }
        },
        stoplossHit: {
          $sum: {
            $cond: [{ $eq: ["$status", "Stoploss Hit"] }, 1, 0]
          }
        }
      }
    }
  ]);

  const data = stats[0] || { totalSignals: 0, activeSignals: 0, closedSignals: 0, targetHit: 0, stoplossHit: 0 };
  
  // Success Rate = (Target Hit) / (Target Hit + Stoploss Hit) * 100
  // Or (Target Hit) / (Total Closed) ? Usually Target vs SL.
  const outcomes = data.targetHit + data.stoplossHit;
  const successRate = outcomes > 0 ? Math.round((data.targetHit / outcomes) * 100) : 0;

  return {
    ...data,
    successRate
  };
};

const updateSignalById = async (signalId, updateBody) => {
  const signal = await Signal.findById(signalId);
  if (!signal) {
     throw new Error('Signal not found');
  }
  // Auto-map category on update if segment/symbol changed or category missing
  if ((updateBody.symbol || updateBody.segment) && !updateBody.category) {
     // Merge current signal data with updates to map correctly
     const merged = { ...signal.toObject(), ...updateBody };
     updateBody.category = mapSignalToCategory(merged);
  } else if (!signal.category && !updateBody.category) {
      // First time mapping for legacy signals
      updateBody.category = mapSignalToCategory(signal);
  }

  Object.assign(signal, updateBody);
  
  // Status update broadcast
  if (updateBody.status || updateBody.report) {
       try {
           broadcastToAll({ type: 'update_signal', payload: signal });

          // Notification Logic
          const { redisClient } = await import('./redis.service.js');
          let subType = null;
          let notificationData = { ...signal.toJSON() }; // Use signal.toJSON() for full refreshed document

          if (updateBody.status === 'Target Hit') {
              subType = 'SIGNAL_TARGET';
              notificationData.targetLevel = 'TP1'; // Logic to detect which target? usually TP1
          } else if (updateBody.status === 'Stoploss Hit') {
              subType = 'SIGNAL_STOPLOSS';
          } else if (updateBody.report || updateBody.notes || updateBody.status) {
              // Generic Update
              subType = 'SIGNAL_UPDATE';
              notificationData.updateMessage = updateBody.notes || updateBody.report || `Status changed to ${updateBody.status}`;
          }

          if (subType) {
              await redisClient.publish('signals', JSON.stringify({
                  ...notificationData,
                  subType
              }));
              logger.info(`Published ${subType} notification for signal ${signalId}`);
          }

      } catch (e) {
          logger.error('Failed to emit socket/redis event for update signal', e);
      }
  }

  await signal.save();
  return signal;
};

const deleteSignalById = async (signalId) => {
  const signal = await Signal.findById(signalId);
  if (!signal) {
    throw new Error('Signal not found');
  }
  await signal.deleteOne();
  return signal;
};

export default {
  createSignal,
  querySignals,
  getSignalStats,
  updateSignalById,
  deleteSignalById,
};
</file>

<file path="src/services/startupOptimizer.js">
import requestQueue from '../utils/requestQueue.js';
import allTickService from './alltick.service.js';
import logger from '../config/logger.js';

class StartupOptimizer {
    constructor() {
        this.phases = {
            1: { name: 'ESSENTIAL', delay: 0, priority: 1, limit: 2 },
            2: { name: 'IMPORTANT', delay: 5000, priority: 2, limit: 5 },
            3: { name: 'BACKGROUND', delay: 30000, priority: 3, limit: 3 } // Batch 3
        };
        
        // Configuration
        this.timeframes = {
            phase1: ['5', '15', '60'],
            phase2: ['30', '240'], 
            phase3: ['D']
        };
    }

    /**
     * Start the Optimized Startup Sequence
     * @param {Object} marketDataService - Reference to main service
     */
    async start(marketDataService) {
        logger.info('[StartupOptimizer] Starting Smart Sequence...');
        
        const allSymbols = Object.keys(marketDataService.symbols || {});
        
        // 1. Identify Groups
        const dashboardSymbols = ['BTCUSD', 'XAUUSD', 'NSE:NIFTY 50-INDEX', 'NSE:NIFTY BANK-INDEX']; // Max 2 effectively
        const watchlistSymbols = allSymbols.filter(s => !dashboardSymbols.includes(s)).slice(0, 5); // Mock 'Watchlist'
        const backgroundSymbols = allSymbols.filter(s => !dashboardSymbols.includes(s) && !watchlistSymbols.includes(s));

        // --- Phase 1: ESSENTIAL (0s) ---
        await this._processPhase(1, dashboardSymbols, this.timeframes.phase1, marketDataService);

        // --- Phase 2: IMPORTANT (5s) ---
        setTimeout(() => {
            this._processPhase(2, watchlistSymbols, this.timeframes.phase2, marketDataService);
        }, this.phases[2].delay);

        // --- Phase 3: BACKGROUND (30s+) ---
        setTimeout(() => {
             this._processBackground(backgroundSymbols, marketDataService);
        }, this.phases[3].delay);
    }

    async _processPhase(phaseId, symbols, tfs, service) {
        const config = this.phases[phaseId];
        logger.info(`[StartupOptimizer] Phase ${phaseId} (${config.name}): Fetching ${symbols.length} symbols`);

        // Limit concurrent symbols? RequestQueue handles it, but we can limit here to be safe.
        const limitedSymbols = symbols.slice(0, config.limit);

        for (const symbol of limitedSymbols) {
            for (const tf of tfs) {
                this._fetchSafe(symbol, tf, config.priority, service);
            }
        }
    }

    async _processBackground(symbols, service) {
        logger.info(`[StartupOptimizer] Phase 3 (BACKGROUND): Queuing ${symbols.length} symbols...`);
        
        // Batch processing with delays
        const batchSize = this.phases[3].limit;
        const tfs = this.timeframes.phase3;

        for (let i = 0; i < symbols.length; i += batchSize) {
            const batch = symbols.slice(i, i + batchSize);
            
            // Stagger batches by 2 seconds
            setTimeout(() => {
                batch.forEach(symbol => {
                    tfs.forEach(tf => {
                         this._fetchSafe(symbol, tf, 3, service);
                    });
                });
            }, (i / batchSize) * 2000);
        }
    }

    async _fetchSafe(symbol, tf, priority, service) {
        // Calculate 'from' based on TF (e.g. last 100 candles)
        // Simplified: Fetch last 24h or 7d?
        // Prompt says "Minimizes initial API calls".
        // Let's rely on getHistory default range logic or provide a smart range.
        
        // Smart Range:
        const now = Math.floor(Date.now() / 1000);
        let duration = 86400 * 2; // 2 Days default
        if (tf === 'D') duration = 86400 * 30; // 30 Days
        
        const from = new Date((now - duration) * 1000);
        const to = new Date(now * 1000);

        try {
            await service.getHistory(symbol, tf, from, to);
        } catch (e) {
            // Emergency Brake
            if (e.response && e.response.status === 429) {
                logger.warn(`[StartupOptimizer] 429 Detected on ${symbol}. ACTIVATING EMERGENCY BRAKE.`);
                requestQueue.pause(60000); // 60s Pause
            }
        }
    }
}

export default new StartupOptimizer();
</file>

<file path="src/services/strategy.service.js">
import Strategy from '../models/Strategy.js';
import Signal from '../models/Signal.js';
import marketDataService from './marketData.service.js';
import signalService from './signal.service.js';
import logger from '../config/logger.js';
import User from '../models/User.js';

// In-Memory Strategy Cache (For Microsecond Access)
let activeStrategies = [];
let isEngineRunning = false;
const processingPending = new Map(); // Global pending guard

const startEngine = async () => {
    if (isEngineRunning) return;
    
    logger.info('üöÄ Strategy Engine Starting (Event-Driven Mode)...');
    isEngineRunning = true;
    
    // 1. Initial Cache Load
    await refreshCache();

    // 2. Subscribe to Market Data Events (Push Architecture)
    marketDataService.on('price_update', handlePriceUpdate);
};

const stopEngine = () => {
    if (!isEngineRunning) return;
    
    logger.info('üõë Strategy Engine Stopped.');
    isEngineRunning = false;
    
    // Unsubscribe
    marketDataService.off('price_update', handlePriceUpdate);
    activeStrategies = [];
};

// Refresh Cache (Called on Start and when User updates Strategy)
const refreshCache = async () => {
    try {
        const strategies = await Strategy.find({ status: 'Active' });
        activeStrategies = strategies;
        logger.info(`‚ôªÔ∏è Strategy Cache Refreshed. Loaded ${strategies.length} active bots.`);
    } catch (e) {
        logger.error('Failed to refresh strategy cache', e);
    }
};

// Event Handler: Called instantly on every tick
const handlePriceUpdate = async (tick) => {
    if (!isEngineRunning) return;

    // Filter strategies interested in this symbol
    const relevantStrategies = activeStrategies.filter(s => s.symbol === tick.symbol);
    
    for (const strategy of relevantStrategies) {
        const isMatch = evaluateLogic(strategy.logic, tick);
        
        if (isMatch) {
            await triggerSignal(strategy, tick);
        }
    }
};

// Evaluation Logic
const evaluateLogic = (logic, tick) => {
    const rule = logic?.rules?.[0];
    if (!rule) return false;

    // --- PROTECTIVE FILTER ---
    // The basic engine only supports simple Price vs Value comparisons.
    // Advanced indicators like Supertrend/PSAR are handled by HybridStrategyService.
    const advancedIndicators = ['Supertrend', 'PSAR', 'RSI', 'EMA', 'SMA'];
    if (advancedIndicators.includes(rule.indicator)) {
        return false; 
    }

    const currentPrice = tick.price;
    const threshold = rule.value; 

    if (rule.operator === '>') return currentPrice > threshold;
    if (rule.operator === '<') return currentPrice < threshold;
    if (rule.operator === '>=') return currentPrice >= threshold;
    if (rule.operator === '<=') return currentPrice <= threshold;
    if (rule.operator === 'CROSS_ABOVE') return currentPrice > threshold; // Simple fallback
    if (rule.operator === 'CROSS_BELOW') return currentPrice < threshold;
    
    return false;
};

const triggerSignal = async (strategy, tick) => {
    // 1. Pending Guard
    const pendingKey = `${strategy._id.toString()}_${tick.symbol}`;
    if (processingPending.has(pendingKey)) return;

    // 2. Cooldown Validation
    const cooldownMs = 30 * 1000;
    const now = new Date();
    
    if (strategy.stats?.lastSignalAt) {
        const diff = now - new Date(strategy.stats.lastSignalAt);
        if (diff < cooldownMs) return;
    }

    // Set Pending & Update Local Cooldown IMMEDIATELY
    processingPending.set(pendingKey, true);
    if (strategy.stats) strategy.stats.lastSignalAt = now;

    logger.info(`‚ö° SIGNAL: ${strategy.name} triggered on ${tick.symbol} @ ${tick.price}`);

    const signalData = {
        strategyId: strategy._id,
        strategyName: strategy.name,
        timeframe: strategy.timeframe,
        symbol: strategy.symbol,
        segment: strategy.segment,
        type: strategy.action === 'BUY' ? 'BUY' : 'SELL',
        entryPrice: tick.price,
        stopLoss: parseFloat((tick.price * 0.98).toFixed(2)),
        targets: {
            target1: parseFloat((tick.price * 1.02).toFixed(2)),
            target2: parseFloat((tick.price * 1.04).toFixed(2)),
            target3: parseFloat((tick.price * 1.06).toFixed(2))
        },
        notes: `ü§ñ Bot Signal: ${strategy.name}`,
        isFree: false
    };

    const systemUser = { id: strategy.user, role: 'admin' }; 
    
    try {
        await signalService.createSignal(signalData, systemUser);
        
        // Update Stats in DB (Async, don't block engine)
        // Note: In high-scale system, we'd queue this update too.
        await Strategy.findByIdAndUpdate(strategy._id, {
            $inc: { 'stats.totalSignals': 1 },
            'stats.lastSignalAt': new Date()
        });

        // Update local cache to reflect cooldown immediately
        const cachedStrat = activeStrategies.find(s => s._id.toString() === strategy._id.toString());
        if (cachedStrat) {
            if (!cachedStrat.stats) cachedStrat.stats = {};
            cachedStrat.stats.lastSignalAt = new Date();
        }

    } catch (e) {
        logger.error('Failed to process signal', e);
    } finally {
        processingPending.delete(pendingKey);
    }
};

// Export refreshCache too so Controllers can call it on update
export const reloadStrategies = refreshCache;

const seedStrategies = async (user = null) => {
    const hybrid = await Strategy.findOne({ name: 'Hybrid Strategy', isSystem: true });
    if (!hybrid) {
         let userId = user?.id;
         if (!userId) {
             const admin = await User.findOne({ role: 'admin' });
             userId = admin?._id;
         }

         if (userId) {
            await Strategy.create({
                user: userId,
                name: 'Hybrid Strategy',
                symbol: 'NSE:NIFTYBANK-INDEX',
                timeframe: '5m',
                segment: 'FNO',
                status: 'Active',
                isSystem: true,
                isDefault: true,
                logic: {
                    condition: 'AND',
                    rules: [
                        { indicator: 'Supertrend', params: { period: 10, multiplier: 3 }, operator: 'CROSS_ABOVE', value: 0 },
                        { indicator: 'PSAR', params: { step: 0.02, max: 0.2 }, operator: '<', value: 'CLOSE' }
                    ]
                }
            });
            logger.info('‚úÖ Hybrid Strategy seeded successfully');
         } else {
             logger.warn('‚ö†Ô∏è Could not find an admin user to assign Hybrid Strategy');
         }
    }
    return { success: true };
};

export default {
    startEngine,
    stopEngine,
    reloadStrategies: refreshCache,
    seedStrategies
};
</file>

<file path="src/services/subBroker.service.js">
import SubBroker from '../models/SubBroker.js';
import User from '../models/User.js';
import Commission from '../models/Commission.js';
import httpStatus from 'http-status';

/**
 * Create a sub-broker
 * @param {Object} subBrokerBody
 * @returns {Promise<SubBroker>}
 */
const createSubBroker = async (subBrokerBody) => {
    if (await SubBroker.isEmailTaken(subBrokerBody.email)) {
        throw new Error('Email already taken');
    }
    return SubBroker.create(subBrokerBody);
};

/**
 * Query for sub-brokers
 * @param {Object} filter - Mongo filter
 * @param {Object} options - Query options
 * @returns {Promise<QueryResult>}
 */
const getSubBrokers = async (filter = {}, options = {}) => {
  return SubBroker.aggregate([
    { $match: filter },
    {
      $lookup: {
        from: 'users',
        let: { sbId: '$_id' },
        pipeline: [
          { $match: {
              $expr: {
                $or: [
                   { $eq: ['$subBrokerId', '$$sbId'] },
                   { $eq: ['$referral.referredBy', '$$sbId'] } 
                ]
              }
          }},
          { $count: "count" }
        ],
        as: 'clientStats'
      }
    },
    {
      $lookup: {
        from: 'commissions',
        localField: '_id',
        foreignField: 'subBroker',
        pipeline: [
           { $project: { amount: 1 } },
           { $group: { _id: null, total: { $sum: "$amount" } } }
        ],
        as: 'revenueStats'
      }
    },
    {
       $addFields: {
          totalClients: { $ifNull: [{ $arrayElemAt: ["$clientStats.count", 0] }, 0] },
          totalRevenue: { $ifNull: [{ $arrayElemAt: ["$revenueStats.total", 0] }, 0] },
          id: '$_id' 
       }
    },
    { $sort: { createdAt: -1 } }
  ]);
};

/**
 * Get sub-broker by id
 * @param {ObjectId} id
 * @returns {Promise<SubBroker>}
 */
const getSubBrokerById = async (id) => {
  return SubBroker.findById(id);
};

/**
 * Update sub-broker by id
 * @param {ObjectId} subBrokerId
 * @param {Object} updateBody
 * @returns {Promise<SubBroker>}
 */
const updateSubBrokerById = async (subBrokerId, updateBody) => {
  const subBroker = await getSubBrokerById(subBrokerId);
  if (!subBroker) {
    const error = new Error('SubBroker not found');
    error.statusCode = httpStatus.NOT_FOUND;
    throw error;
  }
  if (updateBody.email && (await SubBroker.isEmailTaken(updateBody.email, subBrokerId))) {
    throw new Error('Email already taken');
  }
  Object.assign(subBroker, updateBody);
  await subBroker.save();
  return subBroker;
};

/**
 * Delete sub-broker by id
 * @param {ObjectId} subBrokerId
 * @returns {Promise<SubBroker>}
 */
const deleteSubBrokerById = async (subBrokerId) => {
  const subBroker = await getSubBrokerById(subBrokerId);
  if (!subBroker) {
    const error = new Error('SubBroker not found');
    error.statusCode = httpStatus.NOT_FOUND;
    throw error;
  }
  await subBroker.deleteOne();
  return subBroker;
};

// --- Existing Logic Preserved (but updated to check SubBroker model if needed) ---

const getSubBrokerClients = async (subBrokerId) => {
  // Support both new direct subBrokerId and legacy referral structure
  return User.find({ 
      $or: [
          { subBrokerId: subBrokerId },
          { 'referral.referredBy': subBrokerId }
      ]
  });
};

const getCommissions = async (subBrokerId) => {
    return Commission.find({ subBroker: subBrokerId }).populate('user', 'name').populate('transaction');
};

const recordCommission = async (transaction, user, plan) => {
    // Check if user is referred by a sub-broker
    const referrerId = user.subBrokerId || (user.referral && user.referral.referredBy);
    
    if (referrerId) {
        // Try finding in SubBroker model first (New Way)
        let subBroker = await SubBroker.findById(referrerId);
        
        // Fallback to User model (Old Way - for backward compatibility if any)
        if (!subBroker) {
             const userBroker = await User.findById(referrerId);
             if (userBroker && userBroker.role === 'sub-broker') {
                 subBroker = userBroker; // Treat as sub-broker
             }
        }
        
        if (subBroker) {
            // Determine commission
            let commissionAmount = 0;
            let commissionRate = 0;

            if (subBroker.commission && subBroker.commission.type === 'FIXED') {
                 commissionAmount = subBroker.commission.value;
            } else if (subBroker.commission && subBroker.commission.type === 'PERCENTAGE') {
                 commissionRate = subBroker.commission.value;
                 commissionAmount = (transaction.amount * commissionRate) / 100;
            } else {
                 // Default Fallback
                 commissionRate = 10;
                 commissionAmount = (transaction.amount * commissionRate) / 100;
            }

            await Commission.create({
                subBroker: subBroker.id,
                user: user.id,
                transaction: transaction.id,
                amount: commissionAmount,
                percentage: commissionRate,
                status: 'PENDING'
            });
        }
    }
};

const processPayout = async (subBrokerId) => {
    return Commission.updateMany(
        { subBroker: subBrokerId, status: 'PENDING' },
        { status: 'PAID' }
    );
};

export default {
  createSubBroker,
  getSubBrokers,
  getSubBrokerById,
  updateSubBrokerById,
  deleteSubBrokerById,
  getSubBrokerClients,
  getCommissions,
  recordCommission,
  processPayout
};
</file>

<file path="src/services/subscription.service.js">
import Segment from '../models/Segment.js';
import UserSubscription from '../models/UserSubscription.js';
import AdminSetting from '../models/AdminSetting.js';
import httpStatus from 'http-status';
import ApiError from '../utils/ApiError.js';

// --- Core Service Functions ---

/**
 * Get all active segments
 * @returns {Promise<Array>}
 */
const getAllSegments = async () => {
  return Segment.find({ is_active: true }).select('segment_code name base_price');
};

/**
 * Get all subscriptions (Admin)
 * @returns {Promise<Array>}
 */
const getAllSubscriptions = async () => {
  return UserSubscription.find()
    .populate('user_id', 'name email mobile')
    .sort({ createdAt: -1 });
};

/**
 * Purchase Segments
 * @param {string} userId - User ID
 * @param {Array<string>} segmentCodes - List of requested segments
 * @param {string} planType - 'demo' or 'premium'
 * @returns {Promise<Object>} - Subscription details
 */
const purchaseSegments = async (userId, segmentCodes, planType = 'premium') => {
  // 1. Validation: Maximum 1 segment for Demo
  if (planType === 'demo' && segmentCodes.length > 1) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Demo plan allows maximum 1 segment.');
  }

  // 2. Validate Segments & Calculate Price
  const validSegments = await Segment.find({ 
    segment_code: { $in: segmentCodes },
    is_active: true
  });

  if (validSegments.length !== segmentCodes.length) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'One or more invalid or inactive segments selected.');
  }

  // 3. Simple Sum (No Discounts)
  const totalAmount = planType === 'demo' 
    ? 0 
    : validSegments.reduce((sum, seg) => sum + seg.base_price, 0);

  // 4. Determine Validity
  let settings = await AdminSetting.findOne();
  if (!settings) {
    // Creating default if missing
    settings = await AdminSetting.create({ demo_validity_days: 1, premium_validity_days: 30 });
  }

  const validityDays = planType === 'demo' ? settings.demo_validity_days : settings.premium_validity_days;
  
  const startDate = new Date();
  const endDate = new Date();
  endDate.setDate(startDate.getDate() + validityDays);

  // 5. Create Subscription
  // Note: We expire previous active subscriptions for simplicity as per "fresh start" 
  // or we could append. Requirement says "User multiple segments purchase kar sake".
  // Simplest approach: Deactivate old active ones, create new one.
  await UserSubscription.updateMany(
    { user_id: userId, status: 'active' },
    { status: 'cancelled', is_active: false }
  );

  const subscription = await UserSubscription.create({
    user_id: userId,
    segments: segmentCodes,
    total_amount: totalAmount,
    start_date: startDate,
    end_date: endDate,
    plan_type: planType,
    status: 'active'
  });

  return subscription;
};

/**
 * Check User Subscription Status (Full Details)
 * @param {string} userId
 */
const getSubscriptionStatus = async (userId) => {
  const sub = await UserSubscription.findOne({ 
    user_id: userId, 
    status: 'active', 
    end_date: { $gt: new Date() } 
  });
  return sub || null;
};

/**
 * CORE ACCESS CHECK LOGIC
 * @param {string} userId 
 * @param {string} segmentCode 
 * @returns {Promise<boolean>}
 */
const checkAccess = async (userId, segmentCode) => {
  // 1. Find ACTIVE subscription for this user
  // 2. Check if not expired
  // 3. Check if segment exists in array
  const count = await UserSubscription.countDocuments({
    user_id: userId,
    status: 'active',
    end_date: { $gt: new Date() }, // Not expired
    segments: segmentCode // Mongoose array queries check for existence
  });

  return count > 0;
};

// --- Seed Helper (Optional, for first run) ---
const seedDefaults = async () => {
    const count = await Segment.countDocuments();
    if (count === 0) {
        const defaults = [
            { segment_code: 'EQUITY', name: 'Equity Trading', base_price: 25000 },
            { segment_code: 'CRYPTO', name: 'Crypto Trading', base_price: 25000 },
            { segment_code: 'COMMODITY', name: 'Commodity Trading', base_price: 25000 },
            { segment_code: 'FOREX', name: 'Forex Trading', base_price: 25000 },
            { segment_code: 'OPTIONS', name: 'Options Trading', base_price: 25000 },
        ];
        await Segment.insertMany(defaults);
        console.log('Default segments seeded');
    }
};

export default {
  getAllSegments,
  getAllSubscriptions,
  purchaseSegments,
  getSubscriptionStatus,
  checkAccess,
  seedDefaults
};
</file>

<file path="src/services/technicalAnalysis.service.js">
import { SMA } from 'technicalindicators';

class TechnicalAnalysisService {
    
    /**
     * Custom Supertrend Calculation matching Pine Script
     * @param {Array} candles - Array of { high, low, close }
     * @param {Number} period - ATR Period (default 10)
     * @param {Number} multiplier - ATR Multiplier (default 3.0)
     * @returns {Object} { value, trend: 1 (Up) | -1 (Down) }
     */
    calculateSupertrend(candles, period = 10, multiplier = 3.0) {
        if (!candles || candles.length < period + 1) return { value: 0, trend: 0 };

        // 1. Calculate TR (True Range)
        const trs = [];
        for (let i = 0; i < candles.length; i++) {
            if (i === 0) {
                trs.push(candles[i].high - candles[i].low);
                continue;
            }
            const high = candles[i].high;
            const low = candles[i].low;
            const prevClose = candles[i - 1].close;
            
            const tr = Math.max(
                high - low,
                Math.abs(high - prevClose),
                Math.abs(low - prevClose)
            );
            trs.push(tr);
        }

        // 2. Calculate ATR (SMA of TR)
        // input: atr2 = sma(tr, Periods)
        // input: atr = changeATR ? atr(Periods) : atr2
        // Assuming we use SMA as per the script's default "atr2" if changeATR is false.
        // But Pine's `atr()` function is usually RMA (Wilder's MA).
        // The script says: atr2 = sma(tr, Periods). atr = changeATR ? atr(Periods) : atr2.
        // If changeATR is true (default), it uses built-in atr() which is RMA.
        // We will implement RMA (Wilder's Smoothing) for better accuracy with default Pine behavior.

        let atr = [];
        // First ATR is SMA
        let sumTR = 0;
        for(let i=0; i<period; i++) sumTR += trs[i];
        atr[period-1] = sumTR / period;

        // Subsequent are RMA: (prevATR * (n-1) + currentTR) / n
        for(let i=period; i<candles.length; i++) {
            atr[i] = (atr[i-1] * (period - 1) + trs[i]) / period;
        }

        // 3. Calculate Supertrend
        // up=src-(Multiplier*atr)
        // dn=src+(Multiplier*atr)
        // We calculate for the whole series to establish trend continuity
        
        let up = new Array(candles.length).fill(0);
        let dn = new Array(candles.length).fill(0);
        let trend = new Array(candles.length).fill(1); // 1 = Up, -1 = Down

        for (let i = period; i < candles.length; i++) {
            const src = (candles[i].high + candles[i].low) / 2; // hl2
            const currentATR = atr[i];
            
            let currentUp = src - (multiplier * currentATR);
            let currentDn = src + (multiplier * currentATR);

            // prevUp = nz(up[1], up)
            // up := close[1] > up1 ? max(up, up1) : up
            const prevUp = up[i-1] || currentUp;
            const prevClose = candles[i-1].close;
            
            if (prevClose > prevUp) {
                currentUp = Math.max(currentUp, prevUp);
            }
            up[i] = currentUp;

            // prevDn = nz(dn[1], dn)
            // dn := close[1] < dn1 ? min(dn, dn1) : dn
            const prevDn = dn[i-1] || currentDn;
            if (prevClose < prevDn) {
                currentDn = Math.min(currentDn, prevDn);
            }
            dn[i] = currentDn;

            // Trend Logic
            // trend := nz(trend[1], trend)
            // trend := trend == -1 and close > dn1 ? 1 : trend == 1 and close < up1 ? -1 : trend
            let currentTrend = trend[i-1] || 1;
            const close = candles[i].close;

            if (currentTrend === -1 && close > prevDn) {
                currentTrend = 1;
            } else if (currentTrend === 1 && close < prevUp) {
                currentTrend = -1;
            }
            trend[i] = currentTrend;
        }

        const lastIndex = candles.length - 1;
        return {
            value: trend[lastIndex] === 1 ? up[lastIndex] : dn[lastIndex],
            trend: trend[lastIndex],
            trendArray: trend, // Expose full history for flip checks
            isBuy: trend[lastIndex] === 1 && trend[lastIndex-1] === -1,
            isSell: trend[lastIndex] === -1 && trend[lastIndex-1] === 1
        };
    }

    calculatePSAR(candles, step = 0.02, max = 0.2) {
        // Simple implementation or use library. 
        // For accurate "reversal" logic matching Pine, manual might be safest, 
        // but library `technicalindicators` has PSAR.
        // Let's use a simplified custom loop to ensure start/reverse logic matches description.
        
        if (!candles || candles.length < 2) return { value: 0, trend: 'up' };

        // Initial Setup
        let isUp = candles[1].close > candles[0].close;
        let sar = isUp ? candles[0].low : candles[0].high;
        let ep = isUp ? candles[0].high : candles[0].low; // Extreme Point
        let af = step; // Acceleration Factor

        for (let i = 1; i < candles.length; i++) {
            const prevSar = sar;
            
            // Calculate today's SAR
            // SAR = PrevSAR + AF * (PrevEP - PrevSAR)
            sar = prevSar + af * (ep - prevSar);

            // Boundary checks
            const prevLow = candles[i-1].low;
            const prevPrevLow = i > 1 ? candles[i-2].low : prevLow;
            const prevHigh = candles[i-1].high;
            const prevPrevHigh = i > 1 ? candles[i-2].high : prevHigh;

            if (isUp) {
                // If uptrend, SAR cannot be above previous two lows
                sar = Math.min(sar, prevLow, prevPrevLow);
                
                // Check if price penetrates SAR
                if (candles[i].low < sar) {
                    // Reversal to Down
                    isUp = false;
                    sar = ep; // New SAR is old EP
                    ep = candles[i].low; // Reset EP
                    af = step; // Reset AF
                } else {
                    // Continue Uptrend
                    if (candles[i].high > ep) {
                        ep = candles[i].high;
                        af = Math.min(af + step, max);
                    }
                }
            } else {
                // If downtrend, SAR cannot be below previous two highs
                sar = Math.max(sar, prevHigh, prevPrevHigh); // Logic seems inverted in many docs, but standard is: prevent SAR form crossing price "backwards"
                
                // Check if price penetrates SAR
                if (candles[i].high > sar) {
                    // Reversal to Up
                    isUp = true;
                    sar = ep; 
                    ep = candles[i].high;
                    af = step;
                } else {
                    // Continue Downtrend
                    if (candles[i].low < ep) {
                        ep = candles[i].low;
                        af = Math.min(af + step, max);
                    }
                }
            }
        }
        
        return {
            value: sar,
            trend: isUp ? 'up' : 'down'
        };
    }

    /**
     * Identify Higher Highs / Lower Lows (ZigZag-like)
     * @param {Array} candles 
     * @param {Number} depth - Lookback period for pivot
     */
    calculateMarketStructure(candles, depth = 5) {
        if (!candles || candles.length < depth * 2) return { structure: 'consolidation', lastPivot: 'none' };

        // Find pivots
        let pivots = [];
        // Pivot High: High[i] > High[i +/- 1...depth]
        // We scan backwards
        
        const isPivotHigh = (idx) => {
            const h = candles[idx].high;
            for(let j=1; j<=depth; j++) {
                if(idx-j < 0 || candles[idx-j].high > h) return false;
                if(idx+j >= candles.length || candles[idx+j].high > h) return false;
            }
            return true;
        };

        const isPivotLow = (idx) => {
            const l = candles[idx].low;
            for(let j=1; j<=depth; j++) {
                if(idx-j < 0 || candles[idx-j].low < l) return false;
                if(idx+j >= candles.length || candles[idx+j].low < l) return false;
            }
            return true;
        };

        for(let i=depth; i < candles.length - depth; i++) {
            if(isPivotHigh(i)) pivots.push({ type: 'PH', price: candles[i].high, index: i });
            if(isPivotLow(i)) pivots.push({ type: 'PL', price: candles[i].low, index: i });
        }

        // Analyze last 2 identical pivots to determine structure trend
        const highs = pivots.filter(p => p.type === 'PH');
        const lows = pivots.filter(p => p.type === 'PL');

        if(highs.length < 2 || lows.length < 2) return { structure: 'insufficient_data', lastPivot: null };

        const lastPH = highs[highs.length - 1];
        const prevPH = highs[highs.length - 2];
        const lastPL = lows[lows.length - 1];
        const prevPL = lows[lows.length - 2];

        let structure = 'neutral';
        if (lastPH.price > prevPH.price && lastPL.price > prevPL.price) structure = 'HH_HL'; // Uptrend
        else if (lastPH.price < prevPH.price && lastPL.price < prevPL.price) structure = 'LH_LL'; // Downtrend
        else if (lastPH.price > prevPH.price && lastPL.price < prevPL.price) structure = 'expanding';
        else if (lastPH.price < prevPH.price && lastPL.price > prevPL.price) structure = 'consolidation';

        return {
            structure,
            lastPivot: pivots[pivots.length - 1]
        };
    }

    /**
     * Hybrid Analysis Logic (HA + Supertrend + PSAR + Structure)
     * @param {Array} candles 
     * @param {String} timeframeName 
     */
    analyzeTimeframe(candles, timeframeName) {
        if (!candles || candles.length < 20) return { trend: 'NEUTRAL', signal: 'NONE', age: 0, price: 0 };

        // Convert to Heikin Ashi
        const haCandles = [];
        haCandles.push({ ...candles[0] });
        for (let i = 1; i < candles.length; i++) {
            const curr = candles[i];
            const prevHa = haCandles[i - 1];
            const haOpen = (prevHa.open + prevHa.close) / 2;
            const haClose = (curr.open + curr.high + curr.low + curr.close) / 4;
            haCandles.push({
                time: curr.time,
                open: haOpen, high: Math.max(curr.high, haOpen, haClose),
                low: Math.min(curr.low, haOpen, haClose), close: haClose
            });
        }

        // Indicators
        const st = this.calculateSupertrend(haCandles, 14, 1.5);
        const psar = this.calculatePSAR(haCandles);
        const structure = this.calculateMarketStructure(haCandles, 5);
        
        const lastCandle = candles[candles.length - 1];
        const currentPrice = lastCandle.close;

        const trend = st.trend === 1 ? 'BULLISH' : 'BEARISH';
        
        let signalType = 'HOLD'; 
        if (st.isBuy) signalType = 'BUY';
        if (st.isSell) signalType = 'SELL';
        
        let isStrong = false;
        if (trend === 'BULLISH' && psar.value < currentPrice && structure.structure === 'HH_HL') isStrong = true;
        if (trend === 'BEARISH' && psar.value > currentPrice && structure.structure === 'LH_LL') isStrong = true;

        return {
            timeframe: timeframeName,
            trend,
            signalType,
            price: currentPrice,
            support: st.trend === 1 ? st.value : psar.value,
            resistance: st.trend === -1 ? st.value : psar.value,
            isStrong
        };
    }

    calculateRSI(candles, period = 14) {
        if (!candles || candles.length < period + 1) return 50;

        let gains = 0;
        let losses = 0;

        for (let i = 1; i <= period; i++) {
            const diff = candles[i].close - candles[i - 1].close;
            if (diff >= 0) gains += diff;
            else losses -= diff;
        }

        let avgGain = gains / period;
        let avgLoss = losses / period;

        for (let i = period + 1; i < candles.length; i++) {
            const diff = candles[i].close - candles[i - 1].close;
            const currentGain = diff >= 0 ? diff : 0;
            const currentLoss = diff < 0 ? -diff : 0;

            avgGain = (avgGain * (period - 1) + currentGain) / period;
            avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
        }

        if (avgLoss === 0) return 100;
        const rs = avgGain / avgLoss;
        return 100 - (100 / (1 + rs));
    }
}

export const technicalAnalysisService = new TechnicalAnalysisService();
export default technicalAnalysisService;
</file>

<file path="src/services/token.service.js">
import jwt from 'jsonwebtoken';
import config from '../config/config.js';

const generateToken = (userId, expires, type, secret = config.jwt.secret) => {
  const payload = {
    sub: userId,
    iat: Math.floor(Date.now() / 1000),
    exp: expires,
    type,
  };
  return jwt.sign(payload, secret);
};

const verifyToken = async (token, type) => {
  const payload = jwt.verify(token, config.jwt.secret);
  return payload;
};

const generateAuthTokens = async (user) => {
  const accessTokenExpires = Math.floor(Date.now() / 1000) + config.jwt.expiresIn * 60; // if expiresIn is minutes
  
  // Include did (Device ID) and v (Token Version) for single session check
  const accessToken = jwt.sign({ 
      sub: user.id, 
      role: user.role, 
      v: user.tokenVersion,
      did: user.currentDeviceId 
  }, config.jwt.secret, {
      expiresIn: config.jwt.expiresIn
  });
  
  return {
    access: {
      token: accessToken,
    },
  };
};

export default {
  generateToken,
  generateAuthTokens,
  verifyToken,
};
</file>

<file path="src/services/transaction.service.js">
import Transaction from '../models/Transaction.js';

const createTransaction = async (transactionBody) => {
  return Transaction.create(transactionBody);
};

const getTransactionById = async (id) => {
  return Transaction.findById(id);
};

const updateTransactionStatus = async (transactionId, status, gatewayTransactionId) => {
    const transaction = await getTransactionById(transactionId);
    if (!transaction) return null;
    
    transaction.status = status;
    if (gatewayTransactionId) {
        transaction.gatewayTransactionId = gatewayTransactionId;
    }
    await transaction.save();
    return transaction;
};

export default {
  createTransaction,
  getTransactionById,
  updateTransactionStatus,
};
</file>

<file path="src/services/user.service.js">
import httpStatus from 'http-status';
import User from '../models/User.js';
import ApiError from '../utils/ApiError.js';

const getUserById = async (id) => {
  return User.findById(id);
};

const updateUserById = async (userId, updateBody) => {
  const user = await getUserById(userId);
  if (!user) {
    throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
  }
  
  if (updateBody.email && (await User.isEmailTaken(updateBody.email, userId))) {
    throw new ApiError(httpStatus.BAD_REQUEST, 'Email already taken');
  }
  
  Object.assign(user, updateBody);
  await user.save();
  return user;
};

const updateKyc = async (userId, kycData) => {
    const user = await getUserById(userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }

    user.kyc = { ...user.kyc, ...kycData, status: 'pending' }; // Reset to pending on update
    await user.save();
    return user;
};

const queryUsers = async (filter, options) => {
    const users = await User.paginate(filter, options);
    return users;
};

const deleteUserById = async (userId) => {
    const user = await getUserById(userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    await user.remove();
    return user;
};

const blockUserById = async (userId) => {
    const user = await getUserById(userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    
    // Toggle block status
    user.isBlocked = !user.isBlocked;
    user.status = user.isBlocked ? 'Blocked' : 'Active';
    
    await user.save();
    return user;
};

const liquidateUserById = async (userId) => {
    const user = await getUserById(userId);
    if (!user) {
        throw new ApiError(httpStatus.NOT_FOUND, 'User not found');
    }
    
    // Reset equity and set status to Liquidated
    user.equity = 0;
    user.status = 'Liquidated';
    // Add logic to close all open positions here if transaction service is available
    
    await user.save();
    return user;
};

export default {
  getUserById,
  updateUserById,
  updateKyc,
  queryUsers,
  deleteUserById,
  blockUserById,
  liquidateUserById
};
</file>

<file path="src/services/websocket.service.js">
import { WebSocketServer, WebSocket } from 'ws';
import jwt from 'jsonwebtoken';
import config from '../config/config.js';
import { redisSubscriber } from './redis.service.js';
import logger, { logEmitter } from '../config/logger.js';
import pipeline from '../utils/pipeline/DataPipeline.js';

// Re-subscribe to stats (moved from top)
redisSubscriber.subscribe('market_stats', (err) => {
  if (err) logger.error('Failed to subscribe to market_stats channel');
});

redisSubscriber.on('message', (channel, message) => {
  try {
    const data = JSON.parse(message);
    if (channel === 'market_stats') {
      // We need broadcastToAll which is defined later. 
      // We can't call it here if it's const.
      // We'll move this listener setup INTO initWebSocket or after definitions.
    }
  } catch (error) {
    logger.error('WebSocket Broadcast Error', error);
  }
});

let wss;
const rooms = new Map(); // Map<string, Set<WebSocket>>

const initWebSocket = (server) => {
  wss = new WebSocketServer({ server });

  wss.on('connection', (ws, req) => {
    logger.debug('New WebSocket connection attempt');

    // Handle authentication
    const url = new URL(req.url, `http://${req.headers.host}`);
    const token = url.searchParams.get('token');

    if (token) {
      jwt.verify(token, config.jwt.secret, async (err, decoded) => {
        if (err) {
          logger.error('WebSocket Auth Error:', err.message);
          ws.close(1008, 'Authentication failed');
          return;
        }
        ws.decoded = decoded;
        logger.debug(`WebSocket authenticated for user: ${decoded.sub || 'unknown'}`);

        // Perform Single Session & Auto-Subscription
        try {
          const { default: authService } = await import('./auth.service.js');
          const { default: User } = await import('../models/User.js');
          const { default: MasterSymbol } = await import('../models/MasterSymbol.js');

          const user = await User.findById(decoded.sub);
          if (!user) {
            ws.close(1008, 'User not found');
            return;
          }

          // 1. Single Session Verification
          if (user.tokenVersion && decoded.v !== user.tokenVersion) {
            logger.warn(`WS: Session mismatch for ${user.email}. Expected v:${user.tokenVersion}, got v:${decoded.v}`);
            ws.send(JSON.stringify({ type: 'error', payload: 'Session expired. Logged in on another device.' }));
            ws.close(1008, 'Session expired');
            return;
          }

          // 2. Auto-Subscribe to Plan Segments
          const planDetails = await authService.getUserActivePlan(user);
          const segments = authService.getSegmentsFromPermissions(planDetails.permissions);
          
          if (segments.length > 0) {
            const symbols = await MasterSymbol.find({ segment: { $in: segments }, isActive: true });
            const tickerNames = symbols.map(s => s.symbol);
            
            logger.info(`WS: Auto-subscribing user ${user.email} to ${tickerNames.length} symbols in segments: ${segments.join(', ')}`);
            
            tickerNames.forEach(sym => {
              subscribeToRoom(ws, sym);
            });

            // Send confirmation of active segments
            ws.send(JSON.stringify({ 
                type: 'subscription_sync', 
                payload: { segments, symbolCount: tickerNames.length } 
            }));
          } else {
             logger.info(`WS: User ${user.email} has no active plan segments to subscribe.`);
          }
        } catch (authErr) {
          logger.error('WS: Plan logic error during connection:', authErr.message);
        }
      });
    }

    ws.isAlive = true;
    ws.on('pong', () => { ws.isAlive = true; });

    ws.on('message', (message) => {
      try {
        const data = JSON.parse(message);
        const { type, payload } = data;

        switch (type) {
          case 'subscribe':
            subscribeToRoom(ws, payload?.toString().trim());
            break;
          case 'unsubscribe':
            unsubscribeFromRoom(ws, payload?.toString().trim());
            break;
          default:
            logger.warn(`Unknown message type: ${type}`);
        }
      } catch (error) {
        logger.error('WebSocket Message Error:', error.message);
      }
    });

    ws.on('close', () => {
      logger.debug('WebSocket connection closed');
      removeFromAllRooms(ws);
    });

    ws.on('error', (error) => {
      logger.error('WebSocket Error:', error.message);
      removeFromAllRooms(ws);
    });
  });

  // Keep-alive heartbeat
  const interval = setInterval(() => {
    wss.clients.forEach((ws) => {
      if (ws.isAlive === false) return ws.terminate();
      ws.isAlive = false;
      ws.ping();
    });
  }, 30000);

  wss.on('close', () => {
    clearInterval(interval);
  });

  // --- PIPELINE & REDIS SETUP ---

  // 1. Start In-Memory Pipeline (Fast Path)
  pipeline.start((tick) => {
      // Use broadcastToRoom (defined below, but available at runtime)
      broadcastToRoom(tick.symbol, { type: 'tick', payload: tick });
  });

  // 2. Subscribe to Low-Freq Stats via Redis
  redisSubscriber.subscribe('market_stats', (err) => {
    if (err) logger.error('Failed to subscribe to market_stats channel');
  });

  // Note: market_data via Redis is DISABLED for performance (Pipeline is used). 
  // If scaling to multiple nodes, re-enable Redis or use Pipeline->Redis bridge.

  redisSubscriber.on('message', (channel, message) => {
    try {
      const data = JSON.parse(message);

      if (channel === 'market_stats') {
        broadcastToAll({ type: 'market_stats', payload: data });
      }
    } catch (error) {
      logger.error('WebSocket Broadcast Error', error);
    }
  });

  // Handle log broadcasting via emitter to avoid circular dependency
  logEmitter.on('log', (log) => {
    broadcastLog(log);
  });

  logger.info('WebSocket Server initialized (ws)');
  return wss;
};

const subscribeToRoom = async (ws, roomName) => {
  if (!roomName) return;
  const normalized = roomName.toString().trim().toLowerCase();
  if (!rooms.has(normalized)) {
    rooms.set(normalized, new Set());
  }
  rooms.get(normalized).add(ws);
  logger.info(`WebSocket: Room Subscribed -> [${normalized}] (Total: ${rooms.get(normalized).size} clients)`);

  // TICK REPLAY
  try {
    const { default: marketDataService } = await import('./marketData.service.js');
    // Case-insensitive lookup in currentPrices
    const prices = marketDataService.currentPrices || {};
    const exactSymbol = Object.keys(prices).find(s => s.toLowerCase() === normalized);
    
    if (exactSymbol && prices[exactSymbol]) {
       const price = prices[exactSymbol];
       const tick = {
           symbol: exactSymbol,
           price: price,
           last_price: price,
           timestamp: new Date().toISOString(),
           provider: 'cached'
       };
       if (ws.readyState === WebSocket.OPEN) {
           ws.send(JSON.stringify({ type: 'tick', payload: tick }));
       }
    }
  } catch (e) {
      // Passive fail
  }
};

const logActiveRooms = () => {
  if (rooms.size === 0) {
    logger.info('WebSocket: No active rooms.');
    return;
  }
  const summary = Array.from(rooms.entries()).map(([room, clients]) => `${room}(${clients.size})`).join(', ');
  logger.info(`WebSocket: Active Rooms -> [${summary}]`);
};

// Log room status every 30 seconds
setInterval(logActiveRooms, 30000);

const unsubscribeFromRoom = (ws, roomName) => {
  if (!roomName) return;
  const normalized = roomName.toString().trim().toLowerCase();
  if (!rooms.has(normalized)) return;
  rooms.get(normalized).delete(ws);
  if (rooms.get(normalized).size === 0) {
    rooms.delete(normalized);
  }
  logger.debug(`WebSocket unsubscribed from room: ${normalized}`);
};

const removeFromAllRooms = (ws) => {
  rooms.forEach((clients, roomName) => {
    if (clients.has(ws)) {
      clients.delete(ws);
      if (clients.size === 0) {
        rooms.delete(roomName);
      }
    }
  });
};

const broadcastToRoom = (roomName, data) => {
  const normalizedRoom = roomName?.toString().trim().toLowerCase();
  const clients = rooms.get(normalizedRoom);
  if (clients && clients.size > 0) {
    // logger.info(`WebSocket: Broadcasting to room [${normalizedRoom}] -> Type: [${data.type}] (Clients: ${clients.size})`);
    const message = JSON.stringify(data);
    clients.forEach((client) => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  } else {
    // logger.warn(`WebSocket: Broadcast attempt to EMPTY room [${normalizedRoom}] -> Type: [${data.type}]`);
  }
};

const broadcastToAll = (data) => {
  const message = JSON.stringify(data);
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
};

const getWss = () => {
  if (!wss) {
    throw new Error('WebSocket Server not initialized!');
  }
  return wss;
};

const broadcastLog = (log) => {
  broadcastToAll({ type: 'system_log', payload: log });
};

const sendToUser = (userId, data) => {
  if (!wss) return;
  const message = JSON.stringify(data);
  let count = 0;
  wss.clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN && client.decoded && client.decoded.sub === userId) {
      client.send(message);
      count++;
    }
  });
  if (count > 0) {
    logger.info(`WebSocket: Sent targeted message to User [${userId}] (Clients: ${count})`);
  } else {
    logger.debug(`WebSocket: User [${userId}] not connected for targeted message`);
  }
};

export {
  initWebSocket,
  getWss,
  broadcastToRoom,
  broadcastToAll,
  broadcastLog,
  sendToUser
};
</file>

<file path="src/services/websocketManager.js">
import { connectionPool } from '../utils/connection-pool.js';
import logger from '../config/logger.js';
import allTickService from './alltick.service.js';
import metricsCollector from '../monitoring/metricsCollector.js';

// --- Worker Class ---
class PartitionWorker {
    constructor(id) {
        this.id = id;
        this.symbols = new Set();
        this.ws = null;
        this.reconcileTimer = null;
        this.heartbeatTimer = null;
        this.lastHeartbeatTime = 0;
    }

    startHeartbeat() {
        this.stopHeartbeat();
        logger.info(`[WS-Worker ${this.id}] Starting Heartbeat Loop`);
        
        // Send immediate first beat
        this.sendHeartbeat();

        this.heartbeatTimer = setInterval(() => {
            this.sendHeartbeat();
        }, 10000);
    }

    sendHeartbeat() {
        if (this.ws && this.ws.readyState === 1) {
            logger.info(`[WS-Worker ${this.id}] Sending Heartbeat (22000)`);
            this.lastHeartbeatTime = Date.now();
            this.ws.send(JSON.stringify({
                cmd_id: 22000,
                seq_id: Math.floor(Date.now() / 1000), // Simple Int Timestamp
                trace: 'hb' + Date.now()
            }));
        } else {
            logger.warn(`[WS-Worker ${this.id}] Cannot send Heartbeat - Socket not OPEN`);
        }
    }

    stopHeartbeat() {
        if (this.heartbeatTimer) {
            clearInterval(this.heartbeatTimer);
            this.heartbeatTimer = null;
        }
    }

    get count() {
        return this.symbols.size;
    }

    add(symbol) {
        this.symbols.add(symbol);
        this.scheduleReconcile();
    }

    remove(symbol) {
        this.symbols.delete(symbol);
        this.scheduleReconcile();
    }

    scheduleReconcile() {
        if (this.reconcileTimer) clearTimeout(this.reconcileTimer);
        this.reconcileTimer = setTimeout(() => this.reconcile(), 100); // 100ms debounce
    }

    async reconcile() {
        // If empty, we might want to close connection or just stay idle?
        // For now, keep connection but send empty subscribe? 
        // AllTick API: cmd_id 22004 with symbol_list.
        
        if (this.symbols.size === 0) {
            // No symbols, maybe close socket to save resources?
            // connectionPool.removeConnection(this.id); 
            // but for now, let's just do nothing or send empty?
            return; 
        }

        const symbolList = Array.from(this.symbols);
        if (!allTickService.token) {
            logger.warn(`[WS-Worker ${this.id}] Skipping Reconcile - No Token Available`);
            return;
        }
        const tokenPreview = allTickService.token.substring(0, 5) + '...';
        logger.info(`[WS-Worker ${this.id}] Reconcile: ${symbolList.length} symbols. Token: ${tokenPreview}`);
        logger.info(`[WS-Worker ${this.id}] Symbols: ${JSON.stringify(symbolList)}`);
        const url = `${allTickService.wsUrl}?token=${allTickService.token}`;
        
        try {
            // Get Connection from Pool
            this.ws = await connectionPool.getConnection(this.id, {
                url,
                maxRetries: 100,
                baseBackoff: 2000,
                maxBackoff: 60000,
                heartbeatInterval: 0 // DISABLE NATIVE HEARTBEAT (Conflict with App Level HB)
            });
            
            // Send Subscribe Command
            // Need to map symbols if Aliases used? 
            // Assuming Manager passes valid ALLTICK codes or we map here.
            // Let's assume Manager handles mapping or we ask AllTickService.
            const codes = symbolList.map(s => allTickService.aliasMap[s] || s);

            const payload = {
                cmd_id: 22002, // MSPK: Subscribe to DEPTH (Level 2) for Bid/Ask
                seq_id: Math.floor(Date.now() / 1000),
                trace: 'sub' + Date.now(),
                data: { 
                    symbol_list: codes.map(c => ({ code: c, depth_level: 5 })) 
                }
            };
            
            if (this.ws.readyState === 1) { // OPEN
                this.ws.send(JSON.stringify(payload));
                // logger.debug(`[WS-Worker ${this.id}] Subscribed to ${codes.length} symbols`);
            } else {
                // If not open, Pool will handle reconnect and 'open' event?
                // We should listen to 'open' to resubscribe.
                // NOTE: ConnectionPool emits events globally.
            }
        } catch (e) {
            logger.error(`[WS-Worker ${this.id}] Reconcile Failed: ${e.message}`);
        }
    }
}

// --- Manager Class ---
class WebSocketManager {
    constructor() {
        this.MAX_SYMBOLS_PER_WORKER = 200; // AllTick allows hundreds per connection
        this.viewportInterest = new Map(); // Symbol -> Expiry Time
        this.workers = new Map(); // ID -> PartitionWorker
        this.symbolToWorker = new Map(); // Symbol -> WorkerID
        this.messageBuffer = new Map(); // Symbol -> Latest Tick
        this.bufferTimer = null;
        this.marketDataService = null;

        // Cleanup Interval (60s)
        setInterval(() => this.cleanupViewport(), 60000);
        
        // Listen to Pool Messages globally to route them
        // This is efficient? Or should Workers listen to their specific ID?
        // Pool emits `message:${id}`. Workers should handle their own message parsing?
        // Or Manager handles all and routes?
        // Let's have Manager handle all for Batching Centralization.
    }

    init(marketDataService) {
        this.marketDataService = marketDataService;
        
        // Start Buffer Flush Loop
        this.bufferTimer = setInterval(() => this.flushBuffer(), 500); 
    }

    /**
     * Update what the User is verifying looking at
     * @param {string[]} symbols 
     */
    updateViewport(symbols) {
        const now = Date.now();
        // Update Interest
        symbols.forEach(s => {
            if (!s) return;
            if (s.includes(':')) return; // Safety: Reject NSE/MCX symbols
            this.viewportInterest.set(s, now + 60000); // 60s TTL
        });

        this.rebalance();
    }

    cleanupViewport() {
        const now = Date.now();
        let changed = false;
        
        for (const [sym, expiry] of this.viewportInterest) {
            // Keep "Essentials" always?
            // Assuming Essentials are handled by checking `marketDataService` or hardcoded?
            // For now, if expired, remove.
            if (now > expiry) {
                this.viewportInterest.delete(sym);
                changed = true;
            }
        }

        if (changed) this.rebalance();
    }

    rebalance() {
        // Current Desired Set
        const desiredTypes = new Set(this.viewportInterest.keys());
        
        // Add Essentials (Hardcoded for now or from Config)
        const essentials = ['BTCUSD', 'ETHUSD', 'XAUUSD', 'EURUSD'];
        essentials.forEach(s => desiredTypes.add(s));

        // Sync with Actual Workers
        const currentActive = new Set(this.symbolToWorker.keys());
        
        // Reporting
        metricsCollector.updateWsConnections(this.workers.size);

        // 1. Remove Unwanted
        for (const sym of currentActive) {
            if (!desiredTypes.has(sym)) {
                this._removeSymbol(sym);
            }
        }

        // 2. Add New
        for (const sym of desiredTypes) {
            if (!currentActive.has(sym)) {
                this._addSymbol(sym);
            }
        }
    }

    _addSymbol(symbol) {
        // Find suitable worker
        let worker = null;
        for (const w of this.workers.values()) {
            if (w.count < this.MAX_SYMBOLS_PER_WORKER) {
                worker = w;
                break;
            }
        }

        // Create new if needed
        if (!worker) {
            // Partitioning: Create new worker with incremental ID
            const id = `alltick_${this.workers.size}`; 
            worker = new PartitionWorker(id);
            this.workers.set(id, worker);
            this._setupWorkerListener(id);
        }

        worker.add(symbol);
        this.symbolToWorker.set(symbol, worker.id);
    }

    _removeSymbol(symbol) {
        const wid = this.symbolToWorker.get(symbol);
        if (wid) {
            const worker = this.workers.get(wid);
            if (worker) worker.remove(symbol);
            this.symbolToWorker.delete(symbol);
        }
    }

    _setupWorkerListener(id) {
        // Bind to Pool Events
        connectionPool.on(`message:${id}`, (data) => {
            this._handleWorkerMessage(id, data);
        });
        
        
        // On Open, trigger reconcile for that worker (Resubscribe)
        connectionPool.on(`open:${id}`, () => {
             logger.info(`[WS-Manager] Link Open Event received for ${id}`);
             const worker = this.workers.get(id);
             if (worker) {
                 worker.reconcile();
                 worker.startHeartbeat();
                 this._updateGlobalStatus();
             }
        });

        connectionPool.on(`close:${id}`, () => {
            const worker = this.workers.get(id);
            if (worker) {
                worker.stopHeartbeat();
                this._updateGlobalStatus();
            }
        });
    }

    _updateGlobalStatus() {
        let anyConnected = false;
        for (const worker of this.workers.values()) {
            if (worker.ws && worker.ws.readyState === 1) {
                anyConnected = true;
                break;
            }
        }
        allTickService.isConnected = anyConnected;
    }

    _handleWorkerMessage(id, data) {
        try {
            const message = JSON.parse(data.toString());
            const worker = this.workers.get(id);

            // Handle Heartbeat Response (cmd_id 22000/22001)
            if (message.cmd_id === 22000 || message.cmd_id === 22001 || (message.trace && message.trace.startsWith('hb-'))) {
                logger.info(`[WS-Manager] Received Heartbeat ACK from ${id}`);
                if (worker && worker.lastHeartbeatTime) {
                    const rtt = Date.now() - worker.lastHeartbeatTime;
                    allTickService.latency = rtt > 0 ? rtt : 1;
                    allTickService.isConnected = true; // Confirmation
                }
                return;
            }
            
             if (message.cmd_id === 22998 && message.data) { // Tick
                 this._bufferTick(message.data);
             } else if (message.cmd_id === 22999 && message.data) { // Depth
                 this._bufferDepth(message.data);
             } else {
                 // Spy on unknown messages to debug "Silence"
                 logger.info(`[WS-Worker ${id}] Received Non-Tick Message: ${JSON.stringify(message).substring(0, 200)}`);
             }
        } catch (e) {
            // ignore JSON Error
        }
    }

    _bufferTick(tick) {
        const symbol = tick.code; // Need to map alias back?
        // Using raw code for buffer, map later
        
        this.messageBuffer.set(symbol, {
            symbol: symbol,
            last_price: parseFloat(tick.price),
            timestamp: new Date(parseInt(tick.tick_time || Date.now())),
            ohlc: {
                open: parseFloat(tick.open),
                high: parseFloat(tick.high),
                low: parseFloat(tick.low),
                close: parseFloat(tick.price)
            },
            volume: parseFloat(tick.volume),
            // Capture Bid/Ask if present in Tick (rare but possible)
            bid: parseFloat(tick.bid || 0),
            ask: parseFloat(tick.ask || 0)
        });
    }

    _bufferDepth(tick) {
        const symbol = tick.code;
        const bid = parseFloat(tick.bids?.[0]?.price || 0);
        const ask = parseFloat(tick.asks?.[0]?.price || 0);
        const price = parseFloat(tick.price || bid || ask || 0); // Use Tick Price if available in Depth, else mid

        if (price === 0) return;

        this.messageBuffer.set(symbol, {
            symbol: symbol,
            last_price: price,
            timestamp: new Date(parseInt(tick.tick_time || Date.now())),
            ohlc: { open: price, high: price, low: price, close: price },
            volume: 0,
            // CRITICAL: Pass Depth Data
            bid: bid,
            ask: ask
        });
    }

    flushBuffer() {
        if (this.messageBuffer.size === 0 || !this.marketDataService) return;

        const ticks = Array.from(this.messageBuffer.values()).map(t => {
            // Alias Mapping Back
            // Inverse lookup aliasMap? or just use what we have
            const realSym = Object.keys(allTickService.aliasMap).find(key => allTickService.aliasMap[key] === t.symbol) || t.symbol;
            return { ...t, symbol: realSym };
        });

        // Clear Buffer
        this.messageBuffer.clear();

        // Send to MarketData
        if (ticks.length > 0) {
            logger.info(`[WS-Manager] Flushing ${ticks.length} ticks to MarketDataService`);
            this.marketDataService.processLiveTicks(ticks, 'alltick');
            metricsCollector.trackWsMessage(); // Count batches or ticks? Let's count batches. 
            // Or maybe count raw ticks? "Messages/Second" usually means frames. 
            // Since we send 1 frame to Frontend via socket.js (which we track later?), 
            // here we track internal throughput.
        }
    }
}

export default new WebSocketManager();
</file>

<file path="src/services/whatsapp.service.js">
import axios from 'axios';
import logger from '../config/logger.js';

class WhatsappService {
    constructor() {
        this.token = process.env.WHATSAPP_ACCESS_TOKEN;
        this.phoneId = process.env.WHATSAPP_PHONE_NUMBER_ID;
        this.baseUrl = 'https://graph.facebook.com/v17.0';
        
        if (!this.token || !this.phoneId) {
             // logger.warn('WHATSAPP: Credentials missing in .env'); 
        }
    }

    initialize(token, phoneId) {
        this.token = token;
        this.phoneId = phoneId;
        
        if (!this.token || !this.phoneId) {
            logger.warn('WHATSAPP: Missing Credentials. Service disabled.');
        } else {
            logger.info('WHATSAPP: Service Initialized');
        }
    }

    /**
     * Send a Text Message
     * @param {string} to - Recipient Phone Number (e.g., '919876543210')
     * @param {string} message - Text body
     */
    async sendTextMessage(to, message) {
        if (!this.token) {
            console.error('WHATSAPP: No Token Found! Check .env');
            return;
        }

        // Sanitize Phone: Remove all non-numeric characters (e.g. +, spaces, -)
        let cleanPhone = to.replace(/\D/g, '');
        
        // Auto-add text country code for India if missing (Common issue)
        if (cleanPhone.length === 10) {
            cleanPhone = '91' + cleanPhone;
        }
        
        console.log(`WHATSAPP: Sending to ${cleanPhone} (Original: ${to})`);

        try {
            const url = `${this.baseUrl}/${this.phoneId}/messages`;
            const payload = {
                messaging_product: 'whatsapp',
                to: cleanPhone,
                type: 'text',
                text: { body: message }
            };

            const res = await axios.post(url, payload, {
                headers: { 
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            console.log(`WHATSAPP: Success! Message ID: ${res.data.messages?.[0]?.id}`);
        } catch (error) {
            console.error('WHATSAPP: Send Error');
            if (error.response) {
                console.error('Data:', JSON.stringify(error.response.data, null, 2));
            } else {
                console.error('Message:', error.message);
            }
        }
    }

    /**
     * Send a Template Message (For Notifications/OTP)
     * @param {string} to - Recipient Phone
     * @param {string} templateName - Name of template in Meta Manager
     * @param {Array} variables - List of variables for body (e.g. ['Aqib', 'Welcome'])
     * @param {string} language - Language code (default 'en_US')
     */
    async sendTemplate(to, templateName, variables = [], language = 'en_US') {
        if (!this.token) return;

        try {
            const components = [];
            if (variables.length > 0) {
                 components.push({
                    type: 'body',
                    parameters: variables.map(v => ({ type: 'text', text: v }))
                 });
            }

            const url = `${this.baseUrl}/${this.phoneId}/messages`;
            const payload = {
                messaging_product: 'whatsapp',
                to: to,
                type: 'template',
                template: {
                    name: templateName,
                    language: { code: language },
                    components: components
                }
            };

            await axios.post(url, payload, {
                headers: { 
                    'Authorization': `Bearer ${this.token}`,
                    'Content-Type': 'application/json'
                }
            });
            logger.info(`WHATSAPP: Sent template ${templateName} to ${to}`);
        } catch (error) {
            logger.error('WHATSAPP: Template Error', error.response?.data || error.message);
        }
    }

    /**
     * Welcome New User (Auto-Reply Logic Placeholder)
     */
    async sendWelcomeMessage(to, userName) {
        // You can switch this to a 'hello_world' template later if needed
        const msg = `Welcome ${userName} to MSPK Trading! üöÄ\nWe are glad to have you.`;
        await this.sendTextMessage(to, msg);
    }
}

export const whatsappService = new WhatsappService();
</file>

<file path="src/utils/ApiError.js">
class ApiError extends Error {
  constructor(statusCode, message, isOperational = true, stack = '') {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    if (stack) {
      this.stack = stack;
    } else {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}

export default ApiError;
</file>

<file path="src/utils/catchAsync.js">
const catchAsync = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch((err) => next(err));
};

export default catchAsync;
</file>

<file path="src/utils/connection-pool.js">
import { EventEmitter } from 'events';
import WebSocket from 'ws';
import logger from '../config/logger.js';

/**
 * @typedef {Object} ConnectionOptions
 * @property {string} url - WebSocket URL
 * @property {string} [name='AvailableSocket'] - Connection identifier
 * @property {number} [maxRetries=10] - Max reconnect attempts
 * @property {number} [baseBackoff=1000] - Initial retry delay (ms)
 * @property {number} [maxBackoff=30000] - Max retry delay (ms)
 * @property {number} [heartbeatInterval=30000] - Ping interval (ms)
 */

class ConnectionPool extends EventEmitter {
    constructor(maxConnections = 5) {
        super();
        this.maxConnections = maxConnections;
        /** @type {Map<string, WebSocket>} */
        this.connections = new Map();
        /** @type {Map<string, Object>} */
        this.metadata = new Map();
        // WeakMap to associate listeners with sockets for precise cleanup
        this.listeners = new WeakMap(); 
        this.isShuttingDown = false;
    }

    /**
     * Get or create a managed connection
     * @param {string} id - Unique identifier for the connection
     * @param {ConnectionOptions} options
     * @returns {Promise<WebSocket>}
     */
    async getConnection(id, options) {
        if (this.connections.has(id)) {
            const ws = this.connections.get(id);
            if (ws.readyState === WebSocket.OPEN) return ws;
            // If closed/closing, remove and recreate
            this.removeConnection(id);
        }

        if (this.connections.size >= this.maxConnections) {
            throw new Error(`Connection pool limit reached (${this.maxConnections})`);
        }

        return this._createConnection(id, options);
    }

    _createConnection(id, options) {
        const { url, maxRetries = 10, baseBackoff = 1000, maxBackoff = 30000 } = options;
        
        logger.info(`[Pool] Creating connection: ${id}`);
        
        try {
            const ws = new WebSocket(url);
            
            // Metadata for recovery
            this.metadata.set(id, { 
                options, 
                retries: 0, 
                reconnectTimer: null,
                heartbeatTimer: null,
                isAlive: true
            });

            this.connections.set(id, ws);

            // Store bound listeners to allow precise removal
            const handlers = {
                open: () => this._handleOpen(id, ws),
                close: (code, reason) => this._handleClose(id, ws, code, reason),
                error: (err) => this._handleError(id, ws, err),
                message: (data) => this.emit(`message:${id}`, data),
                pong: () => {
                    const meta = this.metadata.get(id);
                     if(meta) meta.isAlive = true; 
                }
            };

            this.listeners.set(ws, handlers);

            // Bind Events
            ws.on('open', handlers.open);
            ws.on('close', handlers.close);
            ws.on('error', handlers.error);
            ws.on('message', handlers.message);
            ws.on('pong', handlers.pong);

            return ws;
        } catch (error) {
            logger.error(`[Pool] Creation failed for ${id}: ${error.message}`);
            this._scheduleReconnect(id);
        }
    }

    _handleOpen(id, ws) {
        logger.info(`[Pool] Connected: ${id}`);
        const meta = this.metadata.get(id);
        if (meta) {
            meta.retries = 0;
            meta.isAlive = true;
            
            // Fix: Check for undefined specifically so 0 is respected.
            const interval = meta.options.heartbeatInterval !== undefined 
                ? meta.options.heartbeatInterval 
                : 30000;
                
            this._startHeartbeat(id, ws, interval);
        }
        this.emit(`open:${id}`);
        this.emit('connect', id);
    }

    _handleClose(id, ws, code, reason) {
        if (this.isShuttingDown) return;
        logger.warn(`[Pool] Closed: ${id} (Code: ${code}, Reason: ${reason})`);
        this._cleanupConnection(id, ws);
        this._scheduleReconnect(id);
        this.emit(`close:${id}`, { code, reason });
    }

    _handleError(id, ws, error) {
        if (error.message?.includes('429')) {
            logger.warn(`[Pool] 429 Rate Limit detected for ${id}. Applying search cool-down.`);
            const meta = this.metadata.get(id);
            if (meta) {
                 meta.retries = Math.max(meta.retries, 5); // Jump to high backoff
            }
        }
        logger.error(`[Pool] Error in ${id}: ${error.message}`);
        this.emit(`error:${id}`, error);
    }

    _cleanupConnection(id, ws) {
        // Stop heartbeat
        const meta = this.metadata.get(id);
        if (meta && meta.heartbeatTimer) clearInterval(meta.heartbeatTimer);

        // Remove listeners explicitly to prevent leaks
        const handlers = this.listeners.get(ws);
        if (handlers) {
            ws.removeListener('open', handlers.open);
            ws.removeListener('close', handlers.close);
            ws.removeListener('error', handlers.error);
            ws.removeListener('message', handlers.message);
            ws.removeListener('pong', handlers.pong);
            this.listeners.delete(ws);
        }

        // Force terminate if still open
        try {
            if (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING) {
                ws.terminate();
            }
        } catch (e) { /* ignore */ }

        this.connections.delete(id);
    }

    _scheduleReconnect(id) {
        const meta = this.metadata.get(id);
        if (!meta || this.isShuttingDown) return;

        if (meta.retries >= (meta.options.maxRetries || 10)) {
            logger.error(`[Pool] Max retries reached for ${id}. Giving up.`);
            this.emit(`failed:${id}`);
            this.metadata.delete(id);
            return;
        }

        // Exponential backoff with jitter
        const delay = Math.min(
            meta.options.baseBackoff * Math.pow(2, meta.retries),
            meta.options.maxBackoff
        );
        const jitter = Math.random() * 1000;
        const finalDelay = delay + jitter;

        logger.info(`[Pool] Reconnecting ${id} in ${Math.round(finalDelay)}ms (Attempt ${meta.retries + 1})`);

        meta.reconnectTimer = setTimeout(() => {
            meta.retries++;
            this._createConnection(id, meta.options);
        }, finalDelay);
    }

    _startHeartbeat(id, ws, interval) {
        if (interval <= 0) return; // Disable heartbeat if interval is 0 or negative
        
        const meta = this.metadata.get(id);
        if (!meta) return;

        if (meta.heartbeatTimer) clearInterval(meta.heartbeatTimer);

        meta.heartbeatTimer = setInterval(() => {
            if (!meta.isAlive) {
                logger.warn(`[Pool] Heartbeat failed for ${id}. Terminating.`);
                ws.terminate(); // Will trigger 'close' logic
                return;
            }

            meta.isAlive = false;
            // Native Ping (if using 'ws' library)
            if (ws.ping) {
                ws.ping();
            } else {
                // Fallback for browser-like sockets if needed, but 'ws' has ping
                meta.isAlive = true; 
            }
        }, interval);
    }

    removeConnection(id) {
        const ws = this.connections.get(id);
        const meta = this.metadata.get(id);
        
        if (meta?.reconnectTimer) clearTimeout(meta.reconnectTimer);
        
        if (ws) {
            this._cleanupConnection(id, ws);
        }
        
        this.metadata.delete(id);
    }

    shutdown() {
        this.isShuttingDown = true;
        for (const id of this.connections.keys()) {
            this.removeConnection(id);
        }
    }
}

// Singleton export
export const connectionPool = new ConnectionPool();
export default ConnectionPool;
</file>

<file path="src/utils/encryption.js">
import crypto from 'crypto';
import logger from '../config/logger.js';

// Use a secure key from env or fallback for dev (32 bytes for AES-256)
const ENCRYPTION_KEY = process.env.ENCRYPTION_KEY || '12345678901234567890123456789012'; 
const IV_LENGTH = 16; // For AES, this is always 16

export const encrypt = (text) => {
    if (!text) return text;
    try {
        const iv = crypto.randomBytes(IV_LENGTH);
        const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY), iv);
        let encrypted = cipher.update(text);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        return iv.toString('hex') + ':' + encrypted.toString('hex');
    } catch (error) {
        logger.error('Encryption Failed', error);
        return text; // Fallback (or throw)
    }
};

export const decrypt = (text) => {
    if (!text) return text;
    try {
        const textParts = text.split(':');
        // If not encrypted format, return as is (backward compatibility)
        if (textParts.length !== 2) return text;

        const iv = Buffer.from(textParts[0], 'hex');
        const encryptedText = Buffer.from(textParts[1], 'hex');
        const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(ENCRYPTION_KEY), iv);
        let decrypted = decipher.update(encryptedText);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return decrypted.toString();
    } catch (error) {
        // logger.error('Decryption Failed', error);
        // Fail silently or return original text if decryption fails (e.g. key changed or not encrypted)
        return text;
    }
};
</file>

<file path="src/utils/pick.js">
/**
 * Create an object composed of the picked object properties
 * @param {Object} object
 * @param {string[]} keys
 * @returns {Object}
 */
const pick = (object, keys) => {
  return keys.reduce((obj, key) => {
    if (object && Object.prototype.hasOwnProperty.call(object, key)) {
      obj[key] = object[key];
    }
    return obj;
  }, {});
};

export default pick;
</file>

<file path="src/utils/pipeline/DataPipeline.js">
import { RingBuffer } from './RingBuffer.js';

class DataPipeline {
    constructor() {
        this.buffers = {
            high: new RingBuffer(20000), // Active symbols
            normal: new RingBuffer(50000), // Other subscribed
            low: new RingBuffer(10000)   // Background updates
        };
        
        this.activeSymbols = new Set();
        this.lastPriceMap = new Map(); // For deduplication
        
        this.wasmFilter = null; // Placeholder for WASM instance
        this.isRunning = false;
        
        // Stats
        this.metrics = {
            in: 0,
            out: 0,
            dropped: 0,
            dupes: 0
        };
    }

    start(broadcaster) {
        this.broadcaster = broadcaster; // Logic to actually send data (ws service)
        this.isRunning = true;
        this.process();
    }
    
    stop() {
        this.isRunning = false;
    }

    setActiveSymbols(symbols) {
        this.activeSymbols = new Set(symbols);
    }

    push(tick) {
        this.metrics.in++;
        
        // 1. Data Filter (WASM or JS Fallback)
        if (this.wasmFilter) {
             if (!this.wasmFilter.isValid(tick.price, tick.volume)) {
                 this.metrics.dropped++;
                 return;
             }
        } else {
             // Basic JS Sanity Check
             if (!tick.price || tick.price <= 0) {
                 this.metrics.dropped++;
                 return;
             }
        }

        // 2. Deduplication
        // Check if price changed significantly? or checks volume?
        // User asked for "Implement data deduplication".
        const key = tick.symbol;
        const last = this.lastPriceMap.get(key);
        
        // If price, vol, bid, ask are same -> Skip
        if (last && 
            last.price === tick.price && 
            last.volume === tick.volume &&
            last.bid === tick.bid &&
            last.ask === tick.ask
           ) {
            this.metrics.dupes++;
            return;
        }
        
        this.lastPriceMap.set(key, tick);

        // 3. Priority Queueing
        if (this.activeSymbols.has(tick.symbol)) {
            this.buffers.high.push(tick);
        } else {
            this.buffers.normal.push(tick);
        }
    }

    async process() {
        while (this.isRunning) {
            let processed = 0;
            const BATCH_SIZE = 100; // Process in chunks to yield event loop

            // High Priority First
            while (!this.buffers.high.isEmpty() && processed < BATCH_SIZE) {
                const tick = this.buffers.high.pop();
                if (tick) {
                    this.broadcaster(tick);
                    this.metrics.out++;
                    processed++;
                }
            }

            // Normal Priority (only if we have bandwidth/time)
            // Fair scheduling: process some normal even if high exists?
            // For now, strict priority.
            if (processed < BATCH_SIZE) {
                while (!this.buffers.normal.isEmpty() && processed < BATCH_SIZE) {
                     const tick = this.buffers.normal.pop();
                     if (tick) {
                         this.broadcaster(tick);
                         this.metrics.out++;
                         processed++;
                     }
                }
            }

            // Yield if we did work, else small sleep
            if (processed > 0) {
                if (global.setImmediate) await new Promise(r => setImmediate(r));
                else await new Promise(r => setTimeout(r, 0));
            } else {
                await new Promise(r => setTimeout(r, 5)); // Sleep 5ms if idle
            }
        }
    }

    getStats() {
        return this.metrics;
    }
}

export const pipeline = new DataPipeline();
export default pipeline;
</file>

<file path="src/utils/pipeline/filters.cpp">
// filters.cpp
// Compile: emcc filters.cpp -O3 -s WASM=1 -s SIDE_MODULE=1 -o filters.wasm

extern "C" {

    // Simple Noise Filter
    // Returns 1 if valid, 0 if noise
    int isValid(float price, float volume) {
        if (price <= 0) return 0;
        if (volume < 0) return 0;
        return 1;
    }

    // Significant Change Filter
    // Returns 1 if change > threshold %
    int isSignificant(float current, float last, float thresholdPercent) {
        if (last == 0) return 1;
        float diff = current - last;
        if (diff < 0) diff = -diff;
        
        float change = (diff / last) * 100.0;
        return (change >= thresholdPercent) ? 1 : 0;
    }

}
</file>

<file path="src/utils/pipeline/RingBuffer.js">
export class RingBuffer {
    constructor(capacity = 10000) {
        this.capacity = capacity;
        // Float32Array for structured data? 
        // Ticks have Symbol(string), Price, Vol, Time.
        // Mixed types. Pointer array is fastest in JS for mixed objects, 
        // but TypedArray is better for memory if we serialize.
        // User target: "Memory < 100MB buffer".
        // 100k ticks * 100 bytes = 10MB.
        // We will use a cyclic array of Objects for flexibility first, 
        // optimization to Structs if needed. JS Engine optimizes object pools well.
        
        this.buffer = new Array(capacity);
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }

    push(item) {
        this.buffer[this.head] = item;
        this.head = (this.head + 1) % this.capacity;
        if (this.size < this.capacity) {
            this.size++;
        } else {
            this.tail = (this.tail + 1) % this.capacity; // Overwrite oldest
        }
    }

    pop() {
        if (this.size === 0) return null;
        const item = this.buffer[this.tail];
        this.buffer[this.tail] = null; // Help GC
        this.tail = (this.tail + 1) % this.capacity;
        this.size--;
        return item;
    }

    peek() {
        if (this.size === 0) return null;
        return this.buffer[this.tail];
    }

    isEmpty() {
        return this.size === 0;
    }
    
    clear() {
        this.head = 0;
        this.tail = 0;
        this.size = 0;
    }
}
</file>

<file path="src/utils/pipeline/WasmLoader.js">
import fs from 'fs';
import path from 'path';

class WasmLoader {
    constructor() {
        this.instance = null;
        this.isReady = false;
        this.init();
    }

    async init() {
        try {
            const wasmPath = path.resolve(__dirname, 'filters.wasm');
            if (fs.existsSync(wasmPath)) {
                const buffer = fs.readFileSync(wasmPath);
                const module = await WebAssembly.compile(buffer);
                this.instance = await WebAssembly.instantiate(module);
                this.isReady = true;
                console.log('[Pipeline] WASM Filter Loaded');
            } else {
                console.log('[Pipeline] filters.wasm not found, using JS fallback');
            }
        } catch (e) {
            console.error('[Pipeline] WASM Load Error:', e);
        }
    }

    isValid(price, volume) {
        if (this.isReady && this.instance) {
            return this.instance.exports.isValid(price, volume) === 1;
        }
        // Fallback
        return price > 0 && volume >= 0;
    }
}

export default new WasmLoader();
</file>

<file path="src/utils/requestQueue.js">
import EventEmitter from 'events';
import logger from '../config/logger.js';

class RequestQueue extends EventEmitter {
    constructor(requestsPerMinute = 50) {
        super();
        this.requestsPerMinute = requestsPerMinute;
        this.intervalMs = (60000 / this.requestsPerMinute) * 1.2; // 1.2x safety buffer
        this.lastRequestTime = 0;
        
        // Queues by priority
        this.queues = {
            1: [], // Realtime (High)
            2: [], // Historical (Medium)
            3: []  // Bulk (Low)
        };

        this.pendingRequests = new Map(); // Key -> Promise
        this.isProcessing = false;
        this.currentJobKey = null; // Track current job
        
        // Stuck Job Detector
        setInterval(() => {
            if (this.isProcessing && this.currentJobKey) {
                const now = Date.now();
                if (now - this.lastRequestTime > 15000) { // 15s Threshold
                    logger.error(`[RequestQueue-Monitor] QUEUE STUCK on Job: ${this.currentJobKey} for ${(now - this.lastRequestTime)/1000}s`);
                    
                    // Optional: Force release? No, unsafe. Just log.
                    // But we can try to inspect memory or just know WHO it is.
                    // If it is 'alltick...', we know the culprit.
                }
            }
        }, 5000);
        
        // Metrics
        this.metrics = {
            totalRequests: 0,
            processed: 0,
            deduplicated: 0,
            errors: 0,
            rateLimited: 0,
            startTime: Date.now()
        };
    }

    /**
     * Add a request to the queue
     * @param {string} key - Unique key for deduplication
     * @param {Function} task - Async function to execute
     * @param {number} priority - 1 (High) to 3 (Low)
     * @returns {Promise}
     */
    add(key, task, priority = 2) {
        // 1. Deduplication
        if (this.pendingRequests.has(key)) {
            this.metrics.deduplicated++;
            return this.pendingRequests.get(key);
        }

        // 2. Create Promise Wrapper
        const promise = new Promise((resolve, reject) => {
            const wrappedTask = {
                key,
                task,
                resolve,
                reject,
                attempts: 0,
                addedAt: Date.now()
            };
            
            console.log(`[RequestQueue-Trace] Added: ${key} (Priority ${priority})`);

            // Add to appropriate queue
            if (!this.queues[priority]) priority = 2;
            this.queues[priority].push(wrappedTask);
            this.metrics.totalRequests++;
        });

        // 3. Store Promise for deduplication
        this.pendingRequests.set(key, promise);
        
        // 4. Cleanup on completion
        promise.finally(() => {
            this.pendingRequests.delete(key);
        });

        // 5. Trigger Processing
        this.process();

        return promise;
    }

    async process() {
        if (this.isProcessing) return;
        this.isProcessing = true;
        console.log(`[RequestQueue-Trace] Starting Process Loop`);

        while (this.hasRequests()) {
            const now = Date.now();
            const timeSinceLast = now - this.lastRequestTime;
            
            // Rate Limiting Wait
            if (timeSinceLast < this.intervalMs) {
                const wait = this.intervalMs - timeSinceLast;
                await new Promise(r => setTimeout(r, wait));
            }

            // Check Pause
            if (this.pausedUntil && Date.now() < this.pausedUntil) {
                const wait = this.pausedUntil - Date.now();
                await new Promise(r => setTimeout(r, wait));
                this.pausedUntil = 0; // Clear after waiting
            }

            // Get next task (Priority 1 -> 2 -> 3)
            const job = this.getNextJob();
            if (!job) break;

            this.lastRequestTime = Date.now();

            try {
                this.currentJobKey = job.key;
                logger.info(`[RequestQueue-Trace] Executing Job: ${job.key}`);
                const result = await job.task();
                this.metrics.processed++;
                job.resolve(result);
            } catch (error) {
                // Rate Limit Handling (429)
                if (error.response && error.response.status === 429) {
                    this.metrics.rateLimited++;
                    job.attempts++;
                    
                    if (job.attempts <= 3) {
                        // Exponential Backoff: 2^attempts * 1000ms
                        const backoff = Math.pow(2, job.attempts) * 1000;
                        logger.warn(`[RequestQueue] 429 Hit. Retrying ${job.key} in ${backoff}ms (Attempt ${job.attempts})`);
                        
                        await new Promise(r => setTimeout(r, backoff));
                        
                        // Re-add to front of high priority queue to retry ASAP
                        this.queues[1].unshift(job); 
                    } else {
                        console.error(`[RequestQueue] Max retries reached for ${job.key}`);
                        this.metrics.errors++;
                        job.reject(error);
                    }
                } else {
                    logger.error(`[RequestQueue] Job Failed ${job.key}: ${error.message}`);
                    this.metrics.errors++;
                    job.reject(error);
                }
            } finally {
                 logger.info(`[RequestQueue-Trace] Job Finished: ${job.key}`);
                 this.currentJobKey = null;
            }
        }

        this.isProcessing = false;
        logger.info(`[RequestQueue-Trace] Loop Ended. Pending: ${this.pendingRequests.size}`);
    }

    hasRequests() {
        return this.queues[1].length > 0 || this.queues[2].length > 0 || this.queues[3].length > 0;
    }

    getNextJob() {
        if (this.queues[1].length > 0) return this.queues[1].shift();
        if (this.queues[2].length > 0) return this.queues[2].shift();
        if (this.queues[3].length > 0) return this.queues[3].shift();
        return null;
    }

    getStats() {
        const uptimeMinutes = (Date.now() - this.metrics.startTime) / 60000;
        return {
            pending: this.queues[1].length + this.queues[2].length + this.queues[3].length,
            rpm: uptimeMinutes > 0 ? (this.metrics.processed / uptimeMinutes).toFixed(2) : 0,
            dedupStats: `${this.metrics.deduplicated}/${this.metrics.totalRequests}`,
            activePromises: this.pendingRequests.size,
            conf: {
                interval: this.intervalMs.toFixed(0) + 'ms',
                limit: this.requestsPerMinute
            }
        };
    }

    emergencyThrottle() {
        console.warn('[RequestQueue] Emergency Throttle Activated!');
        this.requestsPerMinute = 30;
        this.intervalMs = (60000 / 30) * 1.2;
    }

    /**
     * Pause the queue processing for a duration
     * @param {number} durationMs 
     */
    pause(durationMs) {
        console.warn(`[RequestQueue] PAUSED for ${durationMs / 1000}s`);
        this.pausedUntil = Date.now() + durationMs;
    }
}

// Singleton Instance
const requestQueue = new RequestQueue();

export default requestQueue;
</file>

<file path="src/utils/technicalIndicators.js">
/**
 * Calculate RSI (Relative Strength Index)
 * @param {Array<number>} closes - Array of closing prices (newest last)
 * @param {number} period - RSI Period (default 14)
 * @returns {number} RSI Value (0-100)
 */
export const calculateRSI = (closes, period = 14) => {
    if (!closes || closes.length < period + 1) return 50; // Not enough data, return neutral

    let gains = 0;
    let losses = 0;

    // Calculate initial average
    for (let i = 1; i <= period; i++) {
        const change = closes[i] - closes[i - 1];
        if (change > 0) gains += change;
        else losses += Math.abs(change);
    }

    let avgGain = gains / period;
    let avgLoss = losses / period;

    // Smooth subsequent values
    for (let i = period + 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        let gain = change > 0 ? change : 0;
        let loss = change < 0 ? Math.abs(change) : 0;

        avgGain = (avgGain * (period - 1) + gain) / period;
        avgLoss = (avgLoss * (period - 1) + loss) / period;
    }

    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
};

/**
 * Get Fear & Greed Label from RSI
 */
export const getFearGreedFromRSI = (rsi) => {
    if (rsi >= 80) return { label: "Extreme Greed", score: Math.round(rsi) };
    if (rsi >= 60) return { label: "Greed", score: Math.round(rsi) };
    if (rsi <= 20) return { label: "Extreme Fear", score: Math.round(rsi) };
    if (rsi <= 40) return { label: "Fear", score: Math.round(rsi) };
    return { label: "Neutral", score: Math.round(rsi) };
};
</file>

<file path="src/validations/admin.validation.js">
import Joi from 'joi';

const objectId = (value, helpers) => {
  if (!value.match(/^[0-9a-fA-F]{24}$/)) {
    return helpers.message('"{{#label}}" must be a valid mongo id');
  }
  return value;
};

const createUser = {
  body: Joi.object().keys({
    email: Joi.string().required().email(),
    password: Joi.string().required().min(6),
    name: Joi.string().required(),
    phone: Joi.string().optional().allow(''),
    role: Joi.string().required().valid('user', 'admin', 'sub-broker'),
    
    // Trading / Admin Fields
    clientId: Joi.string().optional().allow(''),
    equity: Joi.number().optional().min(0),
    walletBalance: Joi.number().optional().min(0),
    subBrokerId: Joi.string().custom(objectId).optional().allow(null, ''),
    
    // Subscription
    planId: Joi.string().custom(objectId).optional().allow(null, ''),
    
    status: Joi.string().valid('Active', 'Inactive', 'Suspended').default('Active'),
  }),
};

const updateUser = {
  params: Joi.object().keys({
      userId: Joi.required().custom(objectId),
  }),
  body: Joi.object().keys({
      email: Joi.string().email(),
      password: Joi.string().min(6), // Optional update
      name: Joi.string(),
      phone: Joi.string().allow(''),
      role: Joi.string().valid('user', 'admin', 'sub-broker'),
      clientId: Joi.string().allow(''),
      equity: Joi.number().min(0),
      walletBalance: Joi.number().min(0),
      subBrokerId: Joi.string().custom(objectId).allow(null, ''),
      planId: Joi.string().custom(objectId).allow(null, ''), // Allow switching plan
      status: Joi.string().valid('Active', 'Inactive', 'Suspended', 'Blocked', 'Liquidated'), // Includes new statuses
  }).min(1), // Require at least 1 field to update
};

export default {
  createUser,
  updateUser
};
</file>

<file path="src/validations/auth.validation.js">
import Joi from 'joi';

const register = {
  body: Joi.object().keys({
    email: Joi.string().required().email(),
    password: Joi.string().required().min(6), // custom regex if needed
    name: Joi.string().required(),
    phone: Joi.string().optional(),
    referralCode: Joi.string().optional(),
  }),
};

const login = {
  body: Joi.object().keys({
    email: Joi.string().required(),
    password: Joi.string().required(),
    deviceId: Joi.string().optional(),
    ip: Joi.string().optional(),
    sessionId: Joi.string().optional(),
  }),
};

const updateProfile = {
    body: Joi.object().keys({
        name: Joi.string(),
        phone: Joi.string(),
        isWhatsAppEnabled: Joi.boolean(),
        isNotificationEnabled: Joi.boolean(),
        profile: Joi.object().keys({
            avatar: Joi.string().uri(),
            address: Joi.string(),
            city: Joi.string(),
            state: Joi.string()
        })
    }).min(1)
};

const updateKyc = {
    body: Joi.object().keys({
        panCard: Joi.string().uri(),
        aadhaarCard: Joi.string().uri()
    }).min(1)
};

const sendOtp = {
    body: Joi.object().keys({
        type: Joi.string().required().valid('phone', 'email'),
        identifier: Joi.string().required(),
    }),
};

const verifyOtp = {
    body: Joi.object().keys({
        type: Joi.string().required().valid('phone', 'email'),
        identifier: Joi.string().required(),
        otp: Joi.string().required().min(4).max(6),
    }),
};

export default {
  register,
  login,
  updateProfile,
  updateKyc,
  sendOtp,
  verifyOtp
};
</file>

<file path="src/validations/plan.validation.js">
import Joi from 'joi';

const createPlan = {
  body: Joi.object().keys({
    name: Joi.string().required(),
    description: Joi.string(),
    segment: Joi.string().required().valid('EQUITY', 'FNO', 'COMMODITY', 'CURRENCY'),
    price: Joi.number().required(),
    durationDays: Joi.number().integer().required(),
    features: Joi.array().items(Joi.string()),
    isActive: Joi.boolean(),
    isDemo: Joi.boolean()
  }),
};

const getPlans = {
  query: Joi.object().keys({
    role: Joi.string(), // To filter inactive if needed manually
  }),
};

const getPlan = {
  params: Joi.object().keys({
    planId: Joi.string().required(), // Check ObjectId regex if needed
  }),
};

const updatePlan = {
  params: Joi.object().keys({
    planId: Joi.string().required(),
  }),
  body: Joi.object()
    .keys({
      name: Joi.string(),
      description: Joi.string(),
      segment: Joi.string().valid('EQUITY', 'FNO', 'COMMODITY', 'CURRENCY'),
      price: Joi.number(),
      durationDays: Joi.number().integer(),
      features: Joi.array().items(Joi.string()),
      isActive: Joi.boolean(),
      isDemo: Joi.boolean()
    })
    .min(1),
};

export default {
  createPlan,
  getPlans,
  getPlan,
  updatePlan,
};
</file>

<file path="src/validations/signal.validation.js">
import Joi from 'joi';

const createSignal = {
  body: Joi.object().keys({
      symbol: Joi.string().required(),
      segment: Joi.string().valid('EQUITY', 'FNO', 'COMMODITY', 'CURRENCY').required(),
      type: Joi.string().valid('BUY', 'SELL').required(),
      entryPrice: Joi.number().required(), // Changed to number
      stopLoss: Joi.number().required(),
      targets: Joi.object().keys({
          target1: Joi.number().required(),
          target2: Joi.number(),
          target3: Joi.number()
      }).required(),
      isFree: Joi.boolean(),
      notes: Joi.string()
  })
};

const updateSignal = {
    params: Joi.object().keys({
        signalId: Joi.string().required()
    }),
    body: Joi.object().keys({
        status: Joi.string().valid('Active', 'Target Hit', 'Stoploss Hit', 'Closed'),
        report: Joi.object().keys({
            result: Joi.number(),
            closedAt: Joi.date(),
            closedPrice: Joi.number()
        }),
        notes: Joi.string()
    }).min(1)
};

const deleteSignal = {
    params: Joi.object().keys({
        signalId: Joi.string().required()
    })
};

export default {
  createSignal,
  updateSignal,
  deleteSignal
};
</file>

<file path="src/validations/strategy.validation.js">
import Joi from 'joi';

const createStrategy = {
  body: Joi.object().keys({
    name: Joi.string().required(),
    symbol: Joi.string().required(),
    timeframe: Joi.string().required().valid('1m', '5m', '15m', '1h', '4h', '1d'),
    action: Joi.string().valid('BUY', 'SELL', 'ALERT').required(),
    logic: Joi.object().keys({
      condition: Joi.string().valid('AND', 'OR').default('AND'),
      rules: Joi.array().items(
        Joi.object().keys({
          indicator: Joi.string().required(), // e.g., RSI
          params: Joi.object().required(), // e.g., { period: 14 }
          operator: Joi.string().valid('>', '<', '>=', '<=', '==', 'CROSS_ABOVE', 'CROSS_BELOW').required(),
          comparisonType: Joi.string().valid('VALUE', 'INDICATOR').default('VALUE'),
          value: Joi.alternatives().try(Joi.number(), Joi.object()).required() 
        })
      ).min(1).required()
    }).required()
  }),
};

const getStrategies = {
  query: Joi.object().keys({
    name: Joi.string(),
    symbol: Joi.string(),
    sortBy: Joi.string(),
    limit: Joi.number().integer(),
    page: Joi.number().integer(),
  }),
};

const getStrategy = {
  params: Joi.object().keys({
    strategyId: Joi.string().required(), // Validate ObjectId format if needed
  }),
};

export default {
  createStrategy,
  getStrategies,
  getStrategy,
};
</file>

<file path="src/validations/subscription.validation.js">
import Joi from 'joi';

const purchaseSubscription = {
  body: Joi.object().keys({
    planId: Joi.string().required(),
    paymentDetails: Joi.object().keys({
        gateway: Joi.string().valid('RAZORPAY', 'STRIPE', 'MANUAL').required(),
        success: Joi.boolean(), // Mock flag
        transactionId: Joi.string()
    }).required()
  }),
};

export default {
  purchaseSubscription,
};
</file>

<file path="src/workers/notification.worker.js">
import { Worker } from 'bullmq';
import config from '../config/config.js';
import logger from '../config/logger.js';
import User from '../models/User.js';
import Setting from '../models/Setting.js';
import telegramService from '../services/channels/telegram.service.js';
import { msg91Service } from '../services/index.js'; // Use Central MSG91 Service
import pushService from '../services/channels/push.service.js';
import templates from '../config/notificationTemplates.js';

const connection = {
  host: config.redis.host,
  port: config.redis.port,
};

const notificationWorker = new Worker('notifications', async (job) => {
  const { type, signal, announcement, userId } = job.data;
  
  try {
      // Fetch System Settings
      const settings = await Setting.find({ 
          key: { $in: ['telegram_config', 'whatsapp_config', 'push_config', 'notification_templates'] } 
      });
      
      const getSetting = (key) => {
          const s = settings.find(s => s.key === key);
          return s ? s.value : null;
      };

      const dbTemplates = getSetting('notification_templates') || {};
      const activeTemplates = { ...templates, ...dbTemplates };

      let user = null;
      if (userId && userId !== 'system') {
          user = await User.findById(userId);
      }
      
      if (!user && userId !== 'system') {
          logger.warn(`User ${userId} not found for notification`);
          return;
      }

      if (userId === 'system') {
           logger.warn('Skipping notification job for "system" user (Broadcast should fan-out IDs)');
           return;
      }

      const renderTemplate = (templateKey, data) => {
          const template = activeTemplates[templateKey] || activeTemplates.ANNOUNCEMENT;
          let title = template.title;
          let body = template.body;

          // Simple variable replacement
          Object.keys(data).forEach(key => {
              const regex = new RegExp(`{{${key}}}`, 'g');
              const val = data[key] !== undefined ? data[key] : '';
              title = title.replace(regex, val);
              body = body.replace(regex, val);
          });
          return { title, body };
      };

      let title = 'Notification';
      let message = '';
      
      if (signal) {
          // Flatten signal data for template
          const data = {
              symbol: signal.symbol,
              type: signal.type,
              entryPrice: signal.entryPrice,
              stopLoss: signal.stopLoss,
              target1: signal.targets?.target1 || '-',
              target2: signal.targets?.target2 || '-',
              target3: signal.targets?.target3 || '-',
              notes: signal.notes || '',
              
              // For Update/Target
              updateMessage: signal.updateMessage || '',
              targetLevel: signal.targetLevel || 'TP1',
              currentPrice: signal.currentPrice || signal.entryPrice // fallback
          };
          
          // Use subType passed from publisher (SIGNAL_NEW, SIGNAL_UPDATE, SIGNAL_TARGET, SIGNAL_STOPLOSS)
          const templateKey = signal.subType || 'SIGNAL_NEW';
          
          const rendered = renderTemplate(templateKey, data);
          title = rendered.title;
          message = rendered.body;
      } else if (announcement) {
          // Determine subtype
          let templateKey = 'ANNOUNCEMENT';
          if (announcement.type === 'ECONOMIC') templateKey = 'ECONOMIC_ALERT';
          if (announcement.type === 'REMINDER') templateKey = 'PLAN_EXPIRY_REMINDER';
          if (announcement.type === 'TICKET_REPLY') templateKey = 'TICKET_REPLY';
          
          const rendered = renderTemplate(templateKey, announcement);
          title = rendered.title;
          message = rendered.body;
      } else {
          logger.warn('Unknown notification payload');
          return;
      }

      if (type === 'telegram') {
          const teleConfig = getSetting('telegram_config');
          if (teleConfig && teleConfig.enabled && teleConfig.botToken && teleConfig.channelId) {
             await telegramService.sendTelegramMessage(teleConfig, message);
          }
      } 
       else if (type === 'whatsapp') {
           const waConfig = getSetting('whatsapp_config');
           // Strict Check: WhatsApp must be enabled in Admin Settings
           if (waConfig && waConfig.enabled) {
               // MSG91 WhatsApp requires Template + Components
               if (user.phoneNumber || user.phone) {
                   const phone = user.phoneNumber || user.phone;
                   let templateName = 'signal_alert';
                   let components = {};
    
                   if (signal) {
                       components = {
                           "1": signal.symbol,
                           "2": signal.type,
                           "3": signal.entryPrice,
                           "4": signal.stopLoss,
                           "5": signal.targets?.target1 || '-'
                       };
                   } else if (announcement) {
                       templateName = 'announcement_alert';
                       components = {
                           "1": announcement.title,
                           "2": announcement.message
                       };
                   }
    
                   await msg91Service.sendWhatsapp(phone, templateName, components);
               }
           } else {
               logger.debug(`Skipping WhatsApp for User ${userId} - Channel Disabled in Settings`);
           }
      }
      else if (type === 'push') {
          const pushConfig = getSetting('push_config');
          // If pushConfig exists and is enabled, we send. 
          if (pushConfig && pushConfig.enabled) {
              if (user.fcmTokens && user.fcmTokens.length > 0) {
                  // Prepare data payload for deep-linking
                  const pushData = { screen: "NOTIFICATIONS" };
                  if (signal) pushData.signalId = signal._id;
                  if (announcement) pushData.announcementId = announcement._id;

                  logger.info(`[PushWorker] Sending to User ${userId}. Tokens: ${user.fcmTokens.length}. Title: ${title}`);
                  
                  const result = await pushService.sendPushNotification(
                      user.fcmTokens, 
                      title, 
                      message,
                      pushData
                  );
                  logger.info(`[PushWorker] Send Result for User ${userId}: Success=${result.successCount}, Failure=${result.failureCount}`);
                  
                  if (result.failureCount > 0 && result.results) {
                       // Log specific error codes
                       const errors = result.results.filter(r => r.error).map(r => r.error);
                       if (errors.length > 0) {
                           logger.error(`[FCM_FAIL_DETAILS] User ${userId} Errors: ${JSON.stringify(errors.map(e => ({ code: e.code, message: e.message })))}`);
                       }
                  }
              }
          }
      }
      
      logger.info(`Processed ${type} notification for job ${job.id}`);
  } catch (error) {
      logger.error(`Failed to process notification job ${job.id}`, error);
  }
}, { connection });

notificationWorker.on('completed', (job) => {
  logger.debug(`Job ${job.id} completed`);
});

notificationWorker.on('failed', (job, err) => {
  logger.error(`Job ${job.id} failed: ${err.message}`);
});

export default notificationWorker;
</file>

</files>
